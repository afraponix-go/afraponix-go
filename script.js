// Debug: Test if script loads
console.log('üöÄ script.js starting to load...');

// Import UI Components
import { SystemManagementComponent } from './public/js/modules/components/systemManagement.js';
import SystemsList from './public/js/modules/components/systemsList.js';
import { ChartsComponent } from './public/js/modules/components/charts.js';
import { ChartModalComponent } from './public/js/modules/components/chartModal.js';
import { FormValidationComponent } from './public/js/modules/components/formValidation.js';
import { ModalManagerComponent } from './public/js/modules/components/modalManager.js';
import { DataEntryComponent } from './public/js/modules/components/dataEntry.js';
import { DashboardManagerComponent } from './public/js/modules/components/dashboardManager.js';
import { DashboardUIComponent } from './public/js/modules/components/dashboardUI.js';

// Import API Modules
import * as CropKnowledgeAPI from './public/js/modules/api/cropKnowledgeAPI.js';
import * as ConfigAPI from './public/js/modules/api/configAPI.js';
import { apiClient, BaseApiClient } from './public/js/modules/api/baseApiClient.js';

// Import Services
import { AppCoreService } from './public/js/modules/services/appCore.js';
import SystemManager from './public/js/modules/services/systemManager.js';
import DataProcessor from './public/js/modules/services/dataProcessor.js';

// Import Utilities
import { domUtils } from './public/js/modules/utils/domReady.js';
import { WaterQualityComponent } from './public/js/modules/components/waterQuality.js';
import { PlantManagementComponent } from './public/js/modules/components/plantManagement.js';
import { FishManagementComponent } from './public/js/modules/components/fishManagement.js';
import { FormsComponent } from './public/js/modules/components/forms.js';
import { FormValidatorComponent } from './public/js/modules/components/formValidator.js';
import { FarmLayoutRendererComponent } from './public/js/modules/components/farmLayoutRenderer.js';
import { CustomCropManagerComponent } from './public/js/modules/components/customCropManager.js';
import { TankMonitoringFormComponent } from './public/js/modules/components/tankMonitoringForm.js';
import { SprayApplicationManagerComponent } from './public/js/modules/components/sprayApplicationManager.js';
import { FishTankRendererComponent } from './public/js/modules/components/fishTankRenderer.js';
import { FormGeneratorComponent } from './public/js/modules/components/formGenerator.js';
import { UtilitiesComponent } from './public/js/modules/components/utilities.js';
import { NotificationManagerComponent } from './public/js/modules/components/notificationManager.js';
import { AuthenticationManagerComponent } from './public/js/modules/components/authenticationManager.js';
import { SystemStateManagerComponent } from './public/js/modules/components/systemStateManager.js';
import { PlantBatchManagerComponent } from './public/js/modules/components/plantBatchManager.js';
import { FishTankManagerComponent } from './public/js/modules/components/fishTankManager.js';
import { NavigationManagerComponent } from './public/js/modules/components/navigationManager.js';
import { WaterQualitySensorManagerComponent } from './public/js/modules/components/waterQualitySensorManager.js';
import { SystemConfigManagerComponent } from './public/js/modules/components/systemConfigManager.js';
import { CropAllocationManagerComponent } from './public/js/modules/components/cropAllocationManager.js';

// Make components available globally for AppCore dynamic initialization
window.SystemManagementComponent = SystemManagementComponent;
window.SystemsListComponent = SystemsList;
window.ChartsComponent = ChartsComponent;
window.ChartModalComponent = ChartModalComponent;
window.FormValidationComponent = FormValidationComponent;
window.ModalManagerComponent = ModalManagerComponent;
window.DataEntryComponent = DataEntryComponent;
window.DashboardManagerComponent = DashboardManagerComponent;
window.DashboardUIComponent = DashboardUIComponent;
window.WaterQualityComponent = WaterQualityComponent;
window.PlantManagementComponent = PlantManagementComponent;
window.FishManagementComponent = FishManagementComponent;
window.FormsComponent = FormsComponent;
window.FormValidatorComponent = FormValidatorComponent;
window.FarmLayoutRendererComponent = FarmLayoutRendererComponent;
window.CustomCropManagerComponent = CustomCropManagerComponent;
window.TankMonitoringFormComponent = TankMonitoringFormComponent;
window.SprayApplicationManagerComponent = SprayApplicationManagerComponent;
window.FishTankRendererComponent = FishTankRendererComponent;
window.FormGeneratorComponent = FormGeneratorComponent;
window.UtilitiesComponent = UtilitiesComponent;
window.NotificationManagerComponent = NotificationManagerComponent;
window.AuthenticationManagerComponent = AuthenticationManagerComponent;
window.SystemStateManagerComponent = SystemStateManagerComponent;
window.PlantBatchManagerComponent = PlantBatchManagerComponent;
window.FishTankManagerComponent = FishTankManagerComponent;
window.NavigationManagerComponent = NavigationManagerComponent;
window.WaterQualitySensorManagerComponent = WaterQualitySensorManagerComponent;
window.SystemConfigManagerComponent = SystemConfigManagerComponent;
window.CropAllocationManagerComponent = CropAllocationManagerComponent;

// Make utilities available globally
window.domUtils = domUtils;

/**
 * Central Error Deduplication Manager
 * Prevents console spam from repeated warnings
 */
class ErrorManager {
    constructor() {
        this.warningCache = new Map();
        this.errorCache = new Map();
        this.throttleTime = 5000; // 5 seconds
    }

    /**
     * Deduplicated warning (following nutrient warning pattern)
     */
    warnOnce(key, message, context = '') {
        const now = Date.now();
        const cacheKey = `${key}:${context}`;
        
        if (!this.warningCache.has(cacheKey) || 
            (now - this.warningCache.get(cacheKey)) > this.throttleTime) {
            console.warn(message);
            this.warningCache.set(cacheKey, now);
            return true;
        }
        return false;
    }

    /**
     * Deduplicated error logging
     */
    errorOnce(key, message, error = null) {
        const now = Date.now();
        
        if (!this.errorCache.has(key) || 
            (now - this.errorCache.get(key)) > this.throttleTime) {
            console.error(message, error);
            this.errorCache.set(key, now);
            return true;
        }
        return false;
    }

    /**
     * Clear old cache entries (prevent memory leaks)
     */
    clearOldEntries() {
        const now = Date.now();
        const maxAge = this.throttleTime * 10; // 50 seconds
        
        for (const [key, timestamp] of this.warningCache.entries()) {
            if (now - timestamp > maxAge) {
                this.warningCache.delete(key);
            }
        }
        
        for (const [key, timestamp] of this.errorCache.entries()) {
            if (now - timestamp > maxAge) {
                this.errorCache.delete(key);
            }
        }
    }
}

// Global error manager instance
window.errorManager = new ErrorManager();

// Clear old entries every minute
setInterval(() => {
    window.errorManager.clearOldEntries();
}, 60000);

class AquaponicsApp {
    constructor() {
        console.log('üèóÔ∏è AquaponicsApp constructor starting...');
        // Initialize core application configuration using AppCore service
        this.appCore = new AppCoreService(this);
        
        // Set API client after AppCore initialization
        this.apiClient = apiClient; // Default instance available for use
        
        // Initialize SystemManager service
        this.systemManager = new SystemManagementComponent(this);
        console.log('‚úÖ SystemManager initialized:', {
            hasUpdateSystemSelector: typeof this.systemManager.updateSystemSelector === 'function',
            availableMethods: Object.getOwnPropertyNames(Object.getPrototypeOf(this.systemManager))
        });
        
        // Initialize DataProcessor service
        this.dataProcessor = new DataProcessor(this);
        
        // Initialize chart storage
        this.chartInstances = {};
        
        // Initialize Charts Component
        console.log('üîß About to initialize ChartsComponent...');
        try {
            this.charts = new ChartsComponent(this);
            console.log('‚úÖ ChartsComponent initialized successfully:', !!this.charts);
            
            // Immediately test chart initialization
            setTimeout(() => {
                console.log('üîß Testing chart initialization after DOM ready...');
                if (this.charts && typeof this.charts.initializeCharts === 'function') {
                    this.charts.initializeCharts().then(() => {
                        console.log('‚úÖ Charts initialized successfully!');
                    }).catch(error => {
                        console.error('‚ùå Chart initialization failed:', error);
                    });
                } else {
                    console.error('‚ùå Charts component or initializeCharts method not available');
                }
            }, 3000);
        } catch (error) {
            console.error('‚ùå Failed to initialize ChartsComponent:', error);
            this.charts = null;
        }
        
        // Initialize UI Components through AppCore service
        this.appCore.initializeUIComponents();
        
        this.init();
    }

    // Authentication Methods
    async makeApiCall(endpoint, options = {}) {
        // Prevent duplicate login API calls
        if (endpoint === '/auth/login' && this.loginInProgress) {
            throw new Error('Login already in progress');
        }
        
        if (endpoint === '/auth/login') {
            this.loginInProgress = true;
        }
        
        const url = `${this.API_BASE}${endpoint}`;
        const config = {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        // Get token from localStorage
        const token = localStorage.getItem('auth_token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }

        try {
            const response = await fetch(url, config);
            
            if (!response.ok) {
                const errorText = await response.text();
                let errorData;
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    errorData = { error: errorText };
                }
                
                // Create enhanced error object that preserves response data
                const error = new Error(errorData.error || `HTTP error! status: ${response.status}`);
                error.response = errorData;
                error.status = response.status;
                throw error;
            }

            const data = await response.json();
            return data;
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce(`api_call_failed_${endpoint}`, `API call failed: ${endpoint}`, this.activeSystemId);
            } else {
                console.error('‚ùå API call failed:', error);
            }
            throw error;
        } finally {
            if (endpoint === '/auth/login') {
                this.loginInProgress = false;
            }
        }
    }

    async checkAuthStatus() {
        const token = localStorage.getItem('auth_token');
        if (!token) {
            this.showAuthUI();
            return false;
        }

        try {
            const response = await this.makeApiCall('/auth/verify');
            this.user = response.user;
            this.showAppUI();
            await this.loadUserData();
            return true;
        } catch (error) {
            console.error('Auth verification failed:', error);
            await this.logout();
            return false;
        }
    }

    showAuthUI() {
        const authControls = document.getElementById('auth-controls');
        const userControls = document.getElementById('user-controls');
        const systemSelector = document.getElementById('system-selector');
        
        if (authControls) authControls.style.display = 'flex';
        if (userControls) userControls.style.display = 'none';
        if (systemSelector) systemSelector.style.display = 'none';
        
        // Clear any existing notifications when showing landing page
        this.clearAllNotifications();
        
        // Show landing page and hide main content until authenticated
        const landingPage = document.getElementById('landing-page');
        const mobileContent = document.querySelector('.mobile-content');
        
        if (landingPage) landingPage.style.display = 'block';
        if (mobileContent) mobileContent.style.display = 'none';
        if (document.querySelector('.bottom-nav')) {
            document.querySelector('.bottom-nav').style.display = 'none';
        }
        
        // Setup landing page button event listeners
        this.setupLandingPageButtons();
    }

    showAppUI() {
        console.log('üéØ showAppUI() called - making system dropdown visible');
        
        const authControls = document.getElementById('auth-controls');
        const userControls = document.getElementById('user-controls');
        const systemSelector = document.getElementById('system-selector');
        const usernameDisplay = document.getElementById('username-display');
        
        if (authControls) authControls.style.display = 'none';
        if (userControls) userControls.style.display = 'flex';
        if (systemSelector) {
            systemSelector.style.display = 'flex';
            systemSelector.style.visibility = 'visible';
            systemSelector.style.cssText = 'display: flex !important; visibility: visible !important;';
            console.log('üîç System selector should now be visible:', systemSelector.style.display);
            
            // Also ensure the select element inside is visible
            const selectElement = systemSelector.querySelector('select#active-system');
            if (selectElement) {
                selectElement.style.display = 'block';
                selectElement.style.visibility = 'visible';
                selectElement.style.cssText = 'display: block !important; visibility: visible !important;';
                console.log('üîç Select dropdown forced visible:', selectElement.style.display);
            } else {
                console.error('‚ùå Select element not found inside system selector');
            }
        }
        if (usernameDisplay && this.user) usernameDisplay.textContent = this.user.username;
        
        // Ensure system name is displayed (selector will be updated after systems load)
        this.updateCurrentSystemDisplay();
        
        console.log('üîÑ Updated system displays after showing app UI');
        
        // Debug: Check if system selector is now visible
        if (systemSelector) {
            console.log('üîç System selector display style:', systemSelector.style.display);
            console.log('üîç System selector computed style:', window.getComputedStyle(systemSelector).display);
        }
        
        // Show admin settings tab for admin users
        console.log('üîç Checking admin status for user:', {
            user: this.user,
            user_role: this.user?.user_role,
            userRole: this.user?.userRole,
            allUserProperties: this.user ? Object.keys(this.user) : 'no user'
        });
        
        // Show admin settings tab to all users (no longer restricted)
        console.log('üîì Making admin settings accessible to all users');
        
        // Add admin-user class to body element for all users
        document.body.classList.add('admin-user');
        console.log('‚úÖ Added admin-user class to body element');
        
        // Force admin settings content to be visible for all users
        const adminSettingsContent = document.getElementById('admin-settings-content');
        if (adminSettingsContent) {
            adminSettingsContent.classList.add('active');
            adminSettingsContent.style.display = 'block';
            adminSettingsContent.style.cssText = 'display: block !important;';
            console.log('üîß Forced admin settings content to be active and visible for all users');
        }
        
        const adminSettingsTab = document.getElementById('admin-settings-tab');
        if (adminSettingsTab) {
            adminSettingsTab.style.display = 'flex';
            adminSettingsTab.style.visibility = 'visible';
            adminSettingsTab.style.cssText = 'display: flex !important; visibility: visible !important;';
            console.log('üîç Admin settings tab should now be visible to all users');
            
            // Initialize admin data automatically when admin tab is made visible
            setTimeout(async () => {
                console.log('üöÄ Auto-initializing admin data...');
                try {
                    await this.loadAdminUsers();
                    await this.loadAdminStats();
                    await this.loadAdminCrops();
                    await this.loadSmtpConfig();
                    await this.loadDataEditInterface();
                    await this.loadAllDeficiencyImages();
                    
                    // Initialize nutrient ratio management if available
                    if (this.nutrientRatioManager) {
                        console.log('üöÄ Auto-initializing nutrient ratio management...');
                        this.nutrientRatioManager.loadRatioManagement();
                    }
                } catch (error) {
                    console.error('‚ùå Error auto-initializing admin data:', error);
                }
            }, 1000);
        } else {
            console.error('‚ùå Admin settings tab element not found in DOM');
        }
        
        // Hide landing page and show main content
        const landingPage = document.getElementById('landing-page');
        const mobileContent = document.querySelector('.mobile-content');
        const bottomNav = document.querySelector('.bottom-nav');
        
        if (landingPage) landingPage.style.display = 'none';
        if (mobileContent) mobileContent.style.display = 'block';
        if (bottomNav) bottomNav.style.display = 'flex';
        
        // Ensure charts are initialized and dashboard is updated when app UI is shown
        setTimeout(async () => {
            try {
                // Initialize charts first
                await this.initializeCharts();
                // Then update dashboard data
                await this.updateDashboardFromData();
                
                // Force chart visibility check after everything loads
                setTimeout(() => {
                    if (this.charts && this.charts.forceChartVisibilityCheck) {
                        console.log('üîß Final chart visibility check after app initialization...');
                        this.charts.forceChartVisibilityCheck();
                    }
                }, 1000);
            } catch (error) {
                console.error('Error during app UI initialization:', error);
            }
        }, 100);
    }

    async login(username, password) {
        // Rate limiting - prevent multiple login attempts within 3 seconds
        const now = Date.now();
        if (this.lastLoginAttempt && (now - this.lastLoginAttempt) < 3000) {

            return { success: false, error: 'Please wait before trying again' };
        }
        this.lastLoginAttempt = now;

        try {
            const response = await this.makeApiCall('/auth/login', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            });

            this.token = response.token;
            this.user = response.user;
            localStorage.setItem('auth_token', this.token);
            
            this.showAppUI();
            await this.loadUserData('login');
            if (this.modalManager) {
                this.modalManager.closeAuthModal();
            }

            return { success: true };
        } catch (error) {
            console.error('Login failed:', error.message);
            
            // Check if it's an email verification error
            if (error.message.includes('Email not verified') || error.response?.needsVerification) {
                const email = error.response?.email || username || '';
                console.log('Email verification needed. Error response:', error.response);
                console.log('Email from response:', error.response?.email);
                console.log('Username from input:', username);
                console.log('Final email to use:', email);
                if (email) {
                    this.showEmailVerificationMessage(email);
                } else {
                    // Fallback notification if email is not available
                    this.showNotification('Please check your email for verification link', 'warning', 5000);
                }
                return { success: false, error: 'Please verify your email before logging in.', needsVerification: true };
            }
            
            return { success: false, error: error.message };
        }
    }

    async register(username, email, password, firstName, lastName) {
        try {
            const response = await this.makeApiCall('/auth/register', {
                method: 'POST',
                body: JSON.stringify({ username, email, password, firstName, lastName })
            });

            if (response.needsVerification) {
                // Return success with verification flag, but don't show verification message
                // The handleRegister method will show an inline success message instead
                return { success: true, needsVerification: true };
            } else {
                // Legacy flow (in case email verification is disabled)
                this.token = response.token;
                this.user = response.user;
                if (this.token) {
                    localStorage.setItem('auth_token', this.token);
                    this.showAppUI();
                    await this.loadUserData('login');
                    if (this.modalManager) {
                        this.modalManager.closeAuthModal();
                    }
                }
            }
            
            return { success: true };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }


    async logout() {

        this.token = null;
        this.user = null;
        this.systems = {};
        this.activeSystemId = null;
        this.dataRecords = { waterQuality: [], fishInventory: { tanks: [] }, fishEvents: [], plantGrowth: [], operations: [] };
        
        // Hide admin button and SMTP section
        const adminBtn = document.getElementById('admin-btn');
        if (adminBtn) {
            adminBtn.style.display = 'none';
        }
        const smtpSection = document.getElementById('smtp-section');
        if (smtpSection) {
            smtpSection.style.display = 'none';
        }
        
        localStorage.removeItem('auth_token');
        localStorage.removeItem('activeSystemId');
        this.showAuthUI();
        await this.updateDashboardFromData();
        
        // Show notification that logout was successful
        this.showNotification('Successfully logged out', 'success');

    }

    // Notification System
    createNotificationContainer() {
        let container = document.getElementById('notification-container');
        if (container) {

            // Force reapply styles to existing container
            container.style.position = 'fixed';
            container.style.top = '70px';
            container.style.right = '20px';
            container.style.zIndex = '99999';
            container.style.maxWidth = '400px';
            container.style.width = 'auto';
            container.style.pointerEvents = 'none';
            container.style.display = 'block';
            container.style.visibility = 'visible';
            return;
        }
        
        container = document.createElement('div');
        container.id = 'notification-container';
        container.className = 'notification-container';
        
        // Force positioning with inline styles to override any CSS conflicts
        container.style.position = 'fixed';
        container.style.top = '70px';
        container.style.right = '20px';
        container.style.zIndex = '99999';
        container.style.maxWidth = '400px';
        container.style.width = 'auto';
        container.style.pointerEvents = 'none';
        container.style.display = 'block';
        container.style.visibility = 'visible';
        
        document.body.appendChild(container);

        // Double-check styles after DOM insertion
        setTimeout(() => {
            const computedStyles = window.getComputedStyle(container);

            // Force styles again if they're not applied
            if (computedStyles.position !== 'fixed') {
                if (window.errorManager) {
                    window.errorManager.warnOnce('notification_position_fix', 'Position not fixed! Forcing styles again', 'notification');
                } else {
                    console.warn('Position not fixed! Forcing styles again...');
                }
                container.style.cssText = 'position: fixed !important; top: 70px !important; right: 20px !important; z-index: 99999 !important; max-width: 400px; width: auto; pointer-events: none; display: block !important; visibility: visible !important;';
            }
        }, 100);
    }

    showNotification(message, type = 'info', duration = 4000) {
        return this.notificationManager.showNotification(message, type, duration);
    }

    _originalShowNotification(message, type = 'info', duration = 4000) {
        // Suppress notifications during loading unless it's the success message after loading completes
        if (this.isLoading && !message.includes('Afraponix Go loaded successfully')) {
            return;
        }

        // Suppress notifications when landing page is visible (unauthenticated state)
        // BUT allow authentication-related notifications (login/registration errors)
        const landingPage = document.getElementById('landing-page');
        if (landingPage && landingPage.style.display === 'block') {
            // Allow authentication-related notifications
            const authMessages = [
                'invalid credentials',
                'email already exists',
                'username already exists',
                'password',
                'verification',
                'login',
                'register',
                'email not verified',
                'all fields are required',
                'failed to create user',
                'failed to authenticate'
            ];
            
            const isAuthNotification = authMessages.some(authMsg => 
                message.toLowerCase().includes(authMsg.toLowerCase())
            );
            
            if (!isAuthNotification) {
                return; // Suppress non-auth notifications
            }
        }

        // Ensure notification container exists
        if (!document.getElementById('notification-container')) {

            this.createNotificationContainer();
        }
        
        // Try to show inline notification first
        // Temporarily disabled to debug toast notifications
        // if (this.showInlineNotification(message, type, duration)) {
        // //     return;
        // }

        // Fallback to toast notification
        const container = document.getElementById('notification-container');

        if (!container) {
            if (window.errorManager) {
                window.errorManager.warnOnce('notification_container_missing', 'Notification container not found, falling back to alert', 'ui');
            } else {
                console.warn('Notification container not found, falling back to alert');
            }
            alert(message);
            return;
        }
        const containerStyles = window.getComputedStyle(container);

        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        
        // Force notification visibility with inline styles
        notification.style.pointerEvents = 'auto';
        notification.style.opacity = '1';
        notification.style.display = 'flex';
        notification.style.marginBottom = '12px';
        
        const icon = this.getNotificationIcon(type);
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon">${icon}</span>
                <span class="notification-message">${message}</span>
            </div>
            <button class="notification-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        container.appendChild(notification);

        // Force container visibility again right before adding notification
        container.style.position = 'fixed';
        container.style.top = '70px';
        container.style.right = '20px';
        container.style.zIndex = '99999';
        container.style.display = 'block';
        container.style.visibility = 'visible';
        const notificationStyles = window.getComputedStyle(notification);

        // Try to force visibility of the notification element itself
        notification.style.position = 'relative';
        notification.style.display = 'flex';
        notification.style.opacity = '1';
        notification.style.visibility = 'visible';
        notification.style.width = 'auto';
        notification.style.minHeight = '50px';
        notification.style.backgroundColor = type === 'success' ? '#f0f9ff' : '#ffffff';
        notification.style.border = '1px solid #e0e0e0';
        
        // Log final positions after all manipulations
        setTimeout(() => {
            const finalContainerStyles = window.getComputedStyle(container);
            const finalNotificationStyles = window.getComputedStyle(notification);

        }, 50);

        // Auto-remove after duration
        setTimeout(() => {
            if (notification.parentElement) {
                notification.classList.add('notification-fade-out');
                setTimeout(() => notification.remove(), 300);
            }
        }, duration);

        // Remove on click
        notification.addEventListener('click', () => {
            notification.classList.add('notification-fade-out');
            setTimeout(() => notification.remove(), 300);
        });
    }

    clearAllNotifications() {
        const container = document.getElementById('notification-container');
        if (container) {
            // Remove all notification elements
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }
    }

    // showCustomConfirm function moved to ModalManagerComponent

    hideAllAuthForms() {
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const forgotPasswordForm = document.getElementById('forgot-password-form-element');
        
        if (loginForm) loginForm.style.display = 'none';
        if (registerForm) registerForm.style.display = 'none';
        if (forgotPasswordForm) forgotPasswordForm.style.display = 'none';
    }

    showLoginForm() {
        this.hideAllAuthForms();
        const loginForm = document.getElementById('login-form');
        if (loginForm) {
            loginForm.style.display = 'block';
        }
    }

    async handleEmailVerificationUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');
        const requestVerification = urlParams.get('request-verification');
        
        // Handle verification request from expired links
        if (requestVerification === 'true') {
            // Clear the URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);
            
            // Show login panel with a message about requesting new verification
            setTimeout(() => {
                this.modalManager.showLoginSlideout();
                this.showNotification('‚è∞ Your verification link has expired. Please log in to request a new verification email.', 'info', 8000);
            }, 100);
            return;
        }
        
        if (!token) return;
        
        // Show modal and verification processing message
        const modal = document.getElementById('auth-modal');
        if (!modal) {
            if (window.errorManager) {
                window.errorManager.warnOnce('auth_modal_missing', 'Auth modal not found', 'auth');
            } else {
                console.warn('Auth modal not found');
            }
            return;
        }
        modal.classList.add('show');
        
        const modalContent = document.querySelector('#auth-modal .modal-content');
        if (!modalContent) {
            if (window.errorManager) {
                window.errorManager.warnOnce('auth_modal_content_missing', 'Auth modal content not found', 'auth');
            } else {
                console.warn('Auth modal content not found');
            }
            return;
        }
        modalContent.innerHTML = `
            <span class="close" id="close-modal">&times;</span>
            <div class="verification-processing">
                <div class="verification-icon">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="#007bff" stroke-width="2"/>
                        <path d="m9 12 2 2 4-4" stroke="#007bff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <h3>Verifying Your Email...</h3>
                <p>Please wait while we verify your email address.</p>
            </div>
        `;
        
        try {
            const response = await this.makeApiCall('/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({ token })
            });
            
            if (response.verified) {
                // Auto-login after successful verification
                this.token = response.token;
                this.user = response.user;
                localStorage.setItem('auth_token', this.token);
                
                // Clear URL parameters
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Show success and close modal
                modalContent.innerHTML = `
                    <span class="close" id="close-modal">&times;</span>
                    <div class="verification-success">
                        <div class="verification-icon">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="#28a745" stroke-width="2"/>
                                <path d="m9 12 2 2 4-4" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                        <h3>Email Verified Successfully!</h3>
                        <p>Welcome to Afraponix Go! You have been automatically logged in.</p>
                        <button id="continue-to-dashboard-btn" class="btn-primary">
                            Continue to Dashboard
                        </button>
                    </div>
                `;
                
                // Re-attach modal close handler  
                const closeModal = document.getElementById('close-modal');
                if (closeModal) {
                    closeModal.addEventListener('click', async () => {
                        if (this.modalManager) {
                            this.modalManager.closeAuthModal();
                        }
                        this.showAppUI();
                        
                        // Load user data and show system creation modal for new users
                        await this.loadUserData('login');
                    });
                }
                
                // Add continue to dashboard button handler
                const continueBtn = document.getElementById('continue-to-dashboard-btn');
                if (continueBtn) {
                    continueBtn.addEventListener('click', async () => {
                        if (this.modalManager) {
                            this.modalManager.closeAuthModal();
                        }
                        this.showAppUI();
                        
                        // Load user data and show system creation modal for new users
                        await this.loadUserData('login');
                    });
                }
                
            } else {
                throw new Error('Email verification failed');
            }
            
        } catch (error) {
            console.error('Email verification error:', error);
            
            // Show error message
            modalContent.innerHTML = `
                <span class="close" id="close-modal">&times;</span>
                <div class="verification-error">
                    <div class="verification-icon">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="10" stroke="#dc3545" stroke-width="2"/>
                            <path d="m15 9-6 6" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="m9 9 6 6" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <h3>Verification Failed</h3>
                    <p>This verification link is invalid or has expired. Please request a new verification email.</p>
                    <button id="back-to-login-btn" class="btn-primary">
                        Back to Login
                    </button>
                </div>
            `;
            
            // Re-attach modal close handler
            const closeModalBtn = document.getElementById('close-modal');
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', () => {
                    if (this.modalManager) {
                        this.modalManager.closeAuthModal();
                    }
                });
            }
            
            // Add back to login button handler
            const backToLoginBtn = document.getElementById('back-to-login-btn');
            if (backToLoginBtn) {
                backToLoginBtn.addEventListener('click', () => {
                    this.showLoginForm();
                });
            }
            
            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }
    }

    showEmailVerificationMessage(email) {
        // Show the login slideout and replace its content with verification message
        this.modalManager.showLoginSlideout();
        
        // Get the login slideout content area
        const loginPanel = document.getElementById('login-slideout-panel');
        
        // Add null check for safety
        if (!loginPanel) {
            if (window.errorManager) {
                window.errorManager.warnOnce('login_panel_missing', 'Login slideout panel not found', 'auth');
            } else {
                console.error('Login slideout panel not found');
            }
            // Fallback to showing a regular notification
            this.showNotification(`Please check your email (${email}) for verification link`, 'info', 8000);
            return;
        }
        const verificationHtml = `
            <div class="slideout-header">
                <h2>Email Verification Required</h2>
                <button class="close-slideout" onclick="app.modalManager.closeAllSlideoutPanels()">&times;</button>
            </div>
            <div class="slideout-content">
                <div class="verification-message">
                    <div class="verification-icon">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3 8L10.89 13.26C11.2187 13.4793 11.6049 13.5963 12 13.5963C12.3951 13.5963 12.7813 13.4793 13.11 13.26L21 8M5 19H19C19.5304 19 20.0391 18.7893 20.4142 18.4142C20.7893 18.0391 21 17.5304 21 17V7C21 6.46957 20.7893 5.96086 20.4142 5.58579C20.0391 5.21071 19.5304 5 19 5H5C4.46957 5 3.96086 5.21071 3.58579 5.58579C3.21071 5.96086 3 6.46957 3 7V17C3 17.5304 3.21071 18.0391 3.58579 18.4142C3.96086 18.7893 4.46957 19 5 19Z" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <h3>Check Your Email!</h3>
                    <p>We've sent a verification link to:</p>
                    <p class="email-address">${email}</p>
                    <p class="verification-info">Click the link in the email to verify your account and start using Afraponix Go.</p>
                    <div class="verification-actions">
                        <button onclick="app.showResendVerification('${email}')" class="btn-success">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: text-bottom;"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
                            Resend Verification Email
                        </button>
                        <button onclick="app.showLoginForm()" class="btn-secondary">
                            Back to Login
                        </button>
                    </div>
                    <div class="verification-tips">
                        <p><strong>Tips:</strong></p>
                        <ul>
                            <li>Check your spam/junk folder</li>
                            <li>Verification link expires in 24 hours</li>
                            <li>Make sure to check the email address is correct</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        
        loginPanel.innerHTML = verificationHtml;
        
        console.log('Email verification message displayed for:', email);
    }

    async showResendVerification(email) {
        try {
            // Show loading notification
            this.showNotification('Sending verification email...', 'info', 2000);

            const response = await this.makeApiCall('/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({ email })
            });

            // Show success notification with enhanced messaging
            this.showNotification(`Verification email sent to ${email}! Please check your inbox and spam folder.`, 'success', 6000);
            
            // Show verification code input form
            this.showVerificationCodeForm(email);
            
        } catch (error) {
            console.error('‚ùå Resend error:', error);
            
            // Enhanced error messaging based on the error type
            let errorMessage = 'Failed to resend verification email. Please try again.';
            
            if (error.message.includes('already verified')) {
                errorMessage = 'Your email is already verified! You can now log in to your account.';
            } else if (error.message.includes('not found')) {
                errorMessage = 'Email address not found. Please check your email or register a new account.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Please wait a few minutes before requesting another verification email.';
            }
            
            this.showNotification(errorMessage, 'error', 8000);
        }
    }

    showVerificationCodeForm(email) {
        const loginPanel = document.getElementById('login-slideout-panel');
        
        if (!loginPanel) {
            if (window.errorManager) {
                window.errorManager.warnOnce('login_panel_missing_verification', 'Login slideout panel not found in verification', 'auth');
            } else {
                console.error('Login slideout panel not found');
            }
            return;
        }

        const verificationCodeHtml = `
            <div class="slideout-header">
                <h2>Enter Verification Code</h2>
                <button class="close-slideout" onclick="app.modalManager.closeAllSlideoutPanels()">&times;</button>
            </div>
            <div class="slideout-content">
                <div class="verification-code-form">
                    <div class="verification-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" fill="#28a745"/>
                        </svg>
                    </div>
                    <p>We've sent a 6-digit verification code to:</p>
                    <p class="email-address"><strong>${email}</strong></p>
                    <p>Enter the code below to verify your account:</p>
                    
                    <form id="verification-code-form" onsubmit="app.handleVerificationCode(event, '${email}')">
                        <div class="code-input-container">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                            <input type="text" class="code-digit form-input" maxlength="1" pattern="[0-9]" autocomplete="off">
                        </div>
                        
                        <div class="verification-actions">
                            <button type="submit" class="btn-success">
                                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: text-bottom;"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/></svg>
                                Verify Account
                            </button>
                            <button type="button" onclick="app.showResendVerification('${email}')" class="btn-secondary">
                                Resend Code
                            </button>
                        </div>
                        
                        <div class="verification-help">
                            <p><strong>Having trouble?</strong></p>
                            <ul>
                                <li>Check your spam/junk folder</li>
                                <li>Make sure to enter all 6 digits</li>
                                <li>Code expires in 24 hours</li>
                                <li>Click "Resend Code" if you didn't receive it</li>
                            </ul>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        loginPanel.innerHTML = verificationCodeHtml;
        
        // Setup verification code input handling
        this.setupVerificationCode();
        
        console.log('Verification code form displayed for:', email);
    }

    async handleVerificationCode(event, email) {
        event.preventDefault();
        
        // Get all code digit inputs
        const codeInputs = document.querySelectorAll('.code-digit');
        let verificationCode = '';
        
        // Combine all digits into verification code
        codeInputs.forEach(input => {
            verificationCode += input.value;
        });
        
        // Validate code length
        if (verificationCode.length !== 6) {
            this.showNotification('Please enter all 6 digits of the verification code', 'error');
            return;
        }
        
        // Validate code contains only numbers
        if (!/^\d{6}$/.test(verificationCode)) {
            this.showNotification('Verification code must contain only numbers', 'error');
            return;
        }
        
        try {
            // Show loading state
            const submitButton = event.target.querySelector('button[type="submit"]');
            const originalText = submitButton.textContent;
            submitButton.disabled = true;
            submitButton.textContent = 'Verifying...';
            
            this.showNotification('Verifying your code...', 'info', 2000);
            
            // Call verification API with the code
            console.log('üîç Attempting verification with:', { code: verificationCode, email: email });
            const response = await this.makeApiCall('/auth/verify-code', {
                method: 'POST',
                body: JSON.stringify({ 
                    code: verificationCode,
                    email: email 
                })
            });
            
            // Success - store auth token and redirect
            if (response.token) {
                localStorage.setItem('auth_token', response.token);
                localStorage.setItem('user', JSON.stringify(response.user));
            }
            
            this.showNotification('Email verified successfully! Welcome to Afraponix Go!', 'success', 5000);
            
            // Set a flag to show system modal after reload if no systems
            localStorage.setItem('justVerifiedEmail', 'true');
            
            // Close slideout and redirect to dashboard
            this.modalManager.closeAllSlideoutPanels();
            
            // Reload the page to update authentication state
            setTimeout(() => {
                window.location.reload();
            }, 1000);
            
        } catch (error) {
            console.error('‚ùå Verification error:', error);
            
            // Reset form state
            const submitButton = event.target.querySelector('button[type="submit"]');
            submitButton.disabled = false;
            submitButton.textContent = 'Verify Account';
            
            // Handle different error types
            let errorMessage = 'Invalid verification code. Please try again.';
            
            if (error.message.includes('expired')) {
                errorMessage = 'This verification code has expired. Please request a new one.';
            } else if (error.message.includes('invalid') || error.message.includes('Invalid')) {
                errorMessage = 'Invalid verification code. Please check and try again.';
            }
            
            this.showNotification(errorMessage, 'error', 8000);
            
            // Clear the form inputs for user to try again
            const codeInputs = document.querySelectorAll('.code-digit');
            codeInputs.forEach(input => {
                input.value = '';
            });
            
            // Focus on first input
            if (codeInputs.length > 0) {
                codeInputs[0].focus();
            }
        }
    }

    showInlineNotification(message, type = 'info', duration = 4000) {

        // Find the current active view or form context with defensive checks
        const activeView = document.querySelector('.view.active');
        const activeForm = document.querySelector('.data-form.active, .dosing-content.active, .calculator-content.active');
        
        // Log when no active context is found (for debugging)
        if (!activeView && !activeForm && window.errorManager) {
            window.errorManager.warnOnce('no_active_context', 'No active view or form context found', 'notification');
        }

        let targetContainer = null;
        
        // Determine where to show the inline notification
        if (activeForm) {
            // Show in active form context
            targetContainer = activeForm.querySelector('.form-section, .calculator-section, .data-entry-section');
        } else if (activeView) {
            // Show in active view
            targetContainer = activeView;
        }
        
        if (!targetContainer) return false;
        
        // Check if there's already an inline notification
        const existingNotification = targetContainer.querySelector('.inline-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // Create inline notification
        const inlineNotification = document.createElement('div');
        inlineNotification.className = `inline-notification inline-notification-${type}`;
        
        const icon = this.getNotificationIcon(type);
        inlineNotification.innerHTML = `
            <div class="inline-notification-content">
                <span class="inline-notification-icon">${icon}</span>
                <span class="inline-notification-message">${message}</span>
                <button class="inline-notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
            </div>
        `;
        
        // Insert at the top of the container
        targetContainer.insertBefore(inlineNotification, targetContainer.firstChild);
        
        // Auto-remove after duration
        setTimeout(() => {
            if (inlineNotification.parentElement) {
                inlineNotification.classList.add('inline-notification-fade-out');
                setTimeout(() => inlineNotification.remove(), 300);
            }
        }, duration);
        
        return true;
    }

    getNotificationIcon(type) {
        const icons = {
            success: '‚úÖ',
            warning: '‚ö†Ô∏è',
            error: '‚ùå',
            info: '‚ÑπÔ∏è'
        };
        return icons[type] || icons.info;
    }

    async loadUserData(context = 'default') {
        try {
            // Load systems
            const systems = await this.makeApiCall('/systems');
            this.systems = {};
            systems.forEach(system => {
                this.systems[system.id] = system;
            });
            
            // Also update SystemManager's systems
            if (this.systemManager) {
                this.systemManager.systems = { ...this.systems };
                console.log(`üîÑ Updated SystemManager with ${Object.keys(this.systems).length} systems`);
            }
            
            this.updateSystemSelector();
            
            // Check for stored system preference
            const storedSystemId = localStorage.getItem('activeSystemId');
            if (storedSystemId && this.systems[storedSystemId]) {
                // Use stored system if it exists
                await this.switchToSystem(storedSystemId);
            } else {
                // Clear invalid stored system ID
                if (storedSystemId) {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('invalid_system_id_cleared', `Clearing invalid stored system ID: ${storedSystemId}`, 'system_init');
                    } else {
                        console.warn(`üóëÔ∏è Clearing invalid stored system ID: ${storedSystemId}`);
                    }
                    localStorage.removeItem('activeSystemId');
                }
                
                if (systems.length > 0) {
                    // Otherwise default to the first system
                    await this.switchToSystem(systems[0].id);
                } else {
                    this.activeSystemId = null;
                    await this.loadDataRecords();
                    await this.updateDashboardFromData();
                    
                    // Check if we just verified email (after page reload)
                    const justVerified = localStorage.getItem('justVerifiedEmail');
                    if (justVerified === 'true') {
                        localStorage.removeItem('justVerifiedEmail');
                        context = 'login'; // Treat as login context
                    }
                    
                    // Check if this is a first-time user (no systems ever created)
                    const hasSeenSystemModal = localStorage.getItem('hasSeenSystemModal');
                    const isFirstTimeUser = systems.length === 0 && !hasSeenSystemModal;
                    
                    // Show system creation modal for new users after successful login or first-time users
                    if ((context === 'login' || isFirstTimeUser) && systems.length === 0) {
                        // Mark that we've shown the modal
                        localStorage.setItem('hasSeenSystemModal', 'true');
                        
                        // Show welcome notification first
                        this.showNotification('üéâ Welcome to Afraponix Go! Let\'s set up your first aquaponics system.', 'success', 4000);
                        
                        // Then show the system creation modal after a short delay
                        setTimeout(() => {
                            this.showAddSystemDialog();
                        }, 1500);
                    }
                }
            }
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('user_data_load_failed', 'Failed to load user data', 'init');
            } else {
                console.error('Failed to load user data:', error);
            }
        }
    }

    async init() {
        try {
            this.updateLoadingMessage('Setting up navigation...');
            if (this.navigationManager) {
                this.navigationManager.initializeNavigation();
            } else {
                if (window.errorManager) {
                    window.errorManager.warnOnce('navigation_fallback', 'NavigationManager not initialized, setting up basic navigation');
                } else {
                    console.warn('NavigationManager not initialized, setting up basic navigation');
                }
                this.setupBasicNavigation();
            }
            
            this.updateLoadingMessage('Configuring system components...');
            this.setupEventListeners();
            this.setupAuthModal();
            this.setupNewSystemModal();
            this.setupSystemSelector();
            this.setupDataEditTabs();
            
            // Initialize service handlers
            await this.initializeServiceHandlers();
            
            this.updateLoadingMessage('Setting up tab handlers...');
            await this.initializeAllTabHandlers();
            
            this.updateLoadingMessage('Initializing calculators...');
            this.initializeFishCalculator();
            this.initializeNutrientCalculator();
            this.initializeDataEntryForms();
            this.createNotificationContainer();
            
            this.updateLoadingMessage('Checking authentication...');
            
            // Check for email verification in URL parameters
            await this.handleEmailVerificationUrl();
            
            // Check authentication status - this will load user data and systems
            const isAuthenticated = await this.checkAuthStatus();
            
            if (isAuthenticated) {
                this.updateLoadingMessage('Loading system configuration...');
                // Wait for system management to load
                await this.loadSystemManagement();
                
                // Additional delay to ensure all data is rendered
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            // Hide loading screen after ALL initialization is complete
            this.hideLoadingScreen();
            
            // Show success notification after loading screen is hidden
            setTimeout(() => {
                if (this && this.showNotification) {
                    try {
                        this.showNotification('üöÄ Afraponix Go loaded successfully!', 'success', 3000);
                    } catch (error) {
                        if (window.errorManager) {
                            window.errorManager.warnOnce('show_notification_error', 'Error calling showNotification', 'init');
                        } else {
                            console.error('Error calling showNotification:', error);
                        }
                    }
                }
            }, 1000);
            
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('initialization_error', 'Initialization error', 'init');
            } else {
                console.error('Initialization error:', error);
            }
            this.updateLoadingMessage('Error loading application...');
            setTimeout(() => {
                this.hideLoadingScreen();
            }, 1000);
        }
    }
    
    updateLoadingMessage(message) {
        const loadingMessage = document.querySelector('.loading-message');
        if (loadingMessage) {
            loadingMessage.textContent = message;
        }
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            // Update message before hiding
            this.updateLoadingMessage('Ready!');
            
            // Mark loading as complete to allow notifications
            this.isLoading = false;
            
            // Add fade-out class for smooth transition
            setTimeout(() => {
                loadingScreen.classList.add('fade-out');
            }, 200);
            
            // Remove loading screen from DOM after transition completes
            setTimeout(() => {
                loadingScreen.remove();
            }, 700);
        }
    }

    // =====================================================
    // SERVICE HANDLERS INITIALIZATION
    // =====================================================
    
    async initializeServiceHandlers() {
        try {
            // Import and initialize CustomCropHandler
            const { default: CustomCropHandler } = await import('./public/js/modules/services/customCropHandler.js');
            this.customCropHandler = new CustomCropHandler(this);
            console.log('‚úÖ CustomCropHandler initialized');
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('custom_crop_handler_failed', '‚ö†Ô∏è Failed to initialize CustomCropHandler', error.message);
            } else {
                console.warn('‚ö†Ô∏è Failed to initialize CustomCropHandler:', error);
            }
            // Provide fallback for compatibility
            this.customCropHandler = {
                handleSimpleCropSave: () => {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('custom_crop_handler_unavailable', 'CustomCropHandler not available', 'component_init');
                    } else {
                        console.warn('CustomCropHandler not available');
                    }
                },
                handleAdvancedCropSave: () => {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('custom_crop_handler_unavailable', 'CustomCropHandler not available', 'component_init');
                    } else {
                        console.warn('CustomCropHandler not available');
                    }
                },
                attachSimpleCropListeners: () => {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('custom_crop_handler_unavailable', 'CustomCropHandler not available', 'component_init');
                    } else {
                        console.warn('CustomCropHandler not available');
                    }
                },
                attachAdvancedCropListeners: () => {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('custom_crop_handler_unavailable', 'CustomCropHandler not available', 'component_init');
                    } else {
                        console.warn('CustomCropHandler not available');
                    }
                }
            };
        }

        try {
            // Import and initialize GrowBedDataProcessor
            const { default: GrowBedDataProcessor } = await import('./public/js/modules/services/growBedDataProcessor.js');
            this.growBedDataProcessor = new GrowBedDataProcessor(this);
            console.log('‚úÖ GrowBedDataProcessor initialized');
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('grow_bed_processor_failed', '‚ö†Ô∏è Failed to initialize GrowBedDataProcessor', error.message);
            } else {
                console.warn('‚ö†Ô∏è Failed to initialize GrowBedDataProcessor:', error);
            }
            // Provide fallback for compatibility
            this.growBedDataProcessor = {
                transformGrowBedsForAPI: () => { 
                    if (window.errorManager) {
                        window.errorManager.warnOnce('grow_bed_processor_unavailable', 'GrowBedDataProcessor not available', 'component_init');
                    } else {
                        console.warn('GrowBedDataProcessor not available');
                    }
                    return []; 
                },
                saveGrowBedsData: () => { 
                    if (window.errorManager) {
                        window.errorManager.warnOnce('grow_bed_processor_unavailable', 'GrowBedDataProcessor not available', 'component_init');
                    } else {
                        console.warn('GrowBedDataProcessor not available');
                    }
                    return Promise.reject('Not available'); 
                },
                processCreatedBedIds: () => { 
                    if (window.errorManager) {
                        window.errorManager.warnOnce('grow_bed_processor_unavailable', 'GrowBedDataProcessor not available', 'component_init');
                    } else {
                        console.warn('GrowBedDataProcessor not available');
                    }
                    return Promise.resolve([]); 
                },
                validateGrowBedsData: () => { 
                    if (window.errorManager) {
                        window.errorManager.warnOnce('grow_bed_processor_unavailable', 'GrowBedDataProcessor not available', 'component_init');
                    } else {
                        console.warn('GrowBedDataProcessor not available');
                    }
                    return { valid: false, errors: ['Service not available'] }; 
                }
            };
        }
    }

    setupAuthModal() {
        // Prevent duplicate setup
        if (this.authModalSetup) {
            return;
        }
        this.authModalSetup = true;
        
        // Get main auth buttons with null checks
        const loginBtn = document.getElementById('login-btn');
        const registerBtn = document.getElementById('register-btn');
        const logoutBtn = document.getElementById('logout-btn');
        
        // Early return if essential elements are missing
        if (!loginBtn || !registerBtn) {
            if (window.errorManager) {
                window.errorManager.warnOnce('auth_setup_skipped', 'Auth modal setup skipped - login/register buttons not found');
            } else {
                console.warn('Auth modal setup skipped - login/register buttons not found');
            }
            return;
        }
        
        // Get slide-out panel elements
        const loginCloseBtn = document.getElementById('login-close-btn');
        const registerCloseBtn = document.getElementById('register-close-btn');
        const forgotPasswordCloseBtn = document.getElementById('forgot-password-close-btn');
        
        // Get form switching links
        const showRegisterLink = document.getElementById('show-register');
        const showLoginLink = document.getElementById('show-login');
        const showForgotPasswordLink = document.getElementById('show-forgot-password');
        const backToLoginLink = document.getElementById('back-to-login');
        
        // Get forms
        const loginForm = document.getElementById('login-form-element');
        const registerForm = document.getElementById('register-form-element');
        const forgotPasswordForm = document.getElementById('forgot-password-form-element');

        // Main auth button controls - call slideout functions directly
        if (loginBtn) {
            loginBtn.addEventListener('click', () => this.modalManager.showLoginSlideout());
        }
        if (registerBtn) {
            registerBtn.addEventListener('click', () => this.modalManager.showRegisterSlideout());
        }
        
        if (logoutBtn) {
            logoutBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.logout();
            });
        } else {
            if (window.errorManager) {
                window.errorManager.warnOnce('logout_button_missing', 'Logout button not found', 'auth');
            } else {
                console.error('Logout button not found');
            }
        }
        
        // Close button controls with null checks
        if (loginCloseBtn) {
            loginCloseBtn.addEventListener('click', () => this.closeLoginSlideout());
        }
        if (registerCloseBtn) {
            registerCloseBtn.addEventListener('click', () => this.closeRegisterSlideout());
        }
        if (forgotPasswordCloseBtn) {
            forgotPasswordCloseBtn.addEventListener('click', () => this.closeForgotPasswordSlideout());
        }
        
        // Backdrop click to close (only on backdrop, not panel)
        const loginBackdrop = document.getElementById('login-slideout-backdrop');
        const registerBackdrop = document.getElementById('register-slideout-backdrop');
        const forgotPasswordBackdrop = document.getElementById('forgot-password-slideout-backdrop');
        
        // No backdrop click to close for better UX (as requested)
        
        // Form switching - transition between panels with null checks
        if (showRegisterLink) {
            showRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.closeLoginSlideout();
                setTimeout(() => this.modalManager.showRegisterSlideout(), 300);
            });
        }
        if (showLoginLink) {
            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.closeRegisterSlideout();
                setTimeout(() => this.modalManager.showLoginSlideout(), 300);
            });
        }
        if (showForgotPasswordLink) {
            showForgotPasswordLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.closeLoginSlideout();
                setTimeout(() => this.modalManager.showForgotPasswordSlideout(), 300);
            });
        }
        if (backToLoginLink) {
            backToLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.closeForgotPasswordSlideout();
                setTimeout(() => this.modalManager.showLoginSlideout(), 300);
            });
        }

        // Form submissions with debounce protection
        let loginSubmitTimeout;
        let isLoginInProgress = false;
        
        if (loginForm) {
            loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Prevent submission if login is already in progress
            if (isLoginInProgress) {

                return;
            }
            
            // Clear any pending submission
            if (loginSubmitTimeout) {
                clearTimeout(loginSubmitTimeout);
            }
            
            // Capture form reference before timeout
            const formElement = e.target;
            
            // Debounce form submission
            loginSubmitTimeout = setTimeout(async () => {
                if (isLoginInProgress) {

                    return;
                }
                
                isLoginInProgress = true;
                
                try {
                    // Create a synthetic event with the form reference
                    const syntheticEvent = { target: formElement, preventDefault: () => {} };
                    await this.handleLogin(syntheticEvent);
                } finally {
                    isLoginInProgress = false;
                }
            }, 100);
            });
        }
        
        if (registerForm) {
            registerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.handleRegister(e);
            });
        }

        // Set up password validation and strength checking
        this.formValidation.setupPasswordValidation();

        if (forgotPasswordForm) {
            forgotPasswordForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.handleForgotPassword(e);
            });
        }

        // Setup verification code functionality
        this.setupVerificationCode();
    }

    // showModal function moved to ModalManagerComponent

    // New slide-out panel functions
    // showLoginSlideout function moved to ModalManagerComponent

    // showRegisterSlideout function moved to ModalManagerComponent

    // Fallback basic navigation setup
    setupBasicNavigation() {
        const navButtons = document.querySelectorAll('.nav-btn');
        const views = document.querySelectorAll('.view');

        navButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const targetView = btn.getAttribute('data-target') || btn.getAttribute('data-view');
                
                // Remove active class from all nav buttons and views
                navButtons.forEach(navBtn => navBtn.classList.remove('active'));
                views.forEach(view => view.classList.remove('active'));
                
                // Add active class to clicked nav button and target view
                btn.classList.add('active');
                const targetElement = document.getElementById(targetView);
                if (targetElement) {
                    targetElement.classList.add('active');
                    
                    // Handle fish tank view specifically
                    if (targetView === 'fish-tank') {
                        setTimeout(async () => {
                            // Use the main loadFishOverview implementation directly
                            await this.loadFishOverview();
                        }, 100);
                    }
                }
            });
        });
    }

    // showForgotPasswordSlideout function moved to ModalManagerComponent

    // closeLoginSlideout function moved to ModalManagerComponent

    // closeRegisterSlideout function moved to ModalManagerComponent

    // closeForgotPasswordSlideout function moved to ModalManagerComponent

    // closeAllSlideoutPanels function moved to ModalManagerComponent

    // closeAuthModal function moved to ModalManagerComponent

    openAuthModal() {
        // This method is deprecated - using slideout panels instead
        // Fallback to showing login slideout
        this.showLoginSlideout();
    }

    // Verification code functionality
    setupVerificationCode() {
        // Setup verification code input handling
        const codeInputs = document.querySelectorAll('.code-digit');
        
        codeInputs.forEach((input, index) => {
            input.addEventListener('input', (e) => {
                // Only allow digits
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                
                // Move to next input if digit entered
                if (e.target.value && index < codeInputs.length - 1) {
                    codeInputs[index + 1].focus();
                }
            });
            
            input.addEventListener('keydown', (e) => {
                // Move to previous input on backspace
                if (e.key === 'Backspace' && !e.target.value && index > 0) {
                    codeInputs[index - 1].focus();
                }
                
                // Submit on Enter if all fields filled
                if (e.key === 'Enter') {
                    const allFilled = Array.from(codeInputs).every(inp => inp.value);
                    if (allFilled) {
                        const form = document.getElementById('verification-code-form');
                        if (form) {
                            form.requestSubmit();
                        }
                    }
                }
            });
            
            input.addEventListener('paste', (e) => {
                e.preventDefault();
                const pastedData = e.clipboardData.getData('text');
                const digits = pastedData.replace(/[^0-9]/g, '').split('');
                
                // Clear all inputs first
                codeInputs.forEach(inp => inp.value = '');
                
                // Fill inputs with pasted digits starting from the first input
                digits.forEach((digit, i) => {
                    if (i < codeInputs.length) {
                        codeInputs[i].value = digit;
                    }
                });
                
                // Focus on the last filled input or the first empty one
                const lastFilledIndex = Math.min(digits.length - 1, codeInputs.length - 1);
                if (lastFilledIndex >= 0) {
                    codeInputs[lastFilledIndex].focus();
                }
                
                // If we have 6 digits, trigger form submission
                if (digits.length === 6) {
                    const form = document.getElementById('verification-code-form');
                    if (form) {
                        form.requestSubmit();
                    }
                }
            });
        });
        
        // Setup verification buttons
        const verifyBtn = document.getElementById('verify-code-btn');
        const resendBtn = document.getElementById('resend-code-btn');
        
        if (verifyBtn) {
            verifyBtn.addEventListener('click', () => this.verifyEmailCode());
        }
        
        if (resendBtn) {
            resendBtn.addEventListener('click', () => this.resendVerificationCode());
        }
    }

    showRegistrationStep2(email) {
        // Hide step 1, show step 2
        const step1 = document.getElementById('register-step-1');
        const step2 = document.getElementById('register-step-2');
        const emailDisplay = document.getElementById('verification-email-display');
        const code1Input = document.getElementById('code-1');
        
        if (step1) step1.style.display = 'none';
        if (step2) step2.style.display = 'block';
        
        // Display email in verification message
        if (emailDisplay) emailDisplay.textContent = email;
        
        // Focus first code input
        if (code1Input) code1Input.focus();
        
        // Generate and store verification code for testing (in production, this would be server-side)
        this.verificationCode = this.generateVerificationCode();
        this.verificationEmail = email;
        
    }

    generateVerificationCode() {
        return Math.floor(100000 + Math.random() * 900000).toString();
    }

    async verifyEmailCode() {
        const codeInputs = document.querySelectorAll('.code-digit');
        const enteredCode = Array.from(codeInputs).map(input => input.value).join('');
        
        if (enteredCode.length !== 6) {
            this.showNotification('‚ùå Please enter the complete 6-digit code', 'error');
            return;
        }
        
        const verifyBtn = document.getElementById('verify-code-btn');
        const originalText = verifyBtn.textContent;
        verifyBtn.textContent = 'Verifying...';
        verifyBtn.disabled = true;
        
        try {
            // TODO: Future backend integration - add 6-digit code endpoint
            // For now, using demo verification code system
            // Future implementation would call: /auth/verify-code with { code: enteredCode, email: this.pendingRegistration.email }
            
            if (enteredCode === this.verificationCode) {
                this.showNotification('‚úÖ Email verified successfully!', 'success');
                
                // Close registration panel and show login
                setTimeout(() => {
                    this.closeRegisterSlideout();
                    this.showNotification('üéâ Account created! Please log in with your credentials.', 'success');
                    this.modalManager.showLoginSlideout();
                }, 1500);
            } else {
                this.showNotification('‚ùå Invalid verification code. Please try again.', 'error');
                // Clear inputs
                codeInputs.forEach(input => input.value = '');
                codeInputs[0].focus();
            }
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('verification_error', 'Verification error', 'auth');
            } else {
                console.error('Verification error:', error);
            }
            this.showNotification('‚ùå Verification failed. Please try again.', 'error');
        } finally {
            verifyBtn.textContent = originalText;
            verifyBtn.disabled = false;
        }
    }

    async resendVerificationCode() {
        const resendBtn = document.getElementById('resend-code-btn');
        const originalText = resendBtn.textContent;
        
        resendBtn.textContent = 'Sending...';
        resendBtn.disabled = true;
        
        try {
            // Call backend to resend verification email
            if (this.pendingRegistration && this.pendingRegistration.email) {
                const response = await fetch(`${this.API_BASE}/auth/resend-verification`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ email: this.pendingRegistration.email })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    this.showNotification('üìß New verification email sent! Check your inbox.', 'success');
                } else {
                    this.showNotification('‚ùå Failed to resend verification email.', 'error');
                    console.error('Resend verification error:', result);
                }
            }
            
            // For demo purposes, also generate new code for testing
            this.verificationCode = this.generateVerificationCode();
            
            // Clear current inputs
            document.querySelectorAll('.code-digit').forEach(input => input.value = '');
            const code1Input = document.getElementById('code-1');
            if (code1Input) code1Input.focus();
            
            // Start countdown
            let countdown = 30;
            const countdownInterval = setInterval(() => {
                resendBtn.textContent = `Resend (${countdown}s)`;
                countdown--;
                
                if (countdown < 0) {
                    clearInterval(countdownInterval);
                    resendBtn.textContent = originalText;
                    resendBtn.disabled = false;
                }
            }, 1000);
            
        } catch (error) {
            console.error('Resend error:', error);
            this.showNotification('‚ùå Failed to resend code. Please try again.', 'error');
            resendBtn.textContent = originalText;
            resendBtn.disabled = false;
        }
    }

    setupLandingPageButtons() {
        // Only setup once to avoid duplicate listeners
        if (this.landingPageSetup) return;
        this.landingPageSetup = true;

        // Get all landing page buttons
        const heroRegisterBtn = document.getElementById('hero-register-btn');
        const heroLoginBtn = document.getElementById('hero-login-btn');
        const ctaRegisterBtn = document.getElementById('cta-register-btn');
        const ctaLoginBtn = document.getElementById('cta-login-btn');

        // Setup event listeners
        if (heroRegisterBtn) {
            heroRegisterBtn.addEventListener('click', () => this.modalManager.showRegisterSlideout());
        }
        if (heroLoginBtn) {
            heroLoginBtn.addEventListener('click', () => this.modalManager.showLoginSlideout());
        }
        if (ctaRegisterBtn) {
            ctaRegisterBtn.addEventListener('click', () => this.modalManager.showRegisterSlideout());
        }
        if (ctaLoginBtn) {
            ctaLoginBtn.addEventListener('click', () => this.modalManager.showLoginSlideout());
        }

        // Add smooth scroll for internal navigation (if needed)
        this.setupSmoothScroll();

        // Add intersection observer for animations
        this.setupScrollAnimations();
    }

    setupSmoothScroll() {
        // Add smooth scrolling between sections
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                const href = this.getAttribute('href');
                // Skip if href is just "#" or empty
                if (!href || href === '#') {
                    return;
                }
                e.preventDefault();
                try {
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                } catch (error) {
                    // Invalid selector, ignore
                    console.error('Invalid selector for smooth scroll:', href);
                }
            });
        });
    }

    setupScrollAnimations() {
        // Create intersection observer for scroll animations
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate-in');
                }
            });
        }, observerOptions);

        // Observe feature cards, testimonials, and metric items
        document.querySelectorAll('.feature-card, .testimonial-card, .metric-item').forEach(el => {
            observer.observe(el);
        });
    }

    showFieldError(fieldId, message) {
        const field = document.getElementById(fieldId);
        const errorElement = document.getElementById(fieldId + '-error');
        
        if (field && errorElement) {
            field.classList.add('error');
            
            // Fix the actual input field text alignment
            field.style.textAlign = 'left';
            field.style.direction = 'ltr';
            
            errorElement.textContent = message;
            errorElement.classList.add('show');
            
            // Ensure error message is left-aligned
            errorElement.style.textAlign = 'left';
            errorElement.style.direction = 'ltr';
        }
    }

    clearFieldError(fieldId) {
        const field = document.getElementById(fieldId);
        const errorElement = document.getElementById(fieldId + '-error');
        
        if (field && errorElement) {
            field.classList.remove('error');
            errorElement.textContent = '';
            errorElement.classList.remove('show');
        }
    }

    clearAllFieldErrors() {
        // Clear login form errors
        this.clearFieldError('login-username');
        this.clearFieldError('login-password');
        
        // Clear registration form errors (if they exist)
        this.clearFieldError('register-username');
        this.clearFieldError('register-email');
        this.clearFieldError('register-password');
        this.clearFieldError('register-confirm-password');
    }

    async handleLogin(e) {
        const form = e.target;
        const submitBtn = form.querySelector('button[type="submit"]');
        
        // Prevent multiple simultaneous login attempts
        if (form.classList.contains('loading') || (submitBtn && submitBtn.disabled)) {
            e.preventDefault();
            return;
        }
        
        const formData = new FormData(form);
        const usernameElement = document.getElementById('login-username');
        const passwordElement = document.getElementById('login-password');
        
        if (!usernameElement || !passwordElement) {
            if (window.errorManager) {
                window.errorManager.warnOnce('login_form_elements_missing', 'Login form elements not found', 'auth');
            } else {
                console.error('‚ùå Login form elements not found');
            }
            this.showMessage('Login form not available. Please refresh the page.', 'error');
            return;
        }
        
        const username = usernameElement.value;
        const password = passwordElement.value;

        // Clear previous messages and field errors
        this.showMessage('', 'info');
        this.clearAllFieldErrors();
        form.classList.add('loading');
        
        // Disable submit button
        if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Logging in...';
        }

        const result = await this.login(username, password);
        
        form.classList.remove('loading');
        
        // Re-enable submit button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Login';
        }
        
        if (result.success) {
            this.showMessage('Login successful!', 'success');
        } else {
            // Check if it's an email verification error
            if (result.needsVerification) {
                // Email verification message is already shown by the login method
                // Don't show an additional error message
                return;
            } else {
                // Display field-specific error and toast notification for better visibility
                if (result.error.includes('Invalid credentials') || result.error.includes('password')) {
                    this.showFieldError('login-password', 'Invalid username or password');
                    this.showNotification('Invalid username or password', 'error');
                } else if (result.error.includes('Username') || result.error.includes('username')) {
                    this.showFieldError('login-username', result.error);
                    this.showNotification(result.error, 'error');
                } else if (result.error.includes('wait')) {
                    // Rate limiting - show on both fields
                    this.showFieldError('login-username', result.error);
                    this.showFieldError('login-password', result.error);
                    this.showNotification(result.error, 'error');
                } else {
                    // Fallback to password field for unknown errors
                    this.showFieldError('login-password', result.error);
                    this.showNotification(result.error, 'error');
                }
            }
        }
    }

    async handleRegister(e) {
        const form = e.target;
        
        // Get all register form elements with defensive checks
        const firstNameElement = document.getElementById('register-first-name');
        const lastNameElement = document.getElementById('register-last-name');
        const usernameElement = document.getElementById('register-username');
        const emailElement = document.getElementById('register-email');
        const passwordElement = document.getElementById('register-password');
        const confirmPasswordElement = document.getElementById('register-confirm-password');
        
        if (!firstNameElement || !lastNameElement || !usernameElement || !emailElement || !passwordElement || !confirmPasswordElement) {
            if (window.errorManager) {
                window.errorManager.warnOnce('register_form_elements_missing', 'Register form elements not found', 'auth');
            } else {
                console.error('‚ùå Register form elements not found');
            }
            this.showMessage('Registration form not available. Please refresh the page.', 'error');
            return;
        }
        
        const firstName = firstNameElement.value;
        const lastName = lastNameElement.value;
        const username = usernameElement.value;
        const email = emailElement.value;
        const password = passwordElement.value;
        const confirmPassword = confirmPasswordElement.value;

        this.showMessage('', 'info'); // Clear previous messages

        if (password !== confirmPassword) {
            this.showMessage('Passwords do not match', 'error');
            this.scrollAuthModalToTop();
            return;
        }

        // Validate username format
        if (!this.formValidation.isValidUsername(username)) {
            this.showMessage('Please enter a valid username (3-20 characters, letters, numbers, underscore only)', 'error');
            this.scrollAuthModalToTop();
            return;
        }

        // Validate password strength
        if (!this.formValidation.validatePassword()) {
            this.showMessage('Please ensure your password meets all requirements', 'error');
            this.scrollAuthModalToTop();
            return;
        }

        form.classList.add('loading');

        const result = await this.register(username, email, password, firstName, lastName);
        
        form.classList.remove('loading');
        
        if (result.success) {
            if (result.needsVerification) {
                // Store registration data for verification step
                this.pendingRegistration = {
                    username,
                    email,
                    firstName,
                    lastName
                };
                
                // Show verification step
                this.showRegistrationStep2(email);
            } else {
                this.showMessage('Account created successfully!', 'success');
            }
        } else {
            // Handle specific error types with better user experience
            if (result.field === 'email' && result.error === 'Email already exists') {
                this.showEmailExistsMessage(result.message);
            } else {
                this.showMessage(result.error, 'error');
            }
            this.scrollAuthModalToTop();
        }
    }

    async handleForgotPassword(e) {
        const form = e.target;
        
        const emailElement = document.getElementById('forgot-email');
        if (!emailElement) {
            console.error('‚ùå Forgot email form element not found');
            this.showMessage('Password reset form not available. Please refresh the page.', 'error');
            return;
        }
        
        const email = emailElement.value;

        this.showMessage('', 'info'); // Clear previous messages

        if (!email) {
            this.showMessage('Please enter your email address', 'error');
            return;
        }

        // Email validation
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            this.showMessage('Please enter a valid email address', 'error');
            return;
        }

        form.classList.add('loading');

        try {
            const response = await fetch(`${this.API_BASE}/auth/forgot-password`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ email })
            });

            const result = await response.json();
            
            form.classList.remove('loading');
            
            if (response.ok) {
                this.showMessage(result.message, 'success');
                // Also show toast notification for better visibility
                this.showNotification(
                    'Password reset instructions have been sent to your email address. Please check your inbox and spam folder.', 
                    'success'
                );
                // Clear the form
                if (emailElement) emailElement.value = '';
                
                // Auto-close the forgot password modal after 3 seconds
                setTimeout(() => {
                    this.closeForgotPasswordSlideout();
                }, 3000);
            } else {
                // Handle specific error cases
                if (result.temporaryIssue) {
                    this.showMessage('Password reset is temporarily unavailable. Please contact support for assistance.', 'warning');
                    this.showNotification('Password reset is temporarily unavailable. Please contact support for assistance.', 'warning');
                } else {
                    this.showMessage(result.error || 'Failed to send reset email', 'error');
                    this.showNotification(result.error || 'Failed to send reset email', 'error');
                }
            }
        } catch (error) {
            form.classList.remove('loading');
            console.error('Forgot password error:', error);
            this.showMessage('Network error. Please try again.', 'error');
            // Also show toast notification
            this.showNotification('Network error. Please try again.', 'error');
        }
    }

    // Password validation and enhancement methods
    // setupPasswordValidation function moved to FormValidationComponent

    // togglePasswordVisibility function moved to FormValidationComponent

    // validatePassword function moved to FormValidationComponent

    // updateRequirement function moved to FormValidationComponent

    // calculatePasswordStrength function moved to FormValidationComponent

    // updatePasswordStrength function moved to FormValidationComponent

    // validatePasswordMatch function moved to FormValidationComponent

    // showPasswordRequirements function moved to FormValidationComponent

    async checkUsernameAvailability() {
        const usernameInput = document.getElementById('register-username');
        const statusIndicator = document.getElementById('username-status');
        
        if (!usernameInput || !statusIndicator) return;
        
        const username = usernameInput.value.trim();
        const statusIcon = statusIndicator.querySelector('.status-icon');
        const statusText = statusIndicator.querySelector('.status-text');
        
        // Hide indicator if username is empty
        if (username.length === 0) {
            statusIndicator.style.display = 'none';
            return;
        }
        
        // Validate username format first
        if (!this.formValidation.isValidUsername(username)) {
            statusIndicator.style.display = 'flex';
            statusIndicator.className = 'username-status invalid';
            statusText.textContent = 'Invalid format';
            return;
        }
        
        // Show checking status
        statusIndicator.style.display = 'flex';
        statusIndicator.className = 'username-status checking';
        statusText.textContent = 'Checking...';
        
        try {
            const response = await fetch(`${this.API_BASE}/auth/check-username`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username })
            });
            
            const result = await response.json();
            
            if (response.ok) {
                if (result.available) {
                    statusIndicator.className = 'username-status available';
                    statusText.textContent = 'Available';
                } else {
                    statusIndicator.className = 'username-status unavailable';
                    statusText.textContent = 'Already taken';
                }
            } else {
                // Handle API error gracefully
                statusIndicator.style.display = 'none';
            }
        } catch (error) {
            // Hide indicator on network error to avoid user confusion
            console.error('Username check error:', error);
            statusIndicator.style.display = 'none';
        }
    }
    
    // isValidUsername function moved to FormValidationComponent

    scrollAuthModalToTop() {
        // Scroll the auth modal content to top so user can see error messages
        const authForm = document.querySelector('.auth-form');
        if (authForm) {
            authForm.scrollTop = 0;
        }
        // Also scroll the modal container itself
        const modal = document.getElementById('auth-modal');
        if (modal) {
            modal.scrollTop = 0;
        }
    }

    showMessage(message, type) {
        // Remove existing messages
        const existingMessages = document.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());

        if (!message) return;

        // Create new message
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = message;

        // Insert at the top of the active form
        const activeForm = document.querySelector('.auth-form:not([style*="display: none"])');
        if (activeForm) {
            activeForm.insertBefore(messageDiv, activeForm.firstChild);
        }
    }

    showEmailExistsMessage(message) {
        // Remove existing messages
        const existingMessages = document.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());

        // Create enhanced message with login link
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message error email-exists-message';
        
        const messageText = document.createElement('p');
        messageText.textContent = message;
        messageDiv.appendChild(messageText);

        const loginLinkContainer = document.createElement('p');
        loginLinkContainer.className = 'login-suggestion';
        
        const loginLink = document.createElement('a');
        loginLink.href = '#';
        loginLink.className = 'auth-link';
        loginLink.textContent = 'Sign in to your existing account';
        loginLink.onclick = (e) => {
            e.preventDefault();
            this.showLoginForm();
        };
        
        loginLinkContainer.appendChild(loginLink);
        messageDiv.appendChild(loginLinkContainer);

        // Insert at the top of the active form
        const activeForm = document.querySelector('.auth-form:not([style*="display: none"])');
        if (activeForm) {
            activeForm.insertBefore(messageDiv, activeForm.firstChild);
        }
    }

    clearMessages() {
        const messages = document.querySelectorAll('.message');
        messages.forEach(msg => msg.remove());
    }

    setupNavigation() {
        const navButtons = document.querySelectorAll('.nav-btn');
        const views = document.querySelectorAll('.view');

        navButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const targetView = btn.dataset.view || btn.id.replace('-btn', '');
                
                navButtons.forEach(b => b.classList.remove('active'));
                views.forEach(v => v.classList.remove('active'));
                
                btn.classList.add('active');
                const targetElement = document.getElementById(targetView);
                if (targetElement) {
                    targetElement.classList.add('active');
                }
                
                this.currentView = targetView;
                
                // Always scroll to top when switching main tabs
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // Load data when switching to specific views
                if (targetView === 'settings') {
                    this.loadSystemManagement();
                } else if (targetView === 'plants') {
                    this.updatePlantManagement();
                    this.updatePlantNutrientData().catch(console.error);
                } else if (targetView === 'fish-tank') {
                    // Ensure fish overview tab is active and loaded when fish tank view is accessed
                    setTimeout(async () => {
                        console.log('üêü Fish tab clicked - ensuring overview is loaded...');
                        
                        // Wait for any ongoing operations to complete
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Force activate the fish overview tab
                        const fishTabs = document.querySelectorAll('.fish-mgmt-tab');
                        const fishContents = document.querySelectorAll('.fish-mgmt-content');
                        const overviewTab = document.getElementById('fish-overview-tab');
                        const overviewContent = document.getElementById('fish-overview-content');
                        
                        if (overviewTab && overviewContent) {
                            // Reset all fish tabs
                            fishTabs.forEach(t => t.classList.remove('active'));
                            fishContents.forEach(c => {
                                c.classList.remove('active');
                                c.style.display = '';
                            });
                            
                            // Activate overview tab
                            overviewTab.classList.add('active');
                            overviewContent.classList.add('active');
                            overviewContent.style.display = 'block';
                            
                            // Allow DOM to update
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        
                        // Load fish overview data with proper timing
                        await this.loadFishOverview();
                    }, 400);
                }
            });
        });
    }

    setupCalculatorTabs() {
        console.log('üîß Setting up Calculator tabs...');
        const calcTabs = document.querySelectorAll('.calc-tab');
        const calcContents = document.querySelectorAll('.calculator-content');

        calcTabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Calculator tab clicked:', targetContent);
                
                calcTabs.forEach(t => t.classList.remove('active'));
                calcContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                } else {
                    console.error('Could not find element with ID:', targetContent);
                }
                
                this.currentCalcTab = targetContent;
                
                // Load data for specific tabs
                if (targetContent === 'quick-calc-content') {
                    console.log('üì° Loading initializeNutrientCalculator...');
                    await this.initializeNutrientCalculator();
                }
                else if (targetContent === 'mixing-schedule-content') {
                    console.log('üì° Loading loadDosingSchedulePDF...');
                    await this.loadDosingSchedulePDF();
                }
                else if (targetContent === 'custom-nutrients-content') {
                    console.log('üì° Loading loadAvailableNutrients...');
                    await this.loadAvailableNutrients();
                }
                
                // Legacy support for existing calculator tabs
                if (targetContent === 'nutrient-calc') {
                    this.initializeNutrientCalculator();
                } else if (targetContent === 'fish-calc') {
                    this.initializeFishCalculator();
                }
            });
        });
    }

    setupDataEntryTabs() {
        const dataTabs = document.querySelectorAll('.data-tab');
        const dataForms = document.querySelectorAll('.data-form');

        dataTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetForm = tab.id.replace('-tab', '-form');
                
                dataTabs.forEach(t => t.classList.remove('active'));
                dataForms.forEach(f => f.classList.remove('active'));
                
                tab.classList.add('active');
                const targetElement = document.getElementById(targetForm);
                if (targetElement) {
                    targetElement.classList.add('active');
                }
                
                this.currentDataTab = targetForm;
            });
        });
    }

    setupPlantTabs() {
        // Setup the main plant management tabs immediately
        this.setupPlantManagementTabs();
        
        // Initialize the plant action tabs and forms on page load
        setTimeout(() => {
            this.setupPlantActionTabs();
            this.initializePlantActionForms();
        }, 500);
    }

    setupDashboardTabs() {
        console.log('üîß Setting up Dashboard tabs...');
        const tabs = document.querySelectorAll('.dashboard-tab');
        const contents = document.querySelectorAll('.dashboard-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Dashboard tab clicked:', targetContent);

                // Remove active states
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active states
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                }

                // Load data for specific tabs
                if (targetContent === 'dashboard-overview-content') {
                    console.log('üì° Loading loadActionsRequired...');
                    await this.loadActionsRequired();
                    this.initializeCharts();
                    
                    // Force chart visibility check after tab becomes active
                    setTimeout(() => {
                        if (this.charts && this.charts.forceChartVisibilityCheck) {
                            console.log('üîß Forcing chart visibility check for dashboard overview...');
                            this.charts.forceChartVisibilityCheck();
                        }
                    }, 500);
                } else if (targetContent === 'dashboard-farm-layout-content') {
                    console.log('üì° Loading loadSVG...');
                    await this.loadSVG();
                } else if (targetContent === 'dashboard-actions-content') {
                    console.log('üì° Loading loadActionsRequired...');
                    await this.loadActionsRequired();
                }
            });
        });
    }

    setupPlantManagementTabs() {

        const mgmtTabs = document.querySelectorAll('.plant-mgmt-tab');
        const mgmtContents = document.querySelectorAll('.plant-mgmt-content');

        mgmtTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetContent = tab.id.replace('-tab', '-content');

                mgmtTabs.forEach(t => t.classList.remove('active'));
                mgmtContents.forEach(c => {
                    c.classList.remove('active');
                    // Reset forced styles on all content
                    c.style.display = '';
                    c.style.visibility = '';
                    c.style.opacity = '';
                    c.style.position = '';
                    c.style.zIndex = '';
                });
                
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);

                if (targetElement) {
                    targetElement.classList.add('active');
                    // Force visibility with direct styles only for active element
                    targetElement.style.display = 'block';
                    targetElement.style.visibility = 'visible';
                    targetElement.style.opacity = '1';
                    targetElement.style.position = 'relative';
                    targetElement.style.zIndex = '999';
                }
                
                // Scroll to top when switching plant management tabs
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // Load data for specific tabs
                if (targetContent === 'plant-overview-content') {
                    this.updatePlantOverview().catch(console.error);
                    // Ensure nutrient data is loaded for plant overview
                    setTimeout(() => {
                        this.updatePlantNutrientData().catch(console.error);
                    }, 200);
                } else if (targetContent === 'allocation-management-content') {
                    this.loadPlantAllocations();
                } else if (targetContent === 'custom-crops-content') {
                    this.loadCustomCrops();
                } else if (targetContent === 'spray-programmes-content') {

                    this.setupSprayProgrammes();
                } else if (targetContent === 'planting-harvesting-content') {

                    // Ensure the plants view is active
                    const plantsView = document.getElementById('plants');
                    if (!plantsView.classList.contains('active')) {

                        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                        plantsView.classList.add('active');
                        const plantsNavBtn = document.querySelector('[data-view="plants"]') || document.getElementById('plants-btn');
                        if (plantsNavBtn) plantsNavBtn.classList.add('active');
                    }
                    
                    const targetEl = document.getElementById(targetContent);

                    // Ensure visibility
                    if (targetEl) {
                        targetEl.style.display = 'block';
                        targetEl.style.visibility = 'visible';
                        targetEl.style.opacity = '1';
                    }
                    
                    setTimeout(() => {
                        try {
                            this.setupPlantActionTabs();
                            this.initializePlantActionForms();
                            this.updateRecentPlantEntries();

                        } catch (error) {
                            console.error('Error initializing Plant & Harvest tab:', error);
                        }
                    }, 100);
                }
            });
        });
        
        // Setup action tabs for plant/harvest
        this.setupPlantActionTabs();
    }

    setupPlantActionTabs() {
        console.log('üîß Setting up Plant Action tabs...');
        const actionTabs = document.querySelectorAll('.plant-action-tab');
        const actionContents = document.querySelectorAll('.plant-action-content');

        actionTabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Plant Action tab clicked:', targetContent);

                actionTabs.forEach(t => t.classList.remove('active'));
                actionContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                }

                // Load data for specific tabs
                if (targetContent === 'plant-actions-content') {
                    console.log('üì° Loading initializePlantActionForms...');
                    await this.initializePlantActionForms();
                }
                else if (targetContent === 'beds-overview-content') {
                    console.log('üì° Loading loadBedsOverview...');
                    await this.loadBedsOverview();
                }
                else if (targetContent === 'plants-management-content') {
                    console.log('üì° Loading loadPlantsManagement...');
                    await this.loadPlantsManagement();
                }
                else if (targetContent === 'planting-form-content') {
                    console.log('üì° Loading initializePlantActionForms...');
                    await this.initializePlantActionForms();
                }
                else if (targetContent === 'harvesting-form-content') {
                    console.log('üì° Loading initializePlantActionForms...');
                    await this.initializePlantActionForms();
                }
            });
        });
    }

    async initializePlantActionForms() {
        // Set current date/time for forms
        const plantDateInput = document.getElementById('plant-date');
        const harvestDateInput = document.getElementById('harvest-date');
        const currentDateTime = new Date().toISOString().slice(0, 16);
        
        if (plantDateInput) plantDateInput.value = currentDateTime;
        if (harvestDateInput) harvestDateInput.value = currentDateTime;
        
        // Populate grow bed dropdowns
        if (this.activeSystemId) {
            try {
                const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
                const plantBedSelect = document.getElementById('plant-grow-bed');
                const harvestBedSelect = document.getElementById('harvest-grow-bed');
                
                if (plantBedSelect && harvestBedSelect) {
                    // Clear existing options
                    plantBedSelect.innerHTML = '<option value="">Select Grow Bed</option>';
                    harvestBedSelect.innerHTML = '<option value="">Select Grow Bed</option>';
                    
                    growBeds.forEach(bed => {
                        const bedTypeName = bed.bed_type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const option = `<option value="${bed.id}">Bed ${bed.bed_number} - ${bedTypeName}</option>`;
                        plantBedSelect.innerHTML += option;
                        harvestBedSelect.innerHTML += option;
                    });
                    
                    // Remove existing event listeners to prevent duplicates
                    plantBedSelect.replaceWith(plantBedSelect.cloneNode(true));
                    harvestBedSelect.replaceWith(harvestBedSelect.cloneNode(true));
                    
                    // Get the new elements after cloning
                    const newPlantBedSelect = document.getElementById('plant-grow-bed');
                    const newHarvestBedSelect = document.getElementById('harvest-grow-bed');
                    
                    // Add event listeners for bed selection changes
                    newPlantBedSelect.addEventListener('change', () => {
                        this.updatePlantCropDropdown();
                        this.updateRemainingPlantsDisplay();
                    });
                    newHarvestBedSelect.addEventListener('change', () => {
                        this.updateHarvestCropDropdown();
                        // Hide batch summary and clear selections when bed changes
                        const summaryContainer = document.getElementById('harvest-batch-summary');
                        if (summaryContainer) summaryContainer.style.display = 'none';
                        this.clearBatchSelections();
                    });
                    
                    // Add event listener for plant crop type changes  
                    const plantCropSelect = document.getElementById('plant-crop-type');
                    if (plantCropSelect) {
                        plantCropSelect.addEventListener('change', () => {
                            this.updateRemainingPlantsDisplay();
                            this.updateSeedVarietiesForCrop(plantCropSelect.value);
                        });
                    }
                    
                    // Initialize seed variety dropdown functionality
                    this.initializeSeedVarietyDropdown();
                    
                    // Add event listener for harvest crop type changes
                    const harvestCropSelect = document.getElementById('harvest-crop-type');
                    if (harvestCropSelect) {
                        harvestCropSelect.addEventListener('change', async () => {
                            await this.updateHarvestBatchSummary();
                            // Check if there's a pending batch preselection
                            if (this.pendingBatchPreselection) {
                                this.preselectBatchInCheckboxes(this.pendingBatchPreselection);
                                this.pendingBatchPreselection = null;
                            }
                        });
                    }
                }
                
                // Initialize crop dropdowns
                await this.updatePlantCropDropdown();
                await this.updateHarvestCropDropdown();
                
                // Initialize remaining plants display
                await this.updateRemainingPlantsDisplay();
                
            } catch (error) {
                console.error('Error loading grow beds for plant forms:', error);
            }
        }
    }

    async updatePlantCropDropdown() {
        const plantCropSelect = document.getElementById('plant-crop-type');
        
        if (!plantCropSelect) return;
        
        // Clear existing options and add all available crops
        plantCropSelect.innerHTML = `
            <option value="">Select Crop</option>
            <optgroup label="Leafy Greens">
                <option value="lettuce">Lettuce</option>
                <option value="spinach">Spinach</option>
                <option value="kale">Kale</option>
                <option value="arugula">Arugula</option>
                <option value="swiss_chard">Swiss Chard</option>
                <option value="pac_choi">Pac Choi</option>
            </optgroup>
            <optgroup label="Herbs">
                <option value="basil">Basil</option>
                <option value="mint">Mint</option>
                <option value="parsley">Parsley</option>
                <option value="cilantro">Cilantro</option>
                <option value="chives">Chives</option>
            </optgroup>
            <optgroup label="Fruiting Vegetables">
                <option value="tomatoes">Tomatoes</option>
                <option value="peppers">Peppers</option>
                <option value="cucumbers">Cucumbers</option>
            </optgroup>
        `;
        
        // Add custom crops if available
        try {
            const customCrops = await this.makeApiCall(`/plants/custom-crops`);
            if (customCrops && customCrops.length > 0) {
                let customOptionsHtml = '<optgroup label="Custom Crops">';
                customCrops.forEach(crop => {
                    const cleanName = this.cleanCustomCropName(crop.crop_name);
                    customOptionsHtml += `<option value="${crop.crop_name}">${cleanName}</option>`;
                });
                customOptionsHtml += '</optgroup>';
                plantCropSelect.innerHTML += customOptionsHtml;
            }
        } catch (error) {
        }
        
        // Add admin crops from global database
        try {
            const adminCrops = await this.makeApiCall('/crop-knowledge/crops');
            if (adminCrops && adminCrops.success && adminCrops.data && adminCrops.data.length > 0) {
                let adminOptionsHtml = '<optgroup label="Global Crop Database">';
                adminCrops.data.forEach(crop => {
                    // Skip if this crop is already in custom crops to avoid duplicates
                    const isDuplicate = customCrops && customCrops.some(customCrop => 
                        customCrop.crop_name.toLowerCase() === crop.code.toLowerCase()
                    );
                    if (!isDuplicate) {
                        adminOptionsHtml += `<option value="${crop.code}">${crop.name}</option>`;
                    }
                });
                adminOptionsHtml += '</optgroup>';
                plantCropSelect.innerHTML += adminOptionsHtml;
            }
        } catch (error) {
            console.log('Global crop database not available:', error);
        }
        
        plantCropSelect.innerHTML += '<option value="other">Other</option>';
    }

    async updateHarvestCropDropdown() {
        const harvestBedSelect = document.getElementById('harvest-grow-bed');
        const harvestCropSelect = document.getElementById('harvest-crop-type');
        
        if (!harvestCropSelect) return;
        
        // Clear existing options
        harvestCropSelect.innerHTML = '<option value="">Select Crop</option>';
        
        if (!this.activeSystemId) {
            harvestCropSelect.innerHTML += '<option value="" disabled>Please select a system first</option>';
            return;
        }
        
        const selectedBedId = harvestBedSelect?.value;
        
        if (!selectedBedId) {
            harvestCropSelect.innerHTML += '<option value="" disabled>Please select a grow bed first</option>';
            return;
        }
        
        try {
            // Get all planted crops in the selected bed based on batch data
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            const plantedCrops = plantData
                .filter(entry => entry.grow_bed_id == selectedBedId && 
                    (entry.new_seedlings > 0 || entry.count > 0)) // Support both batch and legacy entries
                .map(entry => entry.crop_type)
                .filter(Boolean);
            
            // Get unique crop types that have been planted
            const uniquePlantedCrops = [...new Set(plantedCrops)];
            
            if (uniquePlantedCrops.length === 0) {
                harvestCropSelect.innerHTML += '<option value="" disabled>No crops planted in this bed yet</option>';
                return;
            }
            
            // Sort and add all planted crops to dropdown
            uniquePlantedCrops.sort((a, b) => a.localeCompare(b)).forEach(cropType => {
                const cleanCropName = this.cleanCustomCropName(cropType);
                const cropName = cleanCropName.charAt(0).toUpperCase() + cleanCropName.slice(1);
                harvestCropSelect.innerHTML += `<option value="${cropType}">${cropName}</option>`;
            });
            
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('harvest_crops_load_error', 'Error loading planted crops for harvest', this.activeSystemId);
            } else {
                console.error('Error loading planted crops for harvest:', error);
            }
            if (harvestCropSelect) {
                harvestCropSelect.innerHTML += '<option value="" disabled>Error loading planted crops</option>';
            }
        }
    }

    // Legacy function - kept for backward compatibility but now redirects to updateHarvestCropDropdown
    async populateHarvestCropDropdown() {
        await this.updateHarvestCropDropdown();
    }

    // Plant management functionality
    async updateRemainingPlantsDisplay() {
        const plantBedSelect = document.getElementById('plant-grow-bed');
        const plantCropSelect = document.getElementById('plant-crop-type');
        const remainingPlantsDisplay = document.getElementById('remaining-plants-display');
        const remainingPlantsContainer = document.getElementById('remaining-plants-container');
        
        if (!plantBedSelect || !remainingPlantsDisplay || !remainingPlantsContainer) {
            return;
        }
        
        const selectedBedId = plantBedSelect.value;
        const selectedCrop = plantCropSelect ? plantCropSelect.value : null;
        
        // Hide display if no bed selected
        if (!selectedBedId) {
            remainingPlantsDisplay.style.display = 'none';
            return;
        }
        
        try {
            // Get current plant data, grow bed data, and allocations
            const [plantData, growBeds, allocations] = await Promise.all([
                this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`),
                this.getGrowBedsForSystem(),
                this.makeApiCall(`/plants/allocations/${this.activeSystemId}`)
            ]);
            
            // Find the selected bed
            const selectedBed = growBeds.find(bed => bed.id === parseInt(selectedBedId));
            
            // Get all active batches for this bed
            const activeBatches = this.getActiveBatchesForBed(plantData, selectedBedId);
            
            let html = '<div class="bed-capacity-info">';
            
            if (selectedCrop) {
                // Show crop-specific capacity
                const cropAllocation = allocations.find(alloc => 
                    parseInt(alloc.grow_bed_id) === parseInt(selectedBedId) && 
                    alloc.crop_type.toLowerCase() === selectedCrop.toLowerCase()
                );
                
                if (cropAllocation) {
                    // Calculate allocated area and capacity for this crop
                    const bedArea = selectedBed ? (selectedBed.equivalent_m2 || 0) : 0;
                    const allocatedPercentage = parseFloat(cropAllocation.percentage_allocated) || 0;
                    const allocatedArea = (allocatedPercentage / 100) * bedArea;
                    const plantSpacing = parseFloat(cropAllocation.plant_spacing) || 30;
                    
                    // Calculate capacity from allocated area and spacing
                    const areaCm2 = allocatedArea * 10000;
                    const spacePerPlant = plantSpacing * plantSpacing;
                    const cropCapacity = Math.floor(areaCm2 / spacePerPlant);
                    
                    // Calculate currently planted for this crop
                    const cropBatches = activeBatches.filter(batch => 
                        batch.cropType.toLowerCase() === selectedCrop.toLowerCase()
                    );
                    const currentlyPlanted = cropBatches.reduce((sum, batch) => sum + (batch.planted - batch.harvested), 0);
                    const availableSpaces = Math.max(0, cropCapacity - currentlyPlanted);
                    
                    html += `<div class="capacity-summary">`;
                    html += `<span class="capacity-label">${this.cleanCropName(selectedCrop)} Capacity:</span>`;
                    html += `<span class="capacity-used">${currentlyPlanted}</span>`;
                    html += `<span class="capacity-separator">/</span>`;
                    html += `<span class="capacity-total">${cropCapacity}</span>`;
                    html += `<span class="capacity-available">(${availableSpaces} spaces available)</span>`;
                    html += `</div>`;
                } else {
                    html += `<div class="capacity-summary">`;
                    html += `<span class="capacity-label">${this.cleanCropName(selectedCrop)}:</span>`;
                    html += `<span class="capacity-error">No allocation found for this crop in this bed</span>`;
                    html += `</div>`;
                }
            } else {
                // Show general bed capacity if no crop selected
                const bedCapacity = selectedBed ? (selectedBed.plant_capacity || 0) : 0;
                const totalCurrentPlants = activeBatches.reduce((sum, batch) => sum + (batch.planted - batch.harvested), 0);
                const availableSpaces = Math.max(0, bedCapacity - totalCurrentPlants);
                
                html += `<div class="capacity-summary">`;
                html += `<span class="capacity-label">Bed Capacity:</span>`;
                html += `<span class="capacity-used">${totalCurrentPlants}</span>`;
                html += `<span class="capacity-separator">/</span>`;
                html += `<span class="capacity-total">${bedCapacity}</span>`;
                html += `<span class="capacity-available">(${availableSpaces} spaces available)</span>`;
                html += `</div>`;
            }
            
            html += '</div>';
            
            if (activeBatches.length === 0) {
                html += '<div class="no-batches-message">No active plant batches in this bed</div>';
                remainingPlantsContainer.innerHTML = html;
                remainingPlantsDisplay.style.display = 'block';
                return;
            }
            
            // Build HTML for all crops with remaining plants
            html += '<div class="remaining-crops-grid">';
            
            activeBatches.forEach(batch => {
                const remaining = batch.planted - batch.harvested;
                const percentage = batch.planted > 0 ? Math.round((remaining / batch.planted) * 100) : 0;
                const statusClass = remaining === 0 ? 'fully-harvested' : percentage > 50 ? 'healthy' : 'low';
                const cropIcon = this.getCropIcon(batch.cropType);
                
                html += `
                    <div class="crop-remaining-card ${statusClass}" data-batch-id="${batch.batchId}">
                        <div class="crop-header">
                            <div class="crop-title">
                                <span class="crop-icon">${cropIcon}</span>
                                <span class="crop-name">${this.cleanCropName(batch.cropType)}</span>
                            </div>
                            <button class="batch-edit-btn" onclick="window.app.editBatchGrowBed('${batch.batchId}', ${selectedBedId})" title="Change grow bed">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                </svg>
                            </button>
                        </div>
                        <div class="batch-info">
                            <span class="batch-id">Batch: ${batch.batchId}</span>
                            <span class="batch-date">${batch.plantedDate}</span>
                        </div>
                        <div class="batch-stats">
                            <div class="plant-stats">
                                <span class="planted">Planted: ${batch.planted}</span>
                                <span class="harvested">Harvested: ${batch.harvested}</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            remainingPlantsContainer.innerHTML = html;
            remainingPlantsDisplay.style.display = 'block';
            
        } catch (error) {
            console.error('Error updating remaining plants display:', error);
            remainingPlantsDisplay.style.display = 'none';
        }
    }
    
    getActiveBatchesForBed(plantData, bedId) {
        // Get all batches for this bed with remaining plants
        const batches = new Map();
        
        // Process all plant records for this bed
        plantData.forEach(record => {
            if (record.grow_bed_id == bedId && record.batch_id) {
                if (!batches.has(record.batch_id)) {
                    batches.set(record.batch_id, {
                        batchId: record.batch_id,
                        cropType: record.crop_type,
                        planted: 0,
                        harvested: 0,
                        plantedDate: record.date
                    });
                }
                
                const batch = batches.get(record.batch_id);
                
                // Track planted and harvested counts
                if (record.new_seedlings > 0) {
                    batch.planted += record.new_seedlings;
                    // Use the first planting date as the batch date
                    if (!batch.plantedDate || record.date < batch.plantedDate) {
                        batch.plantedDate = record.date;
                    }
                } else if (record.plants_harvested > 0) {
                    batch.harvested += record.plants_harvested;
                }
            }
        });
        
        // Convert to array and filter to only include batches with remaining plants
        const activeBatches = Array.from(batches.values()).filter(batch => {
            return (batch.planted - batch.harvested) > 0;
        });
        
        // Sort by planted date (most recent first)
        activeBatches.sort((a, b) => b.plantedDate.localeCompare(a.plantedDate));
        
        return activeBatches;
    }

    getCurrentBatchForCrop(plantData, bedId, cropType) {
        // Find the most recent batch for this crop in this bed that still has plants
        const cropBatches = new Map();
        
        // Process all plant records for this bed and crop
        plantData.forEach(record => {
            if (record.grow_bed_id == bedId && record.crop_type === cropType && record.batch_id) {
                if (!cropBatches.has(record.batch_id)) {
                    cropBatches.set(record.batch_id, {
                        batchId: record.batch_id,
                        planted: 0,
                        harvested: 0,
                        lastDate: record.date
                    });
                }
                
                const batch = cropBatches.get(record.batch_id);
                
                // Update last date to find most recent batch
                if (record.date > batch.lastDate) {
                    batch.lastDate = record.date;
                }
                
                // Count planted and harvested
                if (record.new_seedlings > 0) {
                    batch.planted += record.new_seedlings;
                } else if (record.plants_harvested > 0) {
                    batch.harvested += record.plants_harvested;
                }
            }
        });
        
        // Find the most recent batch that still has plants
        let currentBatch = null;
        let mostRecentDate = '';
        
        cropBatches.forEach(batch => {
            const remaining = batch.planted - batch.harvested;
            if (remaining > 0 && batch.lastDate > mostRecentDate) {
                mostRecentDate = batch.lastDate;
                currentBatch = batch;
            }
        });
        
        return currentBatch;
    }

    async recordPlanting() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }

        // Generate batch ID using utility function
        const batchId = this.generateBatchId();
        
        // Display the generated batch ID in the form
        const batchIdInput = document.getElementById('plant-batch-id');
        if (batchIdInput) batchIdInput.value = batchId;

        // Handle seed variety - check if custom variety was entered
        let seedVariety = null;
        const seedVarietySelect = document.getElementById('plant-seed-variety');
        const customVarietyInput = document.getElementById('plant-seed-variety-custom');
        const cropTypeElement = document.getElementById('plant-crop-type');
        const cropType = cropTypeElement ? cropTypeElement.value : '';
        
        if (seedVarietySelect.value === '__add_new__' && customVarietyInput.value.trim()) {
            // User wants to add a new variety
            const newVariety = customVarietyInput.value.trim();
            const success = await this.addNewSeedVariety(cropType, newVariety);
            if (success) {
                seedVariety = newVariety;
            } else {
                return; // Stop if variety addition failed
            }
        } else if (seedVarietySelect.value && seedVarietySelect.value !== '__add_new__') {
            // User selected an existing variety
            seedVariety = seedVarietySelect.value;
        }

        // Collect form data with defensive checks
        const plantDateEl = document.getElementById('plant-date');
        const plantBedEl = document.getElementById('plant-grow-bed');
        const plantCountEl = document.getElementById('plant-count');
        const plantStageEl = document.getElementById('plant-stage');
        const plantNotesEl = document.getElementById('plant-notes');
        const plantHarvestEl = document.getElementById('plant-days-to-harvest');

        if (!plantDateEl || !plantBedEl || !plantCountEl || !plantStageEl) {
            this.showNotification('Required form fields not found. Please refresh the page.', 'error');
            return;
        }

        const data = {
            date: plantDateEl.value,
            grow_bed_id: parseInt(plantBedEl.value),
            crop_type: cropType,
            count: parseInt(plantCountEl.value),
            new_seedlings: parseInt(plantCountEl.value),
            growth_stage: plantStageEl.value,
            health: 'good',
            notes: plantNotesEl ? plantNotesEl.value : '',
            // New batch tracking fields
            batch_id: batchId,
            seed_variety: seedVariety,
            batch_created_date: new Date().toISOString().split('T')[0], // YYYY-MM-DD format
            days_to_harvest: plantHarvestEl ? (parseInt(plantHarvestEl.value) || null) : null
        };

        const validation = this.formValidation.validatePlantEntry(data);
        if (!validation.valid) {
            this.showNotification(validation.message, 'warning');
            return;
        }

        try {
            await this.performSaveWithProgress('plant', async () => {
                // API call
                await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                    method: 'POST',
                    body: JSON.stringify(data)
                });
                
                // Reload data and update displays
                await this.loadDataRecords();
                await this.updateDashboardFromData();
                // Update other plant management components
                this.updateGrowBeds();
                this.updatePlantGrowthHistoryDisplay();
                this.updatePlantRecommendations();
                this.updateRecentPlantEntries();
                await this.updatePlantOverview();
                this.updateRemainingPlantsDisplay();
                
                return { success: true, batchId, cropType: data.crop_type, count: data.count };
            });
            
            // Success actions after modal closes
            this.showNotification(`üå± Recorded planting of ${data.count} ${this.cleanCustomCropName(data.crop_type)} plants in batch ${batchId}!`, 'success');
            this.clearPlantingForm();
            
            // Redirect to plant overview tab
            const overviewTab = document.getElementById('plant-overview-tab');
            if (overviewTab) {
                overviewTab.click();
            }
        } catch (error) {
            console.error('Failed to record planting:', error);
            this.showNotification('‚ùå Failed to record planting. Please try again.', 'error');
        }
    }

    async recordHarvest() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }

        const selectedBatches = this.getSelectedBatches();

        // For now, require exactly one batch selection
        if (selectedBatches.length === 0) {
            this.showNotification('Please select at least one batch to harvest from.', 'warning');
            return;
        }
        
        if (selectedBatches.length > 1) {
            this.showNotification('Please select only one batch at a time for now.', 'warning');
            return;
        }

        const batchId = selectedBatches[0];

        // Collect harvest form data with defensive checks
        const harvestDateEl = document.getElementById('harvest-date');
        const harvestBedEl = document.getElementById('harvest-grow-bed');
        const harvestCropEl = document.getElementById('harvest-crop-type');
        const harvestCountEl = document.getElementById('harvest-plant-count');
        const harvestWeightEl = document.getElementById('harvest-weight');
        const harvestQualityEl = document.getElementById('harvest-quality');
        const harvestNotesEl = document.getElementById('harvest-notes');

        if (!harvestDateEl || !harvestBedEl || !harvestCropEl || !harvestCountEl || !harvestWeightEl || !harvestQualityEl) {
            this.showNotification('Required harvest form fields not found. Please refresh the page.', 'error');
            return;
        }

        const data = {
            date: harvestDateEl.value,
            grow_bed_id: parseInt(harvestBedEl.value),
            crop_type: harvestCropEl.value,
            plants_harvested: parseInt(harvestCountEl.value),
            harvest_weight: parseFloat(harvestWeightEl.value) * 1000, // Convert kg to grams
            health: harvestQualityEl.value,
            growth_stage: 'harvest',
            notes: harvestNotesEl ? harvestNotesEl.value : '',
            // Add batch tracking
            batch_id: batchId
        };

        // Validate harvest form data
        const validation = this.formValidation.validateHarvestEntry(data);
        if (!validation.valid) {
            this.showNotification(validation.message, 'warning');
            return;
        }

        try {
            await this.performSaveWithProgress('plant', async () => {
                // API call
                await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                    method: 'POST',
                    body: JSON.stringify(data)
                });
                
                // Reload data and update displays
                await this.loadDataRecords();
                await this.updateDashboardFromData();
                // Update other plant management components
                this.updateGrowBeds();
                this.updatePlantGrowthHistoryDisplay();
                this.updatePlantRecommendations();
                this.updateRecentPlantEntries();
                await this.updatePlantOverview();
                this.updateRemainingPlantsDisplay();
                
                return { success: true, data };
            });
            
            // Success actions after modal closes
            const weightMsg = `${(data.harvest_weight/1000).toFixed(1)}kg`;
            const cropName = this.cleanCustomCropName(data.crop_type);
            let successMsg;
            
            if (data.plants_harvested > 0) {
                successMsg = `ü•¨ Recorded harvest of ${weightMsg} from ${data.plants_harvested} ${cropName} plants!`;
            } else {
                successMsg = `üçÖ Recorded harvest of ${weightMsg} ${cropName} produce (plants remain in bed)!`;
            }
            
            this.showNotification(successMsg, 'success');
            this.clearHarvestForm();
            
            // Redirect to plant overview tab
            const overviewTab = document.getElementById('plant-overview-tab');
            if (overviewTab) {
                overviewTab.click();
            }
        } catch (error) {
            console.error('Failed to record harvest:', error);
            this.showNotification('‚ùå Failed to record harvest. Please try again.', 'error');
        }
    }

    clearPlantingForm() {
        // Clear planting form with defensive checks
        const elements = {
            'plant-grow-bed': '',
            'plant-crop-type': '',
            'plant-count': '',
            'plant-stage': 'seedling',
            'plant-notes': '',
            'plant-date': new Date().toISOString().slice(0, 16),
            'plant-batch-id': '',
            'plant-seed-variety': '',
            'plant-seed-variety-custom': '',
            'plant-days-to-harvest': ''
        };
        
        Object.keys(elements).forEach(elementId => {
            const element = document.getElementById(elementId);
            if (element) element.value = elements[elementId];
        });
        
        // Hide custom variety input
        const customVarietyInput = document.getElementById('plant-seed-variety-custom');
        if (customVarietyInput) customVarietyInput.style.display = 'none';
    }

    clearHarvestForm() {
        // Clear harvest form with defensive checks
        const elements = {
            'harvest-grow-bed': '',
            'harvest-crop-type': '',
            'harvest-plant-count': '',
            'harvest-weight': '',
            'harvest-quality': 'excellent',
            'harvest-notes': '',
            'harvest-date': new Date().toISOString().slice(0, 16)
        };
        
        Object.keys(elements).forEach(elementId => {
            const element = document.getElementById(elementId);
            if (element) element.value = elements[elementId];
        });
        
        // Clear batch selections
        this.clearBatchSelections();
        
        // Hide batch summary
        const summaryContainer = document.getElementById('harvest-batch-summary');
        if (summaryContainer) summaryContainer.style.display = 'none';
    }

    // Seed variety dropdown functionality
    initializeSeedVarietyDropdown() {
        const seedVarietySelect = document.getElementById('plant-seed-variety');
        const customInput = document.getElementById('plant-seed-variety-custom');
        
        if (seedVarietySelect && customInput) {
            seedVarietySelect.addEventListener('change', (e) => {
                if (e.target.value === '__add_new__') {
                    customInput.style.display = 'block';
                    customInput.focus();
                } else {
                    customInput.style.display = 'none';
                    customInput.value = '';
                }
            });
        }
    }
    
    async updateSeedVarietiesForCrop(cropType) {
        const seedVarietySelect = document.getElementById('plant-seed-variety');
        if (!seedVarietySelect || !cropType) {
            // Reset dropdown if no crop selected
            if (seedVarietySelect) {
                seedVarietySelect.innerHTML = `
                    <option value="">Select variety...</option>
                    <option value="__add_new__">‚ûï Add New Variety</option>
                `;
            }
            return;
        }
        
        try {
            const data = await this.makeApiCall(`/seed-varieties/crop/${cropType}`);
            
            // Build dropdown options
            let optionsHtml = '<option value="">Select variety...</option>';
            
            if (data.varieties && data.varieties.length > 0) {
                data.varieties.forEach(variety => {
                    optionsHtml += `<option value="${variety.variety_name}">${variety.variety_name}</option>`;
                });
            }
            
            optionsHtml += '<option value="__add_new__">‚ûï Add New Variety</option>';
            seedVarietySelect.innerHTML = optionsHtml;
            
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('seed_varieties_fetch_failed', 'Error fetching seed varieties', this.activeSystemId);
            } else {
                console.error('Error fetching seed varieties:', error);
            }
        }
    }
    
    async addNewSeedVariety(cropType, varietyName) {
        try {
            await this.makeApiCall('/seed-varieties', {
                method: 'POST',
                body: JSON.stringify({
                    crop_type: cropType,
                    variety_name: varietyName
                })
            });
            
            // Refresh the dropdown with the new variety
            await this.updateSeedVarietiesForCrop(cropType);
            
            // Select the newly added variety
            const seedVarietySelect = document.getElementById('plant-seed-variety');
            if (seedVarietySelect) {
                seedVarietySelect.value = varietyName;
            }
            
            this.showNotification(`‚úÖ Added new variety: ${varietyName}`, 'success');
            return true;
            
        } catch (error) {
            console.error('Error adding seed variety:', error);
            this.showNotification(`‚ùå Failed to add variety: ${error.message || 'Unknown error'}`, 'error');
            return false;
        }
    }

    // Batch tracking utility functions
    generateBatchId(date = new Date()) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        
        return `BATCH_${year}${month}${day}_${hours}${minutes}${seconds}`;
    }

    parseBatchIdDate(batchId) {
        if (!batchId || !batchId.startsWith('BATCH_')) {
            return null;
        }
        
        const parts = batchId.split('_');
        if (parts.length !== 3) {
            return null;
        }
        
        const datePart = parts[1]; // YYYYMMDD
        const timePart = parts[2]; // HHMMSS
        
        if (datePart.length !== 8 || timePart.length !== 6) {
            return null;
        }
        
        const year = parseInt(datePart.substr(0, 4));
        const month = parseInt(datePart.substr(4, 2)) - 1; // Month is 0-indexed
        const day = parseInt(datePart.substr(6, 2));
        const hours = parseInt(timePart.substr(0, 2));
        const minutes = parseInt(timePart.substr(2, 2));
        const seconds = parseInt(timePart.substr(4, 2));
        
        return new Date(year, month, day, hours, minutes, seconds);
    }

    calculateBatchAge(batchIdOrBatch, currentDate = new Date()) {
        return this.plantManagement.calculateBatchAge(batchIdOrBatch, currentDate);
    }

    async updateHarvestBatchDropdown() {
        const growBedSelect = document.getElementById('harvest-grow-bed');
        const cropTypeSelect = document.getElementById('harvest-crop-type');
        const batchSelect = document.getElementById('harvest-batch-id');
        
        if (!batchSelect) {
            if (window.errorManager) {
                window.errorManager.warnOnce('missing_batch_select', 'Harvest batch select element not found', this.activeSystemId);
            } else {
                console.warn('Harvest batch select element not found');
            }
            return;
        }
        
        if (!growBedSelect || !cropTypeSelect || !growBedSelect.value || !cropTypeSelect.value) {
            batchSelect.innerHTML = '<option value="">Select batch to harvest from...</option>';
            return;
        }

        try {
            // Get plant data for the selected grow bed and crop type
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            // Filter for batches that match the selected grow bed and crop type
            // and have batch_id (planted entries, not harvests)
            const availableBatches = plantData.filter(record => {
                return record.grow_bed_id == growBedSelect.value && 
                       record.crop_type === cropTypeSelect.value &&
                       record.batch_id &&
                       record.new_seedlings > 0; // Records with new plantings (regardless of harvest status)
            });

            // Create a unique list of batches with remaining plant counts
            const uniqueBatches = {};
            availableBatches.forEach(batch => {
                if (!uniqueBatches[batch.batch_id]) {
                    uniqueBatches[batch.batch_id] = {
                        batch_id: batch.batch_id,
                        seed_variety: batch.seed_variety,
                        batch_created_date: batch.batch_created_date,
                        date_planted: batch.date, // Use actual planting date
                        days_to_harvest: batch.days_to_harvest,
                        planted_count: 0
                    };
                }
                uniqueBatches[batch.batch_id].planted_count += (batch.new_seedlings || 0);
            });
            
            // Calculate remaining plants for each batch (planted - harvested)
            Object.keys(uniqueBatches).forEach(batchId => {
                const harvestedCount = this.getBatchHarvestedCount(plantData, batchId);
                uniqueBatches[batchId].remaining_count = Math.max(0, uniqueBatches[batchId].planted_count - harvestedCount);
            });

            // Build dropdown options
            let optionsHtml = '<option value="">Select batch to harvest from...</option>';
            
            // Filter out batches with no remaining plants
            const availableBatchList = Object.values(uniqueBatches).filter(batch => batch.remaining_count > 0);
            
            if (availableBatchList.length === 0) {
                optionsHtml += '<option value="" disabled>No batches with harvestable plants available</option>';
            } else {
                availableBatchList.forEach(batch => {
                    try {
                        const age = this.calculateBatchAge(batch); // Pass full batch object
                        const variety = batch.seed_variety ? ` (${batch.seed_variety})` : '';
                        const harvestInfo = batch.days_to_harvest ? 
                            `, ${batch.days_to_harvest - age} days until expected harvest` : '';
                        
                        optionsHtml += `<option value="${batch.batch_id}">
                            ${batch.batch_id}${variety} - ${batch.remaining_count} plants available, ${age} days old${harvestInfo}
                        </option>`;
                    } catch (error) {
                        console.error('Error processing batch:', batch.batch_id, error);
                        optionsHtml += `<option value="${batch.batch_id}">
                            ${batch.batch_id} - ${batch.remaining_count} plants available
                        </option>`;
                    }
                });
            }

            batchSelect.innerHTML = optionsHtml;
            
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('batch_data_load_error', 'Error loading batch data', this.activeSystemId);
            } else {
                console.error('Error loading batch data:', error);
            }
            if (batchSelect) {
                batchSelect.innerHTML = '<option value="">Error loading batches</option>';
            }
        }
    }

    async updateHarvestBatchSummary() {
        const growBedSelect = document.getElementById('harvest-grow-bed');
        const cropTypeSelect = document.getElementById('harvest-crop-type');
        const summaryContainer = document.getElementById('harvest-batch-summary');
        const summaryContent = document.getElementById('harvest-batch-summary-content');
        
        if (!growBedSelect.value || !cropTypeSelect.value) {
            summaryContainer.style.display = 'none';
            return;
        }

        try {
            // Get plant data for the selected grow bed and crop type
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            
            // Filter for batches that match the selected grow bed and crop type
            const availableBatches = plantData.filter(record => {
                const matches = record.grow_bed_id == growBedSelect.value && 
                       record.crop_type === cropTypeSelect.value &&
                       record.batch_id &&
                       record.new_seedlings > 0; // Records with new plantings (regardless of harvest status)
                
                if (record.batch_id === 'batch_tomato_20250727') {
                }
                
                return matches;
            });
            

            // Create a unique list of batches with remaining plant counts
            const uniqueBatches = {};
            availableBatches.forEach(batch => {
                if (!uniqueBatches[batch.batch_id]) {
                    uniqueBatches[batch.batch_id] = {
                        batch_id: batch.batch_id,
                        seed_variety: batch.seed_variety,
                        batch_created_date: batch.batch_created_date,
                        date_planted: batch.date, // Use actual planting date
                        days_to_harvest: batch.days_to_harvest,
                        planted_count: 0
                    };
                }
                uniqueBatches[batch.batch_id].planted_count += (batch.new_seedlings || 0);
            });
            
            // Calculate remaining plants for each batch (planted - harvested)
            Object.keys(uniqueBatches).forEach(batchId => {
                const harvestedCount = this.getBatchHarvestedCount(plantData, batchId);
                uniqueBatches[batchId].remaining_count = Math.max(0, uniqueBatches[batchId].planted_count - harvestedCount);
            });

            // Filter out batches with no remaining plants
            const availableBatchList = Object.values(uniqueBatches).filter(batch => batch.remaining_count > 0);
            
            // Debug: Log batch processing results
            if (Object.keys(uniqueBatches).length > 0) {
            }
            
            if (availableBatchList.length === 0) {
                summaryContent.innerHTML = '<div class="no-batches">No batches with harvestable plants available for this crop</div>';
            } else {
                let summaryHtml = '';
                availableBatchList.forEach(batch => {
                    try {
                        const age = this.calculateBatchAge(batch); // Pass full batch object
                        const variety = batch.seed_variety ? ` (${batch.seed_variety})` : '';
                        const harvestInfo = batch.days_to_harvest ? 
                            `, ${batch.days_to_harvest - age} days until expected harvest` : '';
                        
                        summaryHtml += `
                            <div class="batch-summary-item selectable" data-batch-id="${batch.batch_id}">
                                <div class="batch-checkbox-container">
                                    <input type="checkbox" class="batch-checkbox" id="batch-${batch.batch_id}" 
                                           data-batch-id="${batch.batch_id}">
                                    <div class="batch-checkbox-content">
                                        <div class="batch-summary-row">
                                            <span class="batch-id">${batch.batch_id}${variety}</span>
                                            <span class="batch-plants">${batch.remaining_count} plants</span>
                                        </div>
                                        <div class="batch-summary-row">
                                            <span class="batch-age">${age} days old</span>
                                            ${harvestInfo ? `<span class="batch-harvest-info">${harvestInfo}</span>` : ''}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } catch (error) {
                        console.error('Error processing batch:', batch.batch_id, error);
                        summaryHtml += `
                            <div class="batch-summary-item selectable" data-batch-id="${batch.batch_id}">
                                <div class="batch-checkbox-container">
                                    <input type="checkbox" class="batch-checkbox" id="batch-${batch.batch_id}" 
                                           data-batch-id="${batch.batch_id}">
                                    <div class="batch-checkbox-content">
                                        <div class="batch-summary-row">
                                            <span class="batch-id">${batch.batch_id}</span>
                                            <span class="batch-plants">${batch.remaining_count} plants</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });
                summaryContent.innerHTML = summaryHtml;
                
                // Add event listeners for checkboxes
                this.setupBatchCheckboxListeners();
            }

            summaryContainer.style.display = 'block';
            
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('batch_summary_load_error', 'Error loading batch summary', this.activeSystemId);
            } else {
                console.error('Error loading batch summary:', error);
            }
            if (summaryContent) {
                summaryContent.innerHTML = '<div class="no-batches">Error loading batch information</div>';
            }
            if (summaryContainer) {
                summaryContainer.style.display = 'block';
            }
        }
    }

    setupBatchCheckboxListeners() {
        const checkboxes = document.querySelectorAll('.batch-checkbox');
        const batchItems = document.querySelectorAll('.batch-summary-item.selectable');
        
        // Add click listeners to checkboxes
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const batchId = e.target.dataset.batchId;
                this.toggleBatchSelection(batchId, e.target.checked);
            });
        });
        
        // Add click listeners to batch items (clicking anywhere toggles checkbox)
        batchItems.forEach(item => {
            item.addEventListener('click', (e) => {
                // Don't trigger if the checkbox itself was clicked
                if (e.target.type === 'checkbox') return;
                
                const batchId = item.dataset.batchId;
                const checkbox = item.querySelector('.batch-checkbox');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    this.toggleBatchSelection(batchId, checkbox.checked);
                }
            });
        });
    }

    toggleBatchSelection(batchId, isSelected) {
        const batchItem = document.querySelector(`.batch-summary-item[data-batch-id="${batchId}"]`);
        
        if (isSelected) {
            batchItem.classList.add('selected');
            this.addToSelectedBatches(batchId);
        } else {
            batchItem.classList.remove('selected');
            this.removeFromSelectedBatches(batchId);
        }
        
        this.updateSelectedBatchesDisplay();
    }

    addToSelectedBatches(batchId) {
        if (!this.selectedBatches) {
            this.selectedBatches = new Set();
        }
        this.selectedBatches.add(batchId);
    }

    removeFromSelectedBatches(batchId) {
        if (this.selectedBatches) {
            this.selectedBatches.delete(batchId);
        }
    }

    updateSelectedBatchesDisplay() {
        const selectedBatchesContainer = document.getElementById('selected-batches-display');
        const selectedBatchesList = document.getElementById('selected-batches-list');
        
        if (!this.selectedBatches || this.selectedBatches.size === 0) {
            selectedBatchesContainer.style.display = 'none';
            // Clear input values when no batches selected
            const plantCountInput = document.getElementById('harvest-plant-count');
            const weightInput = document.getElementById('harvest-weight');
            const qualityInput = document.getElementById('harvest-quality');
            if (plantCountInput) plantCountInput.value = '';
            if (weightInput) weightInput.value = '';
            if (qualityInput) qualityInput.value = 'excellent';
            return;
        }
        
        let selectedHtml = '';
        this.selectedBatches.forEach(batchId => {
            const batchInfo = this.getBatchDisplayInfo(batchId);
            selectedHtml += `
                <div class="selected-batch-tag">
                    <span>${batchInfo}</span>
                    <span class="remove-batch" data-batch-id="${batchId}" onclick="app.removeBatchSelection('${batchId}')">√ó</span>
                </div>
            `;
        });
        
        selectedBatchesList.innerHTML = selectedHtml;
        selectedBatchesContainer.style.display = 'block';
    }

    getBatchDisplayInfo(batchId) {
        const batchItem = document.querySelector(`.batch-summary-item[data-batch-id="${batchId}"]`);
        if (batchItem) {
            const batchIdSpan = batchItem.querySelector('.batch-id');
            const batchPlantsSpan = batchItem.querySelector('.batch-plants');
            return `${batchIdSpan?.textContent || batchId} - ${batchPlantsSpan?.textContent || ''}`;
        }
        return batchId;
    }

    removeBatchSelection(batchId) {
        const checkbox = document.querySelector(`.batch-checkbox[data-batch-id="${batchId}"]`);
        if (checkbox) {
            checkbox.checked = false;
            this.toggleBatchSelection(batchId, false);
        }
    }

    getSelectedBatches() {
        return this.selectedBatches ? Array.from(this.selectedBatches) : [];
    }

    clearBatchSelections() {
        if (this.selectedBatches) {
            this.selectedBatches.clear();
        }
        
        // Uncheck all checkboxes
        const checkboxes = document.querySelectorAll('.batch-checkbox:checked');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
            const batchItem = document.querySelector(`.batch-summary-item[data-batch-id="${checkbox.dataset.batchId}"]`);
            if (batchItem) {
                batchItem.classList.remove('selected');
            }
        });
        
        this.updateSelectedBatchesDisplay();
    }

    preselectBatchInCheckboxes(batchId) {
        try {
            // Find the checkbox for the specific batch
            const checkbox = document.querySelector(`.batch-checkbox[data-batch-id="${batchId}"]`);
            if (checkbox) {
                checkbox.checked = true;
                this.toggleBatchSelection(batchId, true);

            } else {
                console.warn('‚ö†Ô∏è Could not find checkbox for batch:', batchId);
                // The batch might not have loaded yet, try again in a moment
                setTimeout(() => {
                    const retryCheckbox = document.querySelector(`.batch-checkbox[data-batch-id="${batchId}"]`);
                    if (retryCheckbox) {
                        retryCheckbox.checked = true;
                        this.toggleBatchSelection(batchId, true);

                    } else {
                        console.error('‚ùå Failed to find batch checkbox even on retry:', batchId);
                        // Debug: List all available batch checkboxes
                        const allCheckboxes = document.querySelectorAll('.batch-checkbox');
                    }
                }, 500);
            }
        } catch (error) {
            console.error('Error pre-selecting batch:', error);
        }
    }

    async editBatchGrowBed(batchId, currentBedId) {
        try {
            // Get all grow beds for this system
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            
            // Find current bed info - handle both number and string IDs
            const currentBed = growBeds.find(bed => bed.id == currentBedId || bed.bed_number == currentBedId);
            const currentBedDisplay = currentBed ? `Bed ${currentBed.bed_number} - ${currentBed.bed_name} (${currentBed.bed_type.toUpperCase()})` : 'Unknown/Invalid Bed (needs reassignment)';
            
            // Create dropdown options for grow beds (if current bed is unknown, show all beds)
            let bedOptionsHtml = '';
            growBeds.forEach(bed => {
                // If current bed is unknown (not found), show all beds
                // If current bed is known, exclude it from options
                if (!currentBed || bed.id !== currentBedId) {
                    bedOptionsHtml += `<option value="${bed.id}">Bed ${bed.bed_number} - ${bed.bed_name} (${bed.bed_type.toUpperCase()})</option>`;
                }
            });
            
            if (bedOptionsHtml === '') {
                this.showNotification('No other grow beds available to move batch to', 'warning');
                return;
            }
            
            // Create modal for bed selection
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content batch-move-modal">
                    <div class="modal-header">
                        <h4>Move Batch</h4>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="batch-move-info">
                            <div class="batch-detail">
                                <span class="label">Batch ID:</span>
                                <span class="batch-id-display">${batchId}</span>
                            </div>
                            <div class="batch-detail">
                                <span class="label">Current Location:</span>
                                <span class="current-bed ${!currentBed ? 'unknown-bed' : ''}">${currentBedDisplay}</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="new-bed-select">Move to:</label>
                            <select id="new-bed-select" class="form-control">
                                <option value="">Choose destination bed...</option>
                                ${bedOptionsHtml}
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="window.app.confirmBatchMove('${batchId}', ${currentBedId})">Move Batch</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Show the modal
            modal.classList.add('show');
            
        } catch (error) {
            console.error('Error opening batch edit modal:', error);
            this.showNotification('Failed to load grow beds for batch move', 'error');
        }
    }

    async confirmBatchMove(batchId, currentBedId) {
        const newBedSelect = document.getElementById('new-bed-select');
        const newBedId = newBedSelect.value;
        
        if (!newBedId) {
            this.showNotification('Please select a destination grow bed', 'warning');
            return;
        }
        
        try {
            // Use the new efficient endpoint to update all batch records at once

            await this.makeApiCall(`/data/batch/${this.activeSystemId}/${batchId}/grow-bed`, {
                method: 'PUT',
                body: JSON.stringify({
                    newGrowBedId: newBedId
                })
            });
            
            // Close modal
            const modal = document.querySelector('.modal .batch-move-modal');
            if (modal) {
                modal.closest('.modal').remove();
            }
            
            // Comprehensive data refresh to show updated batch data across all views
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            // Update other plant management components (not overview to avoid double-render)
            this.updateGrowBeds();
            this.updatePlantGrowthHistoryDisplay();
            this.updatePlantRecommendations();
            this.updateRecentPlantEntries();
            await this.updatePlantOverview(); // Force update plant overview to refresh batch data
            this.updateRemainingPlantsDisplay(); // Update remaining plants display
            
            this.showNotification(`Batch ${batchId} moved successfully`, 'success');
            
        } catch (error) {
            console.error('Error moving batch:', error);
            this.showNotification('Failed to move batch', 'error');
            
            // Close modal even on error
            const modal = document.querySelector('.modal .batch-move-modal');
            if (modal) {
                modal.closest('.modal').remove();
            }
        }
    }

    setupFishManagementTabs() {
        console.log('üîß Setting up Fish Management tabs...');
        const fishTabs = document.querySelectorAll('.fish-mgmt-tab');
        const fishContents = document.querySelectorAll('.fish-mgmt-content');

        fishTabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.id.replace('-tab', '-content');
                console.log('üìû Fish Management tab clicked:', targetContent);

                fishTabs.forEach(t => t.classList.remove('active'));
                fishContents.forEach(c => {
                    c.classList.remove('active');
                    c.style.display = '';
                });
                
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);

                if (targetElement) {
                    targetElement.classList.add('active');
                    targetElement.style.display = 'block';
                }
                
                // Scroll to top when switching fish management tabs
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // Load data for specific tabs
                if (targetContent === 'fish-overview-content') {
                    console.log('üì° Loading loadFishOverview...');
                    await this.loadFishOverview();
                } else if (targetContent === 'fish-health-entry-content') {
                    console.log('üì° Loading loadFishHealthEntry...');
                    this.loadFishHealthEntry();
                } else if (targetContent === 'tank-information-content') {
                    console.log('üì° Loading loadTankInformation...');
                    this.loadTankInformation();
                } else if (targetContent === 'fish-health-monitoring-content') {
                    console.log('üì° Loading loadFishHealthMonitoring...');
                    this.loadFishHealthMonitoring();
                }
            });
        });

        // Auto-load the fish overview tab when fish management is first accessed
        setTimeout(async () => {
            const overviewTab = document.getElementById('fish-overview-tab');
            const overviewContent = document.getElementById('fish-overview-content');
            
            if (overviewTab && overviewContent) {
                console.log('üöÄ Auto-loading fish overview tab...');
                
                // Always reset and ensure proper activation
                fishTabs.forEach(t => t.classList.remove('active'));
                fishContents.forEach(c => {
                    c.classList.remove('active');
                    c.style.display = '';
                });
                
                overviewTab.classList.add('active');
                overviewContent.classList.add('active');
                overviewContent.style.display = 'block';
                
                // Allow DOM updates and then load data
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.loadFishOverview();
            }
        }, 600);
    }

    setupSettingsTabs() {
        // Setup main settings tabs
        const settingsTabs = document.querySelectorAll('.settings-tab');
        const settingsContents = document.querySelectorAll('.settings-content');
        
        settingsTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetContent = tab.getAttribute('data-target');
                
                settingsTabs.forEach(t => t.classList.remove('active'));
                settingsContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const contentElement = document.getElementById(targetContent);
                if (contentElement) {
                    contentElement.classList.add('active');
                }
                
                // Scroll to top when switching settings tabs
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // Load specific content based on tab
                if (contentElement) {
                    if (targetContent === 'grow-beds-content') {
                        this.displayGrowBedStatus();
                    } else if (targetContent === 'system-sharing-content') {
                        this.loadSystemSharing();
                    } else if (targetContent === 'sensor-config-content') {
                        this.loadSensorConfiguration();
                    } else if (targetContent === 'credentials-content') {
                        this.loadCredentialsStatus();
                    } else if (targetContent === 'admin-settings-content') {
                        this.loadAdminUsers(); // Default to user management
                    }
                }
            });
        });
        
        // Setup system config sub-tabs
        const systemConfigSubTabs = document.querySelectorAll('.system-config-tab');
        const systemConfigContents = document.querySelectorAll('.system-config-content');
        
        systemConfigSubTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetContent = tab.getAttribute('data-target');
                
                systemConfigSubTabs.forEach(t => t.classList.remove('active'));
                systemConfigContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const contentElement = document.getElementById(targetContent);
                if (contentElement) {
                    contentElement.classList.add('active');
                    
                    // Load specific content based on sub-tab
                    if (targetContent === 'overall-system-content') {
                        console.log('üìû Loading overall system configuration...');
                        this.loadSystemConfiguration(); // Load overall system configuration
                    } else if (targetContent === 'fish-tanks-config-content') {
                        console.log('üìû Loading fish tanks configuration...');
                        this.loadFishTankConfiguration(); // Load fish tank configuration
                    } else if (targetContent === 'grow-beds-config-content') {
                        console.log('üìû Loading grow beds configuration...');
                        this.displayGrowBedStatus(); // Load grow bed status when opening that sub-tab
                        this.loadGrowBedConfiguration(); // Load grow bed configuration form
                    }
                }
            });
        });
        
        // Setup admin sub-tabs
        const adminSubTabs = document.querySelectorAll('.admin-subtab');
        const adminSubContents = document.querySelectorAll('.admin-subcontent');
        
        adminSubTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetContent = tab.getAttribute('data-target');
                
                adminSubTabs.forEach(t => t.classList.remove('active'));
                adminSubContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const contentElement = document.getElementById(targetContent);
                if (contentElement) {
                    contentElement.classList.add('active');
                    
                    // Load specific content based on sub-tab
                    console.log('üîç Admin sub-tab clicked:', targetContent);
                    if (targetContent === 'admin-users-subcontent') {
                        console.log('üìû Calling loadAdminUsers()');
                        this.loadAdminUsers();
                    } else if (targetContent === 'admin-smtp-subcontent') {
                        console.log('üìû Calling loadSmtpConfig()');
                        this.loadSmtpConfig();
                    } else if (targetContent === 'admin-data-subcontent') {
                        console.log('üìû Calling loadDataEditInterface()');
                        this.loadDataEditInterface();
                    } else if (targetContent === 'admin-crops-subcontent') {
                        console.log('üìû Calling loadAdminCrops()');
                        this.loadAdminCrops();
                    } else if (targetContent === 'admin-ratios-subcontent') {
                        console.log('üìû Checking nutrientRatioManager:', !!this.nutrientRatioManager);
                        if (this.nutrientRatioManager) {
                            console.log('üìû Calling nutrientRatioManager.loadRatioManagement()');
                            this.nutrientRatioManager.loadRatioManagement();
                        } else {
                            console.error('‚ùå nutrientRatioManager not found!');
                        }
                    } else if (targetContent === 'admin-deficiency-subcontent') {
                        console.log('üìû Calling loadAllDeficiencyImages()');
                        this.loadAllDeficiencyImages();
                    } else if (targetContent === 'admin-stats-subcontent') {
                        console.log('üìû Calling loadAdminStats()');
                        this.loadAdminStats();
                    }
                }
            });
        });
    }

    // ========================================
    // SENSOR CONFIGURATION TAB HANDLERS
    // ========================================
    setupSensorTabs() {
        console.log('üîß Setting up Sensor Configuration tabs...');
        const tabs = document.querySelectorAll('.sensor-tab');
        const contents = document.querySelectorAll('.sensor-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Sensor Configuration tab clicked:', targetContent);

                // Remove active states
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active states
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                }

                // Load data for specific tabs
                if (targetContent === 'add-sensor-content') {
                    console.log('üì° Loading loadSensorConfiguration...');
                    await this.loadSensorConfiguration();
                } else if (targetContent === 'existing-sensors-content') {
                    console.log('üì° Loading loadSensorsList...');
                    await this.loadSensorsList();
                }
            });
        });
    }

    // ========================================
    // NUTRIENT MANAGEMENT TAB HANDLERS
    // ========================================
    setupNutrientManagementTabs() {
        console.log('üîß Setting up Nutrient Management tabs...');
        const tabs = document.querySelectorAll('.nutrient-mgmt-tab');
        const contents = document.querySelectorAll('.nutrient-mgmt-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Nutrient Management tab clicked:', targetContent);

                // Remove active states
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active states
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                }

                // Load data for specific tabs
                if (targetContent === 'ratio-rules-content') {
                    console.log('üì° Loading loadRatioRules...');
                    await this.loadRatioRules();
                } else if (targetContent === 'environmental-adjustments-content') {
                    console.log('üì° Loading loadEnvironmentalAdjustments...');
                    await this.loadEnvironmentalAdjustments();
                }
            });
        });
    }

    setupEventListeners() {
        const checkboxes = document.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => this.updateSettings());
        });

        // Setup modal close handlers
        this.setupNutrientModalHandlers();
        
        // Setup Quick Actions event delegation for Plant tab beds
        this.setupQuickActionsEventDelegation();
    }
    
    setupQuickActionsEventDelegation() {
        // Use event delegation on document body for dynamically created quick action buttons
        // Store reference to 'this' for use in event handler
        const app = this;
        
        document.addEventListener('click', async (event) => {
            // Enhanced debugging for all clicks
            if (event.target.closest('.quick-action-item')) {
            }
            
            // Handle quick plant button clicks
            if (event.target.closest('.quick-plant-btn')) {
                const btn = event.target.closest('.quick-plant-btn');
                const bedId = parseInt(btn.getAttribute('data-bed-id'));
                const bedName = btn.getAttribute('data-bed-name');
                app.openQuickPlantDialog(bedId, bedName);
            }
            
            // Handle quick harvest button clicks
            if (event.target.closest('.quick-harvest-btn')) {
                const btn = event.target.closest('.quick-harvest-btn');
                const bedId = parseInt(btn.getAttribute('data-bed-id'));
                const bedName = btn.getAttribute('data-bed-name');
                
                try {
                    
                    const result = app.openQuickHarvestDialog(bedId, bedName);
                    
                    if (result && typeof result.then === 'function') {
                        await result;
                    }
                } catch (error) {
                    console.error('‚ùå Error calling openQuickHarvestDialog:', error);
                    console.error('‚ùå Error stack:', error.stack);
                }
            }
            
            // Handle quick move batch button clicks
            if (event.target.closest('.quick-move-btn')) {
                const btn = event.target.closest('.quick-move-btn');
                const bedId = parseInt(btn.getAttribute('data-bed-id'));
                const bedName = btn.getAttribute('data-bed-name');
                app.openQuickMoveDialog(bedId, bedName);
            }
            
            // Handle quick details button clicks
            if (event.target.closest('.quick-details-btn')) {
                const btn = event.target.closest('.quick-details-btn');
                const bedId = parseInt(btn.getAttribute('data-bed-id'));
                app.showBedDetails(bedId);
                app.hideBedQuickActions(bedId);
            }
        });
    }

    setupNutrientModalHandlers() {
        const modal = document.getElementById('nutrient-detail-modal');
        const closeBtn = document.getElementById('close-nutrient-modal');
        const closeBtnSecondary = document.getElementById('close-nutrient-modal-btn');
        
        if (!modal) {
            if (window.errorManager) {
                window.errorManager.warnOnce('nutrient_modal_missing', 'Nutrient detail modal not found', 'ui');
            } else {
                console.warn('Nutrient detail modal not found');
            }
            return;
        }
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
                modal.classList.remove('show');
            });
        }

        if (closeBtnSecondary) {
            closeBtnSecondary.addEventListener('click', () => {
                modal.style.display = 'none';
                modal.classList.remove('show');
            });
        }

        // Close modal when clicking outside of it
        if (modal) {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    modal.classList.remove('show');
                }
            });
        }

        // Close modal with escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal && modal.classList.contains('show')) {
                modal.style.display = 'none';
                modal.classList.remove('show');
            }
        });

        // Export chart data button
        const exportBtn = document.getElementById('export-chart-data');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.exportNutrientData();
            });
        }
    }

    async updateDashboardFromData() {
        return this.dashboardManager.updateDashboardFromData();
    }

    updateSystemHealthBadges(displayData) {
        // Update individual parameter badges
        const phElement = document.getElementById('ph-status');
        if (phElement) {
            if (displayData.ph !== null && displayData.ph !== undefined) {
                const phStatus = this.evaluatePH(displayData.ph);
                phElement.textContent = `pH: ${displayData.ph}`;
                phElement.className = `badge ${phStatus.class}`;
            } else {
                phElement.textContent = 'pH: No data';
                phElement.className = 'badge badge-secondary';
            }
        }

        const tempElement = document.getElementById('temperature-status');
        if (tempElement) {
            if (displayData.temperature !== null && displayData.temperature !== undefined) {
                const tempStatus = this.evaluateTemperature(displayData.temperature);
                tempElement.textContent = `Temp: ${displayData.temperature}¬∞C`;
                tempElement.className = `badge ${tempStatus.class}`;
            } else {
                tempElement.textContent = 'Temp: No data';
                tempElement.className = 'badge badge-secondary';
            }
        }

        const oxygenElement = document.getElementById('oxygen-status');
        if (oxygenElement) {
            if (displayData.dissolved_oxygen !== null && displayData.dissolved_oxygen !== undefined) {
                const o2Status = this.evaluateDissolvedOxygen(displayData.dissolved_oxygen);
                oxygenElement.textContent = `O‚ÇÇ: ${displayData.dissolved_oxygen}mg/L`;
                oxygenElement.className = `badge ${o2Status.class}`;
            } else {
                oxygenElement.textContent = 'O‚ÇÇ: No data';
                oxygenElement.className = 'badge badge-secondary';
            }
        }

        // Update overall water status
        const overallElement = document.getElementById('overall-water-status');
        if (overallElement) {
            const overallStatus = this.evaluateOverallWaterHealth(displayData);
            overallElement.textContent = overallStatus.text;
            overallElement.className = `water-quality ${overallStatus.class}`;
        }
    }

    evaluatePH(ph) {
        if (ph >= 6.0 && ph <= 8.0) {
            return { class: 'badge-success', status: 'good' };
        } else if (ph >= 5.5 && ph <= 8.5) {
            return { class: 'badge-warning', status: 'caution' };
        } else {
            return { class: 'badge-danger', status: 'poor' };
        }
    }

    evaluateTemperature(temp) {
        if (temp >= 18 && temp <= 28) {
            return { class: 'badge-success', status: 'good' };
        } else if (temp >= 15 && temp <= 32) {
            return { class: 'badge-warning', status: 'caution' };
        } else {
            return { class: 'badge-danger', status: 'poor' };
        }
    }

    evaluateDissolvedOxygen(do_level) {
        if (do_level >= 5.0) {
            return { class: 'badge-success', status: 'good' };
        } else if (do_level >= 3.0) {
            return { class: 'badge-warning', status: 'caution' };
        } else {
            return { class: 'badge-danger', status: 'poor' };
        }
    }

    evaluateOverallWaterHealth(displayData) {
        const issues = [];
        let goodCount = 0;
        let totalCount = 0;

        // Check pH
        if (displayData.ph !== null && displayData.ph !== undefined) {
            totalCount++;
            const phStatus = this.evaluatePH(displayData.ph);
            if (phStatus.status === 'good') goodCount++;
            else if (phStatus.status === 'poor') issues.push('pH');
        }

        // Check temperature
        if (displayData.temperature !== null && displayData.temperature !== undefined) {
            totalCount++;
            const tempStatus = this.evaluateTemperature(displayData.temperature);
            if (tempStatus.status === 'good') goodCount++;
            else if (tempStatus.status === 'poor') issues.push('temperature');
        }

        // Check dissolved oxygen
        if (displayData.dissolved_oxygen !== null && displayData.dissolved_oxygen !== undefined) {
            totalCount++;
            const o2Status = this.evaluateDissolvedOxygen(displayData.dissolved_oxygen);
            if (o2Status.status === 'good') goodCount++;
            else if (o2Status.status === 'poor') issues.push('dissolved oxygen');
        }

        // Determine overall status
        if (totalCount === 0) {
            return { text: 'No data available', class: 'water-poor' };
        } else if (issues.length === 0) {
            return { text: 'Excellent', class: 'water-excellent' };
        } else if (goodCount / totalCount >= 0.7) {
            return { text: 'Good', class: 'water-good' };
        } else if (goodCount / totalCount >= 0.4) {
            return { text: 'Fair', class: 'water-fair' };
        } else {
            return { text: 'Poor', class: 'water-poor' };
        }
    }

    getLatestWaterQualityData() {
        if (this.dataRecords.waterQuality.length === 0) {
            return null;
        }
        
        // Return an object with the most recent non-null value for each parameter
        const result = {
            temperature: null,
            ph: null,
            dissolved_oxygen: null,
            ammonia: null,
            humidity: null,
            salinity: null,
            ec: null,
            date: null,
            notes: null
        };
        
        // Find the most recent non-null value for each parameter
        for (const entry of this.dataRecords.waterQuality) {
            if (result.temperature === null && entry.temperature !== null && entry.temperature !== undefined) {
                result.temperature = entry.temperature;
            }
            if (result.ph === null && entry.ph !== null && entry.ph !== undefined) {
                result.ph = entry.ph;
            }
            if (result.dissolved_oxygen === null && entry.dissolved_oxygen !== null && entry.dissolved_oxygen !== undefined) {
                result.dissolved_oxygen = entry.dissolved_oxygen;
            }
            if (result.ammonia === null && entry.ammonia !== null && entry.ammonia !== undefined) {
                result.ammonia = entry.ammonia;
            }
            if (result.humidity === null && entry.humidity !== null && entry.humidity !== undefined) {
                result.humidity = entry.humidity;
            }
            if (result.salinity === null && entry.salinity !== null && entry.salinity !== undefined) {
                result.salinity = entry.salinity;
            }
            if (result.ec === null && entry.ec !== null && entry.ec !== undefined) {
                result.ec = entry.ec;
            }
            if (result.date === null) {
                result.date = entry.date;
            }
            if (result.notes === null && entry.notes) {
                result.notes = entry.notes;
            }
            
            // Stop early if we found all values
            const allFound = Object.keys(result).every(key => 
                key === 'notes' || result[key] !== null
            );
            if (allFound) break;
        }
        
        return result;
    }

    async getLatestSensorData() {
        if (!this.activeSystemId) return {};
        
        try {
            // Get all sensors for the system
            const sensorsResponse = await this.makeApiCall(`/sensors/system/${this.activeSystemId}`);
            const sensors = sensorsResponse.sensors || [];
            
            const sensorData = {};
            
            // For each sensor, get the latest reading from sensor_readings table
            for (const sensor of sensors) {
                try {
                    // Check if sensor has mapping to water quality fields
                    if (sensor.mapped_table === 'water_quality' && sensor.mapped_field) {
                        // Get latest water quality data to see if sensor data is there
                        const latestWQ = this.getLatestWaterQualityData();
                        if (latestWQ && latestWQ[sensor.mapped_field]) {
                            sensorData[sensor.mapped_field] = latestWQ[sensor.mapped_field];
                        }
                    }
                } catch (error) {
                    console.error(`Error getting data for sensor ${sensor.sensor_name}:`, error);
                }
            }
            
            return sensorData;
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('sensor_data_fetch_failed', 'Error fetching sensor data', this.activeSystemId);
            } else {
                console.error('Error fetching sensor data:', error);
            }
            return {};
        }
    }

    // Helper function to convert emoji source indicators to icon HTML
    getDataSourceIcon(sourceType) {
        const iconMap = {
            'üì°': '<img src="/icons/new-icons/Afraponix Go Icons_sensor data.svg" alt="Sensor" class="source-icon" style="width: 12px; height: 12px;">',
            'üìù': '<img src="/icons/new-icons/Afraponix Go Icons_Data entry.svg" alt="Manual" class="source-icon" style="width: 12px; height: 12px;">',
            'üß™': '<img src="/icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Lab" class="source-icon" style="width: 12px; height: 12px;">'
        };
        return iconMap[sourceType] || sourceType;
    }

    formatSensorValue(value, unit, sourceIcon = '') {
        if (value === null || value === undefined || value === '' || isNaN(parseFloat(value))) {
            return 'No data';
        }
        
        const numValue = parseFloat(value);
        const formattedValue = unit === 'ppm' ? numValue.toFixed(2) : numValue.toFixed(1);
        const unitText = unit ? ` ${unit}` : '';
        const sourceIconHtml = sourceIcon ? this.getDataSourceIcon(sourceIcon) : '';
        const titleMap = { 'üì°': 'Sensor data', 'üìù': 'Manual entry', 'üß™': 'Lab test' };
        const sourceIndicator = sourceIcon ? `<span style="opacity: 0.7; margin-left: 4px;" title="${titleMap[sourceIcon] || 'Data source'}">${sourceIconHtml}</span>` : '';
        
        return `${formattedValue}${unitText}${sourceIndicator}`;
    }

    async updateLiveSensorData() {
        const container = document.getElementById('sensor-data-container');
        if (!container || !this.activeSystemId) return;
        
        try {
            // Get all sensors for the system
            const sensorsResponse = await this.makeApiCall(`/sensors/system/${this.activeSystemId}`);
            const sensors = sensorsResponse.sensors || [];
            
            if (sensors.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 2rem; border: 2px dashed #ddd; border-radius: 8px; margin: 1rem 0;">
                        <p><strong>No sensors configured yet</strong></p>
                        <p>Add sensors in <strong>Settings ‚Üí Sensor Config</strong> to see live data here.</p>
                    </div>
                `;
                return;
            }
            
            // Build sensor cards HTML
            let sensorsHtml = '';
            for (const sensor of sensors) {
                const isActive = sensor.active;
                const isOnline = this.isSensorOnline(sensor.last_reading, sensor.update_interval, sensor.sensor_name);
                
                // Determine status icon based on both active and online status
                let statusIcon = '‚ö´'; // Default: manual data
                let statusText = 'Manual Data';
                if (isActive && isOnline) {
                    statusIcon = 'üü¢';
                    statusText = 'Sensor Data (Online)';
                } else if (isActive && !isOnline) {
                    statusIcon = 'üî¥';
                    statusText = 'Sensor Data (Offline)';
                } else {
                    statusIcon = '‚ö´';
                    statusText = 'Manual Data';
                }
                
                const lastUpdate = sensor.last_reading ? new Date(sensor.last_reading).toLocaleString() : 'Never';

                // Get latest value from water quality data if mapped
                let currentValue = 'No data';
                if (sensor.mapped_table === 'water_quality' && sensor.mapped_field) {
                    const latestWQ = this.getLatestWaterQualityData();
                    if (latestWQ && latestWQ[sensor.mapped_field]) {
                        const value = parseFloat(latestWQ[sensor.mapped_field]);
                        const unit = this.getSensorUnit(sensor.sensor_type, sensor.mapped_field);
                        currentValue = isNaN(value) ? 'No data' : `${value.toFixed(1)} ${unit}`;
                    }
                }
                
                // Check if sensor is properly mapped (not null, undefined, or empty string)
                const isMapped = sensor.mapped_field && sensor.mapped_field.trim() !== '';
                
                sensorsHtml += `
                    <div class="sensor-card ${!isOnline ? 'sensor-offline' : ''}">
                        <div class="sensor-header">
                            <h4>${statusIcon} ${sensor.sensor_name}</h4>
                            <span class="sensor-type">${sensor.sensor_type}</span>
                        </div>
                        <div class="sensor-value">${currentValue}</div>
                        <div class="sensor-details">
                            <small>Status: <strong>${statusText}</strong></small>
                            <small>Last update: ${lastUpdate}</small>
                            ${isMapped ? `<small>Maps to: ${sensor.mapped_field.replace('_', ' ')}</small>` : '<small>Not mapped to database</small>'}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = sensorsHtml;
            
        } catch (error) {
            console.error('Error loading sensor data:', error);
            container.innerHTML = `
                <div style="text-align: center; color: #dc3545; padding: 2rem; border: 1px solid #dc3545; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>Error loading sensor data</strong></p>
                    <p>Please check your sensor configuration and try again.</p>
                </div>
            `;
        }
    }

    isSensorOnline(lastReading, updateInterval = 300, sensorName = 'Unknown') {
        if (!lastReading) {
            return false;
        }
        
        const lastReadingTime = new Date(lastReading).getTime();
        
        // Check if date parsing failed
        if (isNaN(lastReadingTime)) {
            console.warn('‚ö†Ô∏è  Invalid sensor date format:', lastReading);
            return false;
        }
        
        const currentTime = Date.now();
        const timeDiff = currentTime - lastReadingTime;
        
        // Consider sensor offline if no data for more than 3 hours or 3 times the update interval, whichever is larger
        const offlineThreshold = Math.max(updateInterval * 3 * 1000, 10800000); // Min 3 hours
        
        const isOnline = timeDiff < offlineThreshold;
        
        // Debug logging removed - issue identified as IoT device connectivity
        
        return isOnline;
    }
    
    getSensorUnit(sensorType, mappedField) {
        const unitMappings = {
            'temperature': '¬∞C',
            'ph': '',
            'dissolved_oxygen': 'mg/L',
            'ec': 'mS/cm', 
            'ammonia': 'ppm',
            'nitrite': 'ppm',
            'nitrate': 'ppm'
        };
        
        return unitMappings[mappedField] || unitMappings[sensorType] || '';
    }

    updateRecentWaterQualityEntry() {
        const container = document.getElementById('recent-water-quality-entry');
        if (!container) return;

        const latestData = this.getLatestWaterQualityData();
        
        if (!latestData) {
            container.innerHTML = `
                <div class="no-data-message">
                    <p>No water quality data available. Add your first entry in the Data Entry tab.</p>
                </div>
            `;
            return;
        }

        const entryDate = new Date(latestData.date);
        const formattedDate = this.formatDateDDMMYYYY(entryDate) + ' ' + entryDate.toLocaleTimeString();
        
        // Check if this is the chronologically most recent entry
        const chronologicallyLatest = this.dataRecords.waterQuality[0];
        const isLatestEntry = latestData.id === chronologicallyLatest.id;
        const statusText = isLatestEntry ? 'Latest Entry' : 'Most Recent Entry with Data';

        container.innerHTML = `
            <div class="water-quality-entry">
                <div class="entry-header">
                    <div class="entry-title">
                        <h4>Water Quality - ${formattedDate}</h4>
                        <span class="status-badge ${isLatestEntry ? 'latest' : 'recent-data'}">${statusText}</span>
                    </div>
                    <div class="entry-actions">
                        <button class="edit-btn" onclick="app.editWaterQualityEntry(${latestData.id})">${SVGIcons.getIcon('edit', 'btn-icon-svg')}Edit</button>
                        <button class="delete-btn" onclick="app.deleteWaterQualityEntry(${latestData.id})">${SVGIcons.getIcon('delete', 'btn-icon-svg')}Delete</button>
                    </div>
                </div>
                <div class="entry-data">
                    <div class="data-grid">
                        <div class="data-item">
                            <span class="data-label">Temperature:</span>
                            <span class="data-value">${(latestData.temperature && !isNaN(parseFloat(latestData.temperature))) ? parseFloat(latestData.temperature).toFixed(1) + '¬∞C' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">pH Level:</span>
                            <span class="data-value">${(latestData.ph && !isNaN(parseFloat(latestData.ph))) ? parseFloat(latestData.ph).toFixed(1) : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Dissolved Oxygen:</span>
                            <span class="data-value">${(latestData.dissolved_oxygen && !isNaN(parseFloat(latestData.dissolved_oxygen))) ? parseFloat(latestData.dissolved_oxygen).toFixed(1) + ' mg/L' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Ammonia:</span>
                            <span class="data-value">${(latestData.ammonia && !isNaN(parseFloat(latestData.ammonia))) ? parseFloat(latestData.ammonia).toFixed(2) + ' ppm' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Nitrite:</span>
                            <span class="data-value">${(latestData.nitrite && !isNaN(parseFloat(latestData.nitrite))) ? parseFloat(latestData.nitrite).toFixed(2) + ' ppm' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Nitrate:</span>
                            <span class="data-value">${(latestData.nitrate && !isNaN(parseFloat(latestData.nitrate))) ? parseFloat(latestData.nitrate).toFixed(1) + ' ppm' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">EC:</span>
                            <span class="data-value">${(latestData.ec && !isNaN(parseFloat(latestData.ec))) ? parseFloat(latestData.ec).toFixed(0) + ' ¬µS/cm' : 'Not recorded'}</span>
                        </div>
                        ${latestData.notes ? `
                        <div class="data-item notes">
                            <span class="data-label">Notes:</span>
                            <span class="data-value">${latestData.notes}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    async editWaterQualityEntry(entryId) {
        // Switch to settings view, admin tab, and data edit sub-tab
        this.currentView = 'settings';
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
        const settingsElement = document.getElementById('settings');
        const settingsView = document.querySelector('[data-view="settings"]');
        
        if (settingsElement) {
            settingsElement.classList.add('active');
        } else if (window.errorManager) {
            window.errorManager.warnOnce('settings_element_missing', 'Settings element not found', 'navigation');
        }
        
        if (settingsView) {
            settingsView.classList.add('active');
        } else if (window.errorManager) {
            window.errorManager.warnOnce('settings_view_missing', 'Settings view not found', 'navigation');
        }
        
        // Switch to admin settings tab
        document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.settings-content').forEach(c => c.classList.remove('active'));
        const adminTab = document.getElementById('admin-settings-tab');
        const adminContent = document.getElementById('admin-settings-content');
        if (adminTab) adminTab.classList.add('active');
        if (adminContent) adminContent.classList.add('active');
        
        // Switch to data edit sub-tab
        document.querySelectorAll('.admin-subtab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.admin-subcontent').forEach(c => c.classList.remove('active'));
        const adminDataTab = document.getElementById('admin-data-subtab');
        const adminDataContent = document.getElementById('admin-data-subcontent');
        if (adminDataTab) adminDataTab.classList.add('active');
        if (adminDataContent) adminDataContent.classList.add('active');

        // Wait a bit for the view to switch, then activate data edit tab
        setTimeout(() => {
            const dataEditTab = document.querySelector('[data-category="water-quality"]');
            if (dataEditTab) {
                // Activate water quality edit tab
                document.querySelectorAll('.edit-tab').forEach(t => t.classList.remove('active'));
                dataEditTab.classList.add('active');
                
                // Load the data edit interface
                this.loadDataEditInterface('water-quality');
                
                // Find and populate the specific entry for editing
                setTimeout(() => {
                    const editRows = document.querySelectorAll('.edit-row');
                    editRows.forEach(row => {
                        const editButton = row.querySelector('.edit-entry-btn');
                        if (editButton && editButton.onclick.toString().includes(entryId)) {
                            editButton.click();
                        }
                    });
                }, 500);
            }
        }, 200);
        
        this.showNotification('Switched to Data Edit tab for water quality entry editing', 'info');
    }

    async deleteWaterQualityEntry(entryId) {
        if (!confirm('Are you sure you want to delete this water quality entry? This action cannot be undone.')) {
            return;
        }

        try {
            await this.makeApiCall(`/data/water-quality/${entryId}`, {
                method: 'DELETE'
            });
            
            // Reload data and update dashboard
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            
            this.showNotification('Water quality entry deleted successfully!', 'success');
        } catch (error) {
            console.error('Failed to delete water quality entry:', error);
            this.showNotification('‚ùå Failed to delete water quality entry. Please try again.', 'error');
        }
    }

    destroyAllCharts() {
        console.trace('destroyAllCharts call stack');
        // Destroy all existing charts before creating new ones
        Object.keys(this.chartInstances).forEach(canvasId => {
            if (this.chartInstances[canvasId]) {
                this.chartInstances[canvasId].destroy();
                delete this.chartInstances[canvasId];
            }
        });
    }

    async initializeCharts() {
        console.log('üîÑ initializeCharts called, charts component available:', !!this.charts);
        if (!this.charts) {
            console.warn('Charts component not initialized');
            return;
        }
        
        console.log('üîÑ Calling charts.initializeCharts()...');
        const result = await this.charts.initializeCharts();
        console.log('üîÑ charts.initializeCharts() result:', result);
        
        // Set up click handlers for chart cards after charts are initialized
        this.setupChartClickHandlers();
        
        return result;
    }
    
    setupChartClickHandlers() {
        // Add click handlers to all chart cards
        const chartCards = document.querySelectorAll('.chart-card[data-metric]');
        
        chartCards.forEach(card => {
            // Remove any existing click listeners
            card.style.cursor = 'pointer';
            
            // Clone to remove old event listeners
            const newCard = card.cloneNode(true);
            card.parentNode.replaceChild(newCard, card);
            
            // Add new click listener
            newCard.addEventListener('click', (e) => {
                // Prevent triggering if clicking on input elements within the card
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
                    return;
                }
                
                const metric = newCard.getAttribute('data-metric');
                if (metric) {
                    console.log(`Chart card clicked: ${metric}`);
                    this.openDashboardChartModal(metric);
                }
            });
        });
        
        console.log(`‚úÖ Added click handlers to ${chartCards.length} chart cards`);
    }

    initChart(canvasId, label, color, dataField) {
        const ctx = document.getElementById(canvasId);
        if (!ctx) {
            if (window.errorManager) {
                window.errorManager.warnOnce(`canvas_missing_${canvasId}`, `Canvas element ${canvasId} not found`, this.activeSystemId);
            } else {
                console.warn(`Canvas element ${canvasId} not found`);
            }
            return;
        }
        
        // Destroy existing chart if it exists
        if (this.chartInstances[canvasId]) {
            this.chartInstances[canvasId].destroy();
            delete this.charts[canvasId];
        }
        
        try {
            this.chartInstances[canvasId] = new Chart(ctx.getContext('2d'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: label,
                    data: [],
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    spanGaps: true  // Connect all points since we filter out nulls
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: {
                        display: false
                    },
                    y: {
                        display: false,
                        beginAtZero: dataField === 'ammonia'
                    }
                },
                elements: {
                    point: {
                        radius: 0
                    }
                },
                onClick: (event, elements) => {

                    this.chartModal.openDetailModal(canvasId, label, [], [], color);
                }
            }
        });
        
        // Add cursor pointer and direct click handler as fallback
        ctx.style.cursor = 'pointer';
        ctx.addEventListener('click', (e) => {
            this.chartModal.openDetailModal(canvasId, label, [], [], color);
        });

        // Force resize after creation to ensure proper rendering
        setTimeout(() => {
            if (this.charts[canvasId]) {
                this.charts[canvasId].resize();
            }
        }, 100);

        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce(`chart_init_failed_${canvasId}`, `Error initializing chart ${canvasId}`, this.activeSystemId);
            } else {
                console.error(`Error initializing chart ${canvasId}:`, error);
            }
        }
    }

    // Open dashboard chart modal when clicking on chart cards
    openDashboardChartModal(dataField) {
        try {
            // Map data field to chart canvas ID
            const chartMapping = {
                'temperature': 'temp-chart',
                'ph': 'ph-chart',
                'dissolved_oxygen': 'oxygen-chart',
                'ammonia': 'ammonia-chart',
                'humidity': 'humidity-chart',
                'salinity': 'salinity-chart',
                'ec': 'ec-chart',
                'nitrate': 'nitrate-chart',
                'nitrite': 'nitrite-chart',
                'phosphorus': 'phosphorus-chart',
                'potassium': 'potassium-chart',
                'calcium': 'calcium-chart',
                'magnesium': 'magnesium-chart',
                'iron': 'iron-chart'
            };

            const canvasId = chartMapping[dataField];
            if (!canvasId) {
                console.warn(`Unknown data field for dashboard modal: ${dataField}`);
                return;
            }

            // Get the chart instance and data
            let chartInstance = null;
            
            // Try getting chart from new ChartsComponent first
            if (this.charts && this.charts.getChart) {
                chartInstance = this.charts.getChart(canvasId);
            }
            
            // Fallback to legacy chartInstances
            if (!chartInstance && this.chartInstances) {
                chartInstance = this.chartInstances[canvasId];
            }
            
            if (!chartInstance) {
                console.warn(`Chart instance not found for ${canvasId}`);
                return;
            }

            // Get chart data
            const labels = chartInstance.data.labels;
            const data = chartInstance.data.datasets[0].data;
            const label = chartInstance.data.datasets[0].label;
            const color = chartInstance.data.datasets[0].borderColor;

            // Open the modal using ChartModalComponent if available
            if (this.chartModal && typeof this.chartModal.openDetailModal === 'function') {
                this.chartModal.openDetailModal(canvasId, label, labels, data, color);
            } else {
                // Fallback to opening nutrient modal
                this.openNutrientModal(canvasId, label, labels, data, color);
            }
        } catch (error) {
            console.error('Error opening dashboard chart modal:', error);
        }
    }

    async updateCharts() {
        if (!this.charts) {
            console.warn('Charts component not initialized, skipping chart updates');
            return;
        }
        return this.charts.updateCharts();
    }

    updateChart(chartId, labels, data) {
        if (!this.charts) {
            console.warn('Charts component not initialized');
            return;
        }
        return this.charts.updateChart(chartId, labels, data);
    }

    async updateNutrientCharts() {
        try {
            // Early return if no charts component
            if (!this.charts) {
                console.warn('Charts component not initialized, skipping nutrient chart updates');
                return;
            }
            
            // Early return if no active system selected
            if (!this.activeSystemId || this.activeSystemId === 'undefined') {
                return;
            }
            
            // Get latest nutrient data for current values
            const nutrientData = await this.makeApiCall(`/data/nutrients/latest/${this.activeSystemId}`);
            
            // Get historical nutrient data for charts
            const historicalData = await this.makeApiCall(`/data/nutrients/${this.activeSystemId}?limit=30`);
            if (!historicalData || historicalData.length === 0) {
                // Only warn once per system to avoid console spam
                const warnKey = `nutrient_warn_${this.activeSystemId}`;
                if (!this._nutrientWarnings) this._nutrientWarnings = {};
                if (!this._nutrientWarnings[warnKey]) {
                    console.log(`‚ÑπÔ∏è No historical nutrient data available for system ${this.activeSystemId}`);
                    this._nutrientWarnings[warnKey] = true;
                }
                return;
            }
            
            // Function to get recent non-null data for a specific nutrient
            const getRecentNutrientData = (nutrientType) => {
                return historicalData
                    .filter(item => item.nutrient_type === nutrientType && item.value !== null && item.value !== undefined)
                    .slice(0, 10)
                    .reverse();
            };
            
            // Update each nutrient chart
            const nutrientTypes = ['ec', 'nitrate', 'nitrite', 'phosphorus', 'potassium', 'calcium', 'magnesium', 'iron'];
            
            for (const nutrientType of nutrientTypes) {
                const data = getRecentNutrientData(nutrientType);
                
                if (data.length > 0) {
                    const labels = data.map(item => {
                        const date = new Date(item.reading_date);
                        return date.getMonth() + 1 + '/' + date.getDate();
                    });
                    const values = data.map(item => parseFloat(item.value));
                    this.updateChart(`${nutrientType}-chart`, labels, values);
                    
                    // Update timestamp
                    const latestReading = data[data.length - 1];
                    const timestamp = new Date(latestReading.reading_date).toLocaleString();
                    this.updateChartTimestamp(`${nutrientType}-chart-timestamp`, timestamp);
                } else {
                    // No data available
                    this.updateChartTimestamp(`${nutrientType}-chart-timestamp`, 'No data available');
                }
            }
        } catch (error) {
            console.error('Error updating nutrient charts:', error);
            console.error('Error details:', error.message, error.stack);
        }
    }

    updateChartTimestamp(elementId, timestamp) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = `Last updated: ${timestamp}`;
        }
    }

    updateLatestDataEntries() {
        const container = document.getElementById('latest-entries-container');
        const entries = [];

        // Get latest entry from each category
        if (this.dataRecords.waterQuality.length > 0) {
            const latest = this.dataRecords.waterQuality[0];
            entries.push({
                type: 'Water Quality',
                className: 'water-quality',
                date: latest.date,
                content: this.formatWaterQualityEntry(latest)
            });
        }

        // Get fish inventory summary
        const fishData = this.getLatestFishHealthData();
        if (fishData) {
            const fishDataWithWeight = this.getLatestFishHealthDataWithWeight();
            entries.push({
                type: 'Fish Inventory',
                className: 'fish-health',
                date: fishData.date,
                content: `${fishData.count || 0} fish${fishDataWithWeight?.average_weight ? `, avg ${fishDataWithWeight.average_weight.toFixed(0)}g` : ''}`
            });
        }

        if (this.dataRecords.plantGrowth.length > 0) {
            const latest = this.dataRecords.plantGrowth[0];
            entries.push({
                type: 'Plant Growth',
                className: 'plant-growth',
                date: latest.date,
                content: this.formatPlantGrowthEntry(latest)
            });
        }

        if (this.dataRecords.operations.length > 0) {
            const latest = this.dataRecords.operations[0];
            entries.push({
                type: 'Operations',
                className: 'operations',
                date: latest.date,
                content: this.formatOperationsEntry(latest)
            });
        }

        if (entries.length === 0) {
            container.innerHTML = '<div class="no-data-message">No data entries yet. Use the Data Entry tab to start recording measurements.</div>';
            return;
        }

        // Sort entries by date (newest first)
        entries.sort((a, b) => new Date(b.date) - new Date(a.date));

        const entriesHtml = entries.map(entry => `
            <div class="latest-entry-card ${entry.className}">
                <div class="latest-entry-header">
                    <div class="latest-entry-type">${entry.type}</div>
                    <div class="latest-entry-date">${this.formatEntryDate(entry.date)}</div>
                </div>
                <div class="latest-entry-content">
                    ${entry.content}
                </div>
            </div>
        `).join('');

        container.innerHTML = `<div class="latest-entries-grid">${entriesHtml}</div>`;
    }

    formatWaterQualityEntry(entry) {
        const items = [];
        if (entry.temperature) items.push(`Temp: ${entry.temperature}¬∞C`);
        if (entry.ph) items.push(`pH: ${entry.ph}`);
        if (entry.dissolved_oxygen) items.push(`DO: ${entry.dissolved_oxygen} mg/L`);
        if (entry.ammonia) items.push(`NH‚ÇÉ: ${entry.ammonia} ppm`);
        if (entry.ec) items.push(`EC: ${entry.ec} ppm`);
        if (entry.nitrite) items.push(`NO‚ÇÇ: ${entry.nitrite} ppm`);
        if (entry.nitrate) items.push(`NO‚ÇÉ: ${entry.nitrate} ppm`);
        return items.join(' ‚Ä¢ ') || 'No measurements recorded';
    }

    formatFishHealthEntry(entry) {
        const items = [];
        if (entry.fish_tank_id) items.push(`Tank ${entry.fish_tank_id}`);
        if (entry.count) items.push(`Count: ${entry.count}`);
        if (entry.mortality) items.push(`Mortality: ${entry.mortality}`);
        if (entry.average_weight) items.push(`Avg Weight: ${entry.average_weight}g`);
        if (entry.feed_consumption) items.push(`Feed: ${entry.feed_consumption}g`);
        if (entry.behavior) items.push(`Behavior: ${entry.behavior}`);
        return items.join(' ‚Ä¢ ') || 'No data recorded';
    }

    formatPlantGrowthEntry(entry) {
        const items = [];
        if (entry.crop_type) items.push(`Crop: ${entry.crop_type}`);
        if (entry.count) items.push(`Count: ${entry.count}`);
        if (entry.harvest_weight) items.push(`Harvest: ${entry.harvest_weight}g`);
        if (entry.health) items.push(`Health: ${entry.health}`);
        if (entry.growth_stage) items.push(`Stage: ${entry.growth_stage}`);
        return items.join(' ‚Ä¢ ') || 'No data recorded';
    }

    formatOperationsEntry(entry) {
        const items = [];
        if (entry.operation_type) items.push(`Type: ${entry.operation_type}`);
        if (entry.water_volume) items.push(`Water: ${entry.water_volume}L`);
        if (entry.chemical_added) items.push(`Chemical: ${entry.chemical_added}`);
        if (entry.amount_added) items.push(`Amount: ${entry.amount_added}`);
        if (entry.downtime_duration) items.push(`Downtime: ${entry.downtime_duration}h`);
        return items.join(' ‚Ä¢ ') || 'No data recorded';
    }

    formatEntryDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 0) {
            return 'Today';
        } else if (diffDays === 1) {
            return 'Yesterday';
        } else if (diffDays < 7) {
            return `${diffDays} days ago`;
        } else {
            return this.formatDateDDMMYYYY(date);
        }
    }

    updateDataHistoryDisplays() {
        this.updateWaterQualityHistory();
        this.updateFishHealthHistory();
        this.updatePlantGrowthHistory();
        this.updateOperationsHistory();
    }

    updateWaterQualityHistory() {
        const container = document.getElementById('water-quality-history');
        if (!container) return;
        
        const data = this.dataRecords.waterQuality.slice(0, 5); // Show last 5 entries
        
        if (data.length === 0) {
            container.innerHTML = '<div class="data-history-empty">No water quality data recorded yet.</div>';
            return;
        }
        
        const itemsHtml = data.map(item => `
            <div class="data-history-item water-quality">
                <div class="data-history-header">
                    <div class="data-history-date">${this.formatEntryDate(item.date)}</div>
                </div>
                <div class="data-history-content">
                    ${this.formatWaterQualityEntry(item)}
                </div>
            </div>
        `).join('');
        
        container.innerHTML = itemsHtml;
    }

    updateFishHealthHistory() {
        const container = document.getElementById('fish-health-history');
        if (!container) return;
        
        // Fish events will be loaded on demand - for now show placeholder
        const data = []; // TODO: Load recent fish events from API
        
        if (data.length === 0) {
            container.innerHTML = '<div class="data-history-empty">No fish health data recorded yet.</div>';
            return;
        }
        
        const itemsHtml = data.map(item => `
            <div class="data-history-item fish-health">
                <div class="data-history-header">
                    <div class="data-history-date">${this.formatEntryDate(item.date)}</div>
                </div>
                <div class="data-history-content">
                    ${this.formatFishHealthEntry(item)}
                </div>
            </div>
        `).join('');
        
        container.innerHTML = itemsHtml;
    }

    updatePlantGrowthHistory() {
        const container = document.getElementById('plant-growth-history');
        if (!container) return;
        
        const data = this.dataRecords.plantGrowth.slice(0, 5); // Show last 5 entries
        
        if (data.length === 0) {
            container.innerHTML = '<div class="data-history-empty">No plant growth data recorded yet.</div>';
            return;
        }
        
        const itemsHtml = data.map(item => `
            <div class="data-history-item plant-growth">
                <div class="data-history-header">
                    <div class="data-history-date">${this.formatEntryDate(item.date)}</div>
                </div>
                <div class="data-history-content">
                    ${this.formatPlantGrowthEntry(item)}
                </div>
            </div>
        `).join('');
        
        container.innerHTML = itemsHtml;
    }

    updateOperationsHistory() {
        const container = document.getElementById('operations-history');
        if (!container) return;
        
        const data = this.dataRecords.operations.slice(0, 5); // Show last 5 entries
        
        if (data.length === 0) {
            container.innerHTML = '<div class="data-history-empty">No operations data recorded yet.</div>';
            return;
        }
        
        const itemsHtml = data.map(item => `
            <div class="data-history-item operations">
                <div class="data-history-header">
                    <div class="data-history-date">${this.formatEntryDate(item.date)}</div>
                </div>
                <div class="data-history-content">
                    ${this.formatOperationsEntry(item)}
                </div>
            </div>
        `).join('');
        
        container.innerHTML = itemsHtml;
    }

    async updateFishTankSummary() {
        const container = document.getElementById('tank-summary-container');
        if (!container) return;

        const systemConfig = this.loadSystemConfig();
        
        // Load individual fish tank configurations
        if (this.activeSystemId) {
            try {
                const response = await this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}`);
                systemConfig.fish_tanks = response.tanks || [];
            } catch (error) {
                console.error('Failed to load fish tank configurations:', error);
                systemConfig.fish_tanks = [];
            }
        }
        
        // Calculate actual tank count based on configured tanks
        const tankConfigs = systemConfig.fish_tanks || [];
        
        // If no tank configs loaded, create mock tanks based on system configuration
        if (tankConfigs.length === 0 && systemConfig.fish_tank_count > 0) {
            const totalVolume = systemConfig.total_fish_volume || 7000; // Default 7000L for 7 tanks
            const volumePerTank = Math.floor(totalVolume / systemConfig.fish_tank_count);
            
            for (let i = 1; i <= systemConfig.fish_tank_count; i++) {
                tankConfigs.push({
                    id: i,
                    tank_number: i,
                    volume_liters: volumePerTank,
                    size_m3: volumePerTank / 1000,
                    fish_type: systemConfig.fish_type || 'tilapia',
                    system_id: this.activeSystemId
                });
            }
            systemConfig.fish_tanks = tankConfigs;

        }
        
        const actualTankCount = Math.max(tankConfigs.length, systemConfig.fish_tank_count || 1);

        if (!systemConfig || systemConfig.system_name === 'No System Selected') {
            container.innerHTML = `
                <div class="no-system-message">
                    <p>Please select a system to view fish tank information.</p>
                </div>
            `;
            return;
        }

        // Fetch fish inventory data from the new API
        let totalFish = 0;
        let totalBiomassKg = 0;
        let averageWeight = 0;
        let inventoryTanks = [];
        
        try {
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`);

            if (fishInventoryData && fishInventoryData.tanks) {
                inventoryTanks = fishInventoryData.tanks;
                totalFish = inventoryTanks.reduce((sum, tank) => {
                    const count = parseInt(tank.current_count) || 0;
                    return sum + (isNaN(count) ? 0 : count);
                }, 0);
                totalBiomassKg = inventoryTanks.reduce((sum, tank) => {
                    const biomass = parseFloat(tank.biomass_kg) || 0;
                    return sum + (isNaN(biomass) ? 0 : biomass);
                }, 0);
                
                // Calculate weighted average weight
                if (totalFish > 0) {
                    const totalWeight = inventoryTanks.reduce((sum, tank) => {
                        const count = parseInt(tank.current_count) || 0;
                        const weight = parseFloat(tank.average_weight) || 0;
                        return sum + ((isNaN(count) ? 0 : count) * (isNaN(weight) ? 0 : weight));
                    }, 0);
                    averageWeight = isNaN(totalWeight) || totalFish === 0 ? 0 : totalWeight / totalFish;
                }

            }
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('fish_inventory_fetch_failed', 'Failed to fetch fish inventory data', this.activeSystemId);
            } else {
                console.error('Failed to fetch fish inventory data:', error);
            }
            totalFish = 0;
            totalBiomassKg = 0;
            averageWeight = 0;
        }
        
        // If no inventory data, use fish health data as fallback
        if (totalFish === 0 && totalBiomassKg === 0) {
            try {
                const fishHealthData = this.dataRecords?.fishHealth || [];
                const latestHealthEntry = fishHealthData.find(entry => 
                    entry.count > 0 && entry.average_weight > 0
                );
                
                if (latestHealthEntry) {
                    totalFish = latestHealthEntry.count;
                    averageWeight = latestHealthEntry.average_weight;
                    totalBiomassKg = (totalFish * averageWeight) / 1000; // Convert to kg
                }
            } catch (error) {
                console.error('Failed to use fish health fallback:', error);
            }
        }
        
        // Get fish type for calculations
        const fishType = systemConfig.fish_type || 'Unknown';
        
        // Calculate actual total volume from tank configurations
        let fishVolume = 0;
        if (tankConfigs.length > 0) {
            fishVolume = tankConfigs.reduce((total, tank) => total + (parseFloat(tank.volume_liters) || 0), 0);

        } else {
            fishVolume = systemConfig.total_fish_volume || 1000;

        }
        const fishVolumeM3 = fishVolume / 1000; // Convert liters to cubic meters
        
        // Use inventory biomass if available, otherwise estimate
        let totalWeightKg = totalBiomassKg;
        let effectiveWeight = averageWeight;
        
        if (totalWeightKg === 0 && totalFish > 0) {
            // Use estimated weight if no actual weight data is available
            const estimatedWeights = {
                'tilapia': 250,  // 250g average for growing tilapia
                'trout': 200,    // 200g average for growing trout  
                'catfish': 300,  // 300g average for growing catfish
                'salmon': 350,   // 350g average for growing salmon
                'bass': 250      // 250g average for growing bass
            };
            effectiveWeight = estimatedWeights[fishType.toLowerCase()] || 250;
            totalWeightKg = (totalFish * effectiveWeight) / 1000; // Convert grams to kg
        }
        
        // Add safety checks for NaN values

        // Ensure values are valid numbers
        const safeWeightKg = isNaN(totalWeightKg) || !isFinite(totalWeightKg) ? 0 : totalWeightKg;
        const safeVolumeM3 = isNaN(fishVolumeM3) || !isFinite(fishVolumeM3) ? 1 : fishVolumeM3; // Default 1m¬≥ to avoid division by zero
        
        // Current actual density and final harvest density
        const actualDensity = safeVolumeM3 > 0 ? (safeWeightKg / safeVolumeM3).toFixed(1) : 'N/A';
        const isUsingEstimatedWeight = totalBiomassKg === 0 && effectiveWeight > 0;
        const finalHarvestWeight = this.getFinalHarvestWeight(fishType);
        const finalTotalWeight = (totalFish * finalHarvestWeight) / 1000; // Convert to kg
        const finalDensity = fishVolumeM3 > 0 ? (finalTotalWeight / fishVolumeM3).toFixed(1) : 'N/A';
        
        // Calculate recommended stocking density based on fish type
        const recommendedMaxDensity = this.getRecommendedStockingDensity(fishType);
        const densityStatus = actualDensity !== 'N/A' && actualDensity > recommendedMaxDensity ? 'warning' : 'good';
        
        // Get last feeding time
        const lastFeedTime = this.getLastFeedingTime();
        
        // Calculate monthly feed consumption
        const feedConsumption = this.getCurrentMonthFeedConsumption();
        
        // Get latest fish health data for tank details
        const latestFishData = this.getLatestFishHealthData();

        container.innerHTML = `
            <div class="charts-grid">
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_fish.svg" alt="Fish" class="metric-icon-svg"></div>
                    <div class="metric-value">${totalFish}</div>
                    <div class="metric-label">Total Fish Count</div>
                    <div class="summary-detail">Across ${actualTankCount} tank${actualTankCount > 1 ? 's' : ''}</div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_parameters.svg" alt="Density" class="metric-icon-svg"></div>
                    <div class="metric-value">${actualDensity} kg/m¬≥</div>
                    <div class="metric-label">Current Density</div>
                    <div class="density-progress-container">
                        <div class="density-progress-bar">
                            <div class="density-progress-fill ${densityStatus}" style="width: ${Math.min((actualDensity !== 'N/A' ? (parseFloat(actualDensity) / recommendedMaxDensity) * 100 : 0), 100)}%"></div>
                        </div>
                        <div class="density-progress-label">Max: ${recommendedMaxDensity} kg/m¬≥</div>
                    </div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_data.svg" alt="Feed Consumption" class="metric-icon-svg"></div>
                    <div class="metric-value">${feedConsumption.current}</div>
                    <div class="metric-label">Feed This Month</div>
                    <div class="summary-detail">${feedConsumption.comparison}</div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_feed.svg" alt="Feed" class="metric-icon-svg"></div>
                    <div class="metric-value">${lastFeedTime}</div>
                    <div class="metric-label">Last Fed</div>
                    <div class="summary-detail">Feed regularly for optimal health</div>
                </div>
            </div>
            
            ${totalFish > 0 ? `
                <div class="tank-details">
                    <h4>Tank Details</h4>
                    <div class="tank-details-grid">
                        ${this.generateTankDetails(systemConfig, inventoryTanks, actualTankCount)}
                    </div>
                </div>
                
                <div class="fish-density-chart-section">
                    <h4>Fish Density Over Time</h4>
                    <canvas id="fish-density-chart" width="400" height="200"></canvas>
                </div>
                
            ` : ''}
            
            ${false ? `
                <div class="mortality-alert">
                    <strong>‚ö†Ô∏è Recent Mortality:</strong> mortality data from fish events coming soon
                </div>
            ` : ''}
        `;
        
        // Initialize fish density chart if fish are present
        if (totalFish > 0) {
            setTimeout(() => this.initializeFishDensityChart().catch(console.error), 100);
        }
    }

    async displayFishOverviewCards(container, actualTotalVolumeL) {
        // Load fish inventory data
        let inventoryTanks = [];
        let totalFish = 0;
        
        try {
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`);
            if (fishInventoryData && fishInventoryData.tanks) {
                inventoryTanks = fishInventoryData.tanks;
                totalFish = inventoryTanks.reduce((sum, tank) => sum + (parseInt(tank.current_count) || 0), 0);
            }
        } catch (error) {
            console.error('Error loading fish inventory:', error);
        }
        
        // Fallback to fish health data if inventory is empty
        if (totalFish === 0) {
            const latestFishData = this.getLatestFishHealthData();
            if (latestFishData) {
                totalFish = latestFishData.count || 0;
            }
        }
        
        const systemConfig = this.getActiveSystem();
        const actualTankCount = inventoryTanks.length || systemConfig?.tank_count || 0;
        
        // Calculate density metrics
        const fishType = systemConfig?.fish_type || 'tilapia';
        const recommendedMaxDensity = this.getRecommendedStockingDensity(fishType);
        const actualDensity = totalFish > 0 && actualTotalVolumeL > 0 
            ? (totalFish * 0.25 / (actualTotalVolumeL / 1000)).toFixed(1) 
            : 'N/A';
        const stockingDensity = recommendedMaxDensity.toFixed(1);
        const densityStatus = actualDensity !== 'N/A' && actualDensity > recommendedMaxDensity ? 'warning' : 'good';
        
        // Get last feeding time and feed consumption
        const lastFeedTime = this.getLastFeedingTime();
        const feedConsumption = this.getCurrentMonthFeedConsumption();
        
        const cardsHtml = `
            <div class="charts-grid">
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_fish.svg" alt="Fish" class="metric-icon-svg"></div>
                    <div class="metric-value">${totalFish}</div>
                    <div class="metric-label">Total Fish Count</div>
                    <div class="summary-detail">Across ${actualTankCount} tank${actualTankCount !== 1 ? 's' : ''}</div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_parameters.svg" alt="Density" class="metric-icon-svg"></div>
                    <div class="metric-value">${actualDensity} kg/m¬≥</div>
                    <div class="metric-label">Current Density</div>
                    <div class="density-progress-container">
                        <div class="density-progress-bar">
                            <div class="density-progress-fill ${densityStatus}" style="width: ${Math.min((actualDensity !== 'N/A' ? (parseFloat(actualDensity) / recommendedMaxDensity) * 100 : 0), 100)}%"></div>
                        </div>
                        <div class="density-progress-label">Max: ${recommendedMaxDensity} kg/m¬≥</div>
                    </div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_data.svg" alt="Feed Consumption" class="metric-icon-svg"></div>
                    <div class="metric-value">${feedConsumption.current}</div>
                    <div class="metric-label">Feed This Month</div>
                    <div class="summary-detail">${feedConsumption.comparison}</div>
                </div>
                
                <div class="chart-card metric-card">
                    <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_feed.svg" alt="Feed" class="metric-icon-svg"></div>
                    <div class="metric-value">${lastFeedTime}</div>
                    <div class="metric-label">Last Fed</div>
                    <div class="summary-detail">Feed regularly for optimal health</div>
                </div>
            </div>
            
            ${actualTankCount > 0 ? `
                <div class="tank-details">
                    <h4>Tank Details</h4>
                    <div class="tank-details-grid">
                        ${this.generateTankDetails(systemConfig, inventoryTanks, actualTankCount)}
                    </div>
                </div>
                
                ${totalFish > 0 ? `
                    <div class="fish-density-chart-section">
                        <h4>Fish Density Over Time</h4>
                        <canvas id="fish-density-chart" width="400" height="200"></canvas>
                    </div>
                ` : ''}
            ` : ''}
        `;
        
        // Set the container HTML
        container.innerHTML = cardsHtml;
        
        // Initialize fish density chart if fish are present
        if (totalFish > 0) {
            setTimeout(() => this.initializeFishDensityChart().catch(console.error), 100);
        }
    }

    getLatestFishHealthData() {
        // Return inventory summary or null
        const inventory = this.dataRecords.fishInventory;
        if (!inventory || !inventory.tanks || inventory.tanks.length === 0) {
            return null;
        }
        
        // Calculate total fish across all tanks
        const totalCount = inventory.tanks.reduce((sum, tank) => sum + (tank.current_count || 0), 0);
        if (totalCount === 0) return null;
        
        // Return a fish health-like object for compatibility
        return {
            count: totalCount,
            date: new Date().toISOString().split('T')[0]
        };
    }
    
    getLatestFishHealthDataWithWeight() {
        // Return inventory summary with weight or null
        const inventory = this.dataRecords.fishInventory;
        if (!inventory || !inventory.tanks || inventory.tanks.length === 0) {
            return null;
        }
        
        // Calculate weighted average weight across all tanks
        let totalWeight = 0;
        let totalCount = 0;
        
        inventory.tanks.forEach(tank => {
            const count = tank.current_count || 0;
            const weight = tank.average_weight || 0;
            totalWeight += count * weight;
            totalCount += count;
        });
        
        if (totalCount === 0) return null;
        
        const averageWeight = totalWeight / totalCount;
        
        // Return a fish health-like object for compatibility
        return {
            count: totalCount,
            average_weight: averageWeight,
            date: new Date().toISOString().split('T')[0]
        };
    }

    getOptimalStockingRate(fishType) {
        // Optimal stocking rates in liters per fish for different species
        const stockingRates = {
            tilapia: 50,    // 50L per tilapia
            catfish: 40,    // 40L per catfish  
            trout: 80,      // 80L per trout
            bass: 100,      // 100L per bass
            goldfish: 20,   // 20L per goldfish
            koi: 150        // 150L per koi
        };
        return stockingRates[fishType.toLowerCase()] || 50; // Default to tilapia rate
    }

    getLastFeedingTime() {
        // Get the most recent fish health entry with feeding data
        const fishHealthData = this.dataRecords?.fishHealth || [];
        
        if (fishHealthData.length === 0) {
            return 'No feeding data';
        }
        
        // Find the most recent entry with feeding information
        const latestFeedEntry = fishHealthData.find(entry => 
            entry.feed_consumption && entry.feed_consumption > 0 && entry.date
        );
        
        
        if (!latestFeedEntry) {
            return 'No recent feeding';
        }
        
        try {
            // Use created_at for precise timestamp, fallback to date if not available
            const feedTimestamp = latestFeedEntry.created_at || latestFeedEntry.date;
            const feedDate = new Date(feedTimestamp);
            const now = new Date();
            const timeDiff = now - feedDate;
            const hoursDiff = Math.floor(timeDiff / (1000 * 60 * 60));
            const daysDiff = Math.floor(hoursDiff / 24);
            
            
            if (hoursDiff < 1) {
                return 'Just now';
            } else if (hoursDiff < 24) {
                return `${hoursDiff}h ago`;
            } else if (daysDiff === 1) {
                return 'Yesterday';
            } else if (daysDiff < 7) {
                return `${daysDiff} days ago`;
            } else {
                return this.formatDateDDMMYYYY(feedDate);
            }
        } catch (error) {
            console.error('Error calculating last feeding time:', error);
            return 'Unknown';
        }
    }

    getCurrentMonthFeedConsumption() {
        const fishHealthData = this.dataRecords?.fishHealth || [];
        
        if (fishHealthData.length === 0) {
            return {
                current: '0g',
                comparison: 'No feeding data available'
            };
        }
        
        const now = new Date();
        const currentMonth = now.getMonth();
        const currentYear = now.getFullYear();
        const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
        const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;
        
        // Calculate current month consumption
        const currentMonthEntries = fishHealthData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate.getMonth() === currentMonth && 
                   entryDate.getFullYear() === currentYear;
        });
        
        const currentMonthConsumption = currentMonthEntries.reduce((total, entry) => {
            const consumption = parseFloat(entry.feed_consumption) || 0;
            return total + consumption;
        }, 0);
        
        // Calculate previous month consumption  
        const previousMonthConsumption = fishHealthData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate.getMonth() === previousMonth && 
                   entryDate.getFullYear() === previousYear;
        }).reduce((total, entry) => {
            const consumption = parseFloat(entry.feed_consumption) || 0;
            return total + consumption;
        }, 0);
        
        // Format current consumption
        const safeConsumption = (isNaN(currentMonthConsumption) || currentMonthConsumption < 0) ? 0 : currentMonthConsumption;
        const currentFormatted = safeConsumption >= 1000 ? 
            `${(safeConsumption / 1000).toFixed(1)}kg` : 
            `${Math.round(safeConsumption)}g`;
        
        // Calculate comparison
        let comparison;
        if (previousMonthConsumption === 0) {
            comparison = currentMonthConsumption > 0 ? 'First month data' : 'No consumption recorded';
        } else {
            const percentChange = ((currentMonthConsumption - previousMonthConsumption) / previousMonthConsumption) * 100;
            if (Math.abs(percentChange) < 5) {
                comparison = 'Similar to last month';
            } else if (percentChange > 0) {
                comparison = `+${Math.round(percentChange)}% vs last month`;
            } else {
                comparison = `${Math.round(percentChange)}% vs last month`;
            }
        }
        
        return {
            current: currentFormatted,
            comparison: comparison
        };
    }

    getFinalHarvestWeight(fishType) {
        // Returns average final harvest weight in grams
        const harvestWeights = {
            'tilapia': 500, // 500g average
            'trout': 300,   // 300g average  
            'catfish': 800, // 800g average
            'default': 400  // 400g default
        };
        return harvestWeights[fishType.toLowerCase()] || harvestWeights.default;
    }

    getRecommendedStockingDensity(fishType) {
        // Returns recommended maximum stocking density in kg/m¬≥
        const densityLimits = {
            'tilapia': 30,  // 30 kg/m¬≥ max for tilapia
            'trout': 25,    // 25 kg/m¬≥ max for trout
            'catfish': 35,  // 35 kg/m¬≥ max for catfish
            'default': 25   // 25 kg/m¬≥ default
        };
        if (!fishType) return densityLimits.default;
        return densityLimits[fishType.toLowerCase()] || densityLimits.default;
    }

    generateTankDetails(systemConfig, inventoryTanks, actualTankCount) {
        return this.fishTankRenderer.generateTankDetails(systemConfig, inventoryTanks, actualTankCount);
    }

    toggleQuickActions(tankNumber) {
        // Hide all existing dropdowns first
        this.hideAllQuickActionMenus();
        
        // Find the button that was clicked
        const button = document.querySelector(`button[onclick="app.toggleQuickActions(${tankNumber})"]`);
        if (!button) {
            return;
        }
        
        // Create or find the dropdown menu
        let menu = document.getElementById(`floating-quick-actions-${tankNumber}`);
        if (!menu) {
            // Create the menu dynamically
            menu = this.createFloatingQuickActionsMenu(tankNumber);
        }
        
        // Position the menu relative to the button with smart positioning
        const buttonRect = button.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        menu.style.display = 'block';
        menu.style.position = 'fixed';
        menu.style.zIndex = '999999';
        
        // Get menu dimensions after showing it
        const menuRect = menu.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Smart vertical positioning
        const spaceBelow = viewportHeight - buttonRect.bottom;
        const spaceAbove = buttonRect.top;
        const menuHeight = menuRect.height || 200; // Fallback height if not measured yet
        
        let topPosition;
        if (spaceBelow >= menuHeight + 10) {
            // Enough space below - position below button
            topPosition = buttonRect.bottom + 4;
        } else if (spaceAbove >= menuHeight + 10) {
            // Not enough space below but enough above - position above button
            topPosition = buttonRect.top - menuHeight - 4;
        } else {
            // Not enough space either way - position at top of viewport with padding
            topPosition = 10;
        }
        
        // Smart horizontal positioning
        let leftPosition = buttonRect.left;
        const menuWidth = menuRect.width || 200; // Fallback width
        
        if (leftPosition + menuWidth > viewportWidth - 10) {
            // Menu would extend beyond right edge - align right edge with button right edge
            leftPosition = buttonRect.right - menuWidth;
        }
        
        // Ensure menu doesn't go beyond left edge
        if (leftPosition < 10) {
            leftPosition = 10;
        }
        
        menu.style.top = topPosition + 'px';
        menu.style.left = leftPosition + 'px';
        
        // Close menu when clicking outside
        setTimeout(() => {
            document.addEventListener('click', this.closeQuickActionsOnOutsideClick, true);
        }, 0);
    }
    
    createFloatingQuickActionsMenu(tankNumber) {
        const menu = document.createElement('div');
        menu.id = `floating-quick-actions-${tankNumber}`;
        menu.className = 'floating-quick-actions-menu';
        menu.style.display = 'none';
        
        menu.innerHTML = `
            <button class="quick-action-item" onclick="app.showAddFishModal(${tankNumber})">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
                Add Fish
            </button>
            <button class="quick-action-item" onclick="app.showMortalityModal(${tankNumber})">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                Mortality
            </button>
            <button class="quick-action-item" onclick="app.showFeedingModal(${tankNumber})">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7z"/>
                </svg>
                Feed
            </button>
            <button class="quick-action-item" onclick="app.showFishSizeModal(${tankNumber})">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                </svg>
                Record Size
            </button>
            <button class="quick-action-item" onclick="app.showHarvestFishModal(${tankNumber})">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1zM10 6a2 2 0 0 1 4 0v1h-4V6zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10z"/>
                </svg>
                Harvest
            </button>
        `;
        
        document.body.appendChild(menu);
        return menu;
    }
    
    hideAllQuickActionMenus() {
        // Hide original dropdown menus
        document.querySelectorAll('.quick-actions-menu').forEach(menu => {
            menu.style.display = 'none';
        });
        
        // Hide and remove floating menus
        document.querySelectorAll('.floating-quick-actions-menu').forEach(menu => {
            menu.style.display = 'none';
            menu.remove(); // Remove from DOM
        });
        
        document.removeEventListener('click', this.closeQuickActionsOnOutsideClick, true);
    }
    
    hideQuickActions(tankNumber) {
        // Hide regular dropdown menu
        const menu = document.getElementById(`quick-actions-${tankNumber}`);
        if (menu) {
            menu.style.display = 'none';
        }
        
        // Hide floating menu
        const floatingMenu = document.getElementById(`floating-quick-actions-${tankNumber}`);
        if (floatingMenu) {
            floatingMenu.style.display = 'none';
        }
        
        document.removeEventListener('click', this.closeQuickActionsOnOutsideClick, true);
    }
    
    // Force close all Quick Actions menus (used when opening modals)
    hideAllQuickActions() {
        // Hide all regular dropdown menus with aggressive CSS forcing
        const allMenus = document.querySelectorAll('[id^="quick-actions-"]');
        allMenus.forEach(menu => {
            menu.removeAttribute('style');
            menu.style.setProperty('display', 'none', 'important');
            menu.style.setProperty('visibility', 'hidden', 'important');
            menu.style.setProperty('opacity', '0', 'important');
        });
        
        // Hide all floating menus more aggressively
        const allFloatingMenus = document.querySelectorAll('[id^="floating-quick-actions-"]');
        allFloatingMenus.forEach(menu => {
            menu.style.setProperty('display', 'none', 'important');
            menu.style.setProperty('visibility', 'hidden', 'important');
            menu.style.setProperty('opacity', '0', 'important');
            menu.style.setProperty('pointer-events', 'none', 'important');
            // Also remove from DOM
            menu.remove();
        });
        
        // Remove outside click listener
        document.removeEventListener('click', this.closeQuickActionsOnOutsideClick, true);
    }
    
    closeQuickActionsOnOutsideClick = (event) => {
        // Check if click is inside any dropdown or floating menu
        if (!event.target.closest('.quick-actions-dropdown') && 
            !event.target.closest('.floating-quick-actions-menu')) {
            // Hide all dropdown menus
            document.querySelectorAll('.quick-actions-menu').forEach(menu => {
                menu.style.display = 'none';
            });
            // Hide all floating menus
            document.querySelectorAll('.floating-quick-actions-menu').forEach(menu => {
                menu.style.display = 'none';
                // Remove from DOM if it's a floating menu
                menu.remove();
            });
            document.removeEventListener('click', this.closeQuickActionsOnOutsideClick, true);
        }
    }

    // Bed Quick Actions Functions
    toggleBedQuickActions(bedId) {
        
        // Find the inline dropdown menu that exists in the HTML
        const menu = document.getElementById(`bed-quick-actions-${bedId}`);
        if (!menu) {
            return;
        }
        
        
        // Check if this specific menu is currently visible
        const isVisible = menu.style.display === 'block' || window.getComputedStyle(menu).display === 'block';
        
        if (isVisible) {
            // Menu is visible, hide it
            this.hideAllBedQuickActionMenus();
        } else {
            // Menu is not visible, hide all others first then show this one
            this.hideAllBedQuickActionMenus();
            
            // Show this menu after a small delay to ensure hiding is complete
            setTimeout(() => {
                menu.style.setProperty('display', 'block', 'important');
                menu.style.setProperty('visibility', 'visible', 'important');
                menu.style.setProperty('opacity', '1', 'important');
                menu.style.setProperty('z-index', '99999', 'important');
            }, 10);
        }
    }
    
    createFloatingBedQuickActionsMenu(bedId) {
        const menu = document.createElement('div');
        menu.id = `floating-bed-quick-actions-${bedId}`;
        menu.className = 'floating-quick-actions-menu';
        menu.style.display = 'none';
        
        // Get bed name for display
        const bed = this.allGrowBeds?.find(b => b.id === bedId);
        const bedName = bed?.bed_name || `Bed ${bed?.bed_number || bedId}`;
        
        menu.innerHTML = `
            <button class="quick-action-item" onclick="app.openQuickPlantDialog('${bedId}', '${bedName}')">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
                Plant
            </button>
            <button class="quick-action-item" onclick="app.openQuickHarvestDialog('${bedId}', '${bedName}')">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M12 2L13.09 8.26L22 9L14 14.74L16.18 22L12 18.27L7.82 22L10 14.74L2 9L10.91 8.26L12 2z"/>
                </svg>
                Harvest
            </button>
            <button class="quick-action-item" onclick="app.openQuickMoveDialog('${bedId}', '${bedName}')">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                </svg>
                Move Batch
            </button>
            <button class="quick-action-item" onclick="app.showBedDetails('${bedId}')">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                    <path d="M13 17.5c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm0-9c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm-6 0c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2z"/>
                </svg>
                Details
            </button>
        `;
        
        // Add click listeners to menu items for debugging
        menu.addEventListener('click', (e) => {
            const clickedItem = e.target.closest('.quick-action-item');
            if (clickedItem) {
                // Don't hide menu here - let the onclick handler execute first
                // Menu will be hidden by the action functions themselves
            }
        });
        
        document.body.appendChild(menu);
        return menu;
    }

    hideAllBedQuickActionMenus() {
        // Hide old inline menus
        document.querySelectorAll('[id^="bed-quick-actions-"]').forEach(menu => {
            menu.removeAttribute('style');
            menu.style.setProperty('display', 'none', 'important');
            menu.style.setProperty('visibility', 'hidden', 'important');
            menu.style.setProperty('opacity', '0', 'important');
        });
        // Hide floating menus more aggressively
        document.querySelectorAll('[id^="floating-bed-quick-actions-"]').forEach(menu => {
            menu.style.setProperty('display', 'none', 'important');
            menu.style.setProperty('visibility', 'hidden', 'important');
            menu.style.setProperty('opacity', '0', 'important');
            menu.style.setProperty('pointer-events', 'none', 'important');
            // Also remove from DOM
            menu.remove();
        });
        document.removeEventListener('click', this.closeBedQuickActionsOnOutsideClick, true);
    }

    hideBedQuickActions(bedId) {
        const menu = document.getElementById(`bed-quick-actions-${bedId}`);
        if (menu) {
            menu.removeAttribute('style');
            menu.style.display = 'none';
        }
        document.removeEventListener('click', this.closeBedQuickActionsOnOutsideClick, true);
    }

    closeBedQuickActionsOnOutsideClick = (event) => {
        // Check if click is inside any bed dropdown
        if (!event.target.closest('.quick-actions-dropdown') && 
            !event.target.closest('.quick-actions-menu') &&
            !event.target.closest('.floating-quick-actions-menu')) {
            this.hideAllBedQuickActionMenus();
        }
    }

    // Bed Action Functions
    async openQuickPlantDialog(bedId, bedName) {
        
        try {
            // Hide the quick actions menu
            this.hideBedQuickActions(bedId);
            this.hideAllBedQuickActionMenus();
            
            // First ensure we're in the Plants view
            const plantsView = document.getElementById('plants');
            if (plantsView && !plantsView.classList.contains('active')) {
                const plantsNavBtn = document.querySelector('[data-view="plants"]') || document.getElementById('plants-btn');
                if (plantsNavBtn) {
                    plantsNavBtn.click();
                }
            }
            
            // Then switch to Plant & Harvest main tab
            const plantHarvestTab = document.getElementById('planting-harvesting-tab');
            if (plantHarvestTab) {
                plantHarvestTab.click();
            }
            
            // Wait a bit, then switch to the specific planting sub-tab
            setTimeout(() => {
                const plantingTab = document.getElementById('planting-tab');
                if (plantingTab) {
                    plantingTab.click();
                }
            }, 100);
            
            // Pre-populate the main planting form with bed information
            const plantBedSelect = document.getElementById('plant-grow-bed');
            const plantDateInput = document.getElementById('plant-date');
            if (plantBedSelect) plantBedSelect.value = bedId;
            if (plantDateInput) plantDateInput.value = new Date().toISOString().split('T')[0];
            
            // Show a helpful notification about the pre-populated form
            this.showNotification(`üå± Planting form opened for ${bedName}. Select crop and enter planting details.`, 'info');
            
            // Focus on the crop selection dropdown
            setTimeout(() => {
                const cropSelect = document.getElementById('plant-crop-type');
                if (cropSelect) {
                    cropSelect.focus();
                }
            }, 300);
            
        } catch (error) {
            console.error('Error opening plant dialog:', error);
            this.showNotification('Error loading planting form', 'error');
        }
    }
    
    navigateToPlantHarvest() {
        // First ensure we're on the plants view
        const plantsView = document.getElementById('plants');
        if (!plantsView.classList.contains('active')) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            plantsView.classList.add('active');
            const plantsNavBtn = document.querySelector('[data-view="plants"]') || document.getElementById('plants-btn');
            if (plantsNavBtn) plantsNavBtn.classList.add('active');
        }
        
        // Then click the Plant & Harvest tab
        const plantHarvestTab = document.getElementById('planting-harvesting-tab');
        if (plantHarvestTab) {
            plantHarvestTab.click();
        }
    }

    async openQuickHarvestDialog(bedId, bedName) {
        
        try {
            // Hide the quick actions menu
            this.hideBedQuickActions(bedId);
            this.hideAllBedQuickActionMenus();
            
            // First ensure we're in the Plants view
            const plantsView = document.getElementById('plants');
            if (plantsView && !plantsView.classList.contains('active')) {
                const plantsNavBtn = document.querySelector('[data-view="plants"]') || document.getElementById('plants-btn');
                if (plantsNavBtn) {
                    plantsNavBtn.click();
                }
            }
            
            // Then switch to Plant & Harvest main tab
            const plantHarvestTab = document.getElementById('planting-harvesting-tab');
            if (plantHarvestTab) {
                plantHarvestTab.click();
            }
            
            // Wait a bit, then switch to the specific harvest sub-tab
            setTimeout(() => {
                const harvestTab = document.getElementById('harvesting-tab');
                if (harvestTab) {
                    harvestTab.click();
                }
            }, 100);
            
            // Pre-populate the main harvest form with bed information
            const harvestBedSelect = document.getElementById('harvest-grow-bed');
            const harvestDateInput = document.getElementById('harvest-date');
            if (harvestBedSelect) harvestBedSelect.value = bedId;
            if (harvestDateInput) harvestDateInput.value = new Date().toISOString().split('T')[0];
            
            // Show a helpful notification about the pre-populated form
            this.showNotification(`üåæ Harvest form opened for ${bedName}. Select crop and enter harvest details.`, 'info');
            
            // Focus on the crop selection dropdown
            setTimeout(() => {
                const cropSelect = document.getElementById('harvest-crop-type');
                if (cropSelect) {
                    cropSelect.focus();
                }
            }, 300);
            
        } catch (error) {
            console.error('Error opening harvest dialog:', error);
            this.showNotification('Error loading harvest form', 'error');
        }
    }

    async openQuickMoveDialog(bedId, bedName) {
        
        try {
            // Hide the quick actions menu
            this.hideBedQuickActions(bedId);
            this.hideAllBedQuickActionMenus();
            
            // Get fresh plant data from API instead of using cached data
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            const batchesInBed = {};
            
            // Group plant data by batch for this bed
            plantData.forEach(entry => {
                if (entry.grow_bed_id == bedId && entry.batch_id) {
                    if (!batchesInBed[entry.batch_id]) {
                        batchesInBed[entry.batch_id] = {
                            batch_id: entry.batch_id,
                            crop_type: entry.crop_type,
                            planted: 0,
                            harvested: 0
                        };
                    }
                    
                    if (entry.plants_harvested && entry.plants_harvested > 0) {
                        batchesInBed[entry.batch_id].harvested += entry.plants_harvested;
                    } else if (entry.count && entry.count > 0) {
                        batchesInBed[entry.batch_id].planted += entry.count;
                    }
                }
            });
            
            const batches = Object.values(batchesInBed).filter(batch => batch.planted > batch.harvested);
            
            if (batches.length === 0) {
                this.showNotification(`No active batches found in ${bedName} to move`, 'warning');
                return;
            }
            
            // Get all grow beds for destination selection
            const growBeds = await this.getGrowBedsForSystem();
            
            // Create batch selection modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content batch-move-modal">
                    <div class="modal-header">
                        <h4>Move Batch from ${bedName}</h4>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="quick-batch-select" class="form-label">Select Batch to Move:</label>
                            <select id="quick-batch-select" class="form-input">
                                <option value="">Choose a batch...</option>
                                ${batches.map(batch => `
                                    <option value="${batch.batch_id}">
                                        ${batch.crop_type} - Batch ${batch.batch_id} (${batch.planted - batch.harvested} plants)
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="quick-destination-bed" class="form-label">Move to Grow Bed:</label>
                            <select id="quick-destination-bed" class="form-input">
                                <option value="">Choose destination...</option>
                                ${growBeds.filter(bed => bed.id != bedId).map(bed => `
                                    <option value="${bed.id}">
                                        ${bed.bed_name || `Bed ${bed.bed_number}`} (${bed.bed_type || 'Standard'})
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                        <button class="btn btn-primary" onclick="window.app.confirmQuickBatchMove(${bedId})">Move Batch</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
            
        } catch (error) {
            console.error('Error opening move dialog:', error);
            this.showNotification('Error loading batch move options', 'error');
        }
    }

    async confirmQuickBatchMove(fromBedId) {
        try {
            const batchSelect = document.getElementById('quick-batch-select');
            const destinationSelect = document.getElementById('quick-destination-bed');
            
            const batchId = batchSelect.value;
            const toBedId = destinationSelect.value;
            
            if (!batchId) {
                this.showNotification('Please select a batch to move', 'warning');
                return;
            }
            
            if (!toBedId) {
                this.showNotification('Please select a destination grow bed', 'warning');
                return;
            }
            
            // Use the existing batch move API - note: API expects camelCase
            const response = await this.makeApiCall(`/data/batch/${this.activeSystemId}/${batchId}/grow-bed`, {
                method: 'PUT',
                body: JSON.stringify({
                    newGrowBedId: parseInt(toBedId)
                })
            });
            
            if (response.message && !response.error) {
                // Close modal
                document.querySelector('.modal .batch-move-modal')?.closest('.modal').remove();
                
                // Get destination bed name for notification
                const growBeds = await this.getGrowBedsForSystem();
                const destinationBed = growBeds.find(bed => bed.id == toBedId);
                const destinationName = destinationBed?.bed_name || `Bed ${destinationBed?.bed_number}`;
                
                this.showNotification(`Batch ${batchId} moved successfully to ${destinationName}`, 'success');
                
                // Refresh data and UI
                await this.loadDataRecords();
                await this.updatePlantOverview();
                await this.loadBedsOverview();
            } else {
                this.showNotification('Failed to move batch: ' + (response.error || 'Unknown error'), 'error');
            }
            
        } catch (error) {
            console.error('Error moving batch:', error);
            this.showNotification('Error moving batch', 'error');
        }
    }

    showQuickHarvestModal(bedId, bedName, plants) {
        
        // Remove any existing harvest modal
        const existing = document.getElementById('quick-harvest-modal');
        if (existing) existing.remove();
        
        // Group plants by crop type and include batch information with ages
        const cropGroups = {};
        plants.forEach(plant => {
            const cropType = plant.crop_type;
            if (!cropGroups[cropType]) {
                cropGroups[cropType] = { total: 0, entries: [], batches: new Map() };
            }
            cropGroups[cropType].total += plant.count;
            cropGroups[cropType].entries.push(plant);
            if (plant.batch_id && !cropGroups[cropType].batches.has(plant.batch_id)) {
                // Calculate age from planting date
                const plantDate = new Date(plant.date);
                const today = new Date();
                const ageInDays = Math.floor((today - plantDate) / (1000 * 60 * 60 * 24));
                
                cropGroups[cropType].batches.set(plant.batch_id, {
                    id: plant.batch_id,
                    age: ageInDays,
                    plantDate: plant.date
                });
            }
        });
        
        // Convert maps to arrays for easier handling
        Object.keys(cropGroups).forEach(crop => {
            cropGroups[crop].batches = Array.from(cropGroups[crop].batches.values());
        });
        
        // Create modal HTML
        const modalHtml = `
            <div id="quick-harvest-modal" class="modal-overlay" style="display: block;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üåæ Harvest from ${bedName}</h3>
                        <button type="button" class="close-modal" onclick="this.closest('.modal-overlay').remove()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <form id="quick-harvest-form">
                            <div class="form-group">
                                <label class="form-label">Select crop to harvest:</label>
                                <select id="harvest-crop-select" class="form-input" required>
                                    <option value="">Choose a crop...</option>
                                    ${Object.keys(cropGroups).map(crop => 
                                        `<option value="${crop}">${this.cleanCustomCropName(crop)} (${cropGroups[crop].total} plants)</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <div class="form-group" id="batch-selection-group" style="display: none;">
                                <label class="form-label">Select batch:</label>
                                <select id="harvest-batch-select" class="form-input" required>
                                    <option value="">Choose a batch...</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Harvest type:</label>
                                <div style="display: flex; gap: 10px; margin-top: 5px;">
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="radio" name="harvest-type" value="weight-only" checked>
                                        <span>üçÖ Harvest produce only (plants remain)</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="radio" name="harvest-type" value="full-harvest">
                                        <span>üå± Harvest entire plants</span>
                                    </label>
                                </div>
                            </div>
                            <div class="form-group" id="plant-count-group" style="display: none;">
                                <label class="form-label">Number of plants to harvest:</label>
                                <input type="number" id="harvest-count" class="form-input" min="1" placeholder="Enter plant count">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Harvest weight (kg):</label>
                                <input type="number" id="quick-harvest-weight" class="form-input" min="0.1" step="0.1" required placeholder="Enter weight in kg">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Quality/Health:</label>
                                <select id="harvest-quality" class="form-input" required>
                                    <option value="">Select quality...</option>
                                    <option value="excellent">Excellent</option>
                                    <option value="good">Good</option>
                                    <option value="fair">Fair</option>
                                    <option value="poor">Poor</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Notes (optional):</label>
                                <textarea id="harvest-notes" class="form-input" rows="2" placeholder="Add any harvest notes..."></textarea>
                            </div>
                            <div class="form-actions">
                                <button type="button" class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                                <button type="submit" class="btn btn-success">Record Harvest</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Add event listeners
        const form = document.getElementById('quick-harvest-form');
        const cropSelect = document.getElementById('harvest-crop-select');
        const batchSelect = document.getElementById('harvest-batch-select');
        const batchGroup = document.getElementById('batch-selection-group');
        const countInput = document.getElementById('harvest-count');
        const plantCountGroup = document.getElementById('plant-count-group');
        const harvestTypeRadios = document.querySelectorAll('input[name="harvest-type"]');
        
        // Handle harvest type changes
        harvestTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.value === 'full-harvest') {
                    plantCountGroup.style.display = 'block';
                    countInput.required = true;
                } else {
                    plantCountGroup.style.display = 'none';
                    countInput.required = false;
                    countInput.value = '';
                }
            });
        });
        
        // Update batch dropdown when crop is selected
        cropSelect.addEventListener('change', () => {
            const selectedCrop = cropSelect.value;
            if (selectedCrop && cropGroups[selectedCrop]) {
                // Update plant count limits
                countInput.max = cropGroups[selectedCrop].total;
                countInput.placeholder = `Max: ${cropGroups[selectedCrop].total} plants`;
                
                // Show batch selection if batches exist
                const batches = cropGroups[selectedCrop].batches;
                if (batches.length > 0) {
                    batchGroup.style.display = 'block';
                    batchSelect.innerHTML = '<option value="">Choose a batch...</option>' +
                        batches.map(batch => {
                            const ageText = batch.age === 1 ? '1 day old' : `${batch.age} days old`;
                            return `<option value="${batch.id}">Batch ${batch.id} (${ageText})</option>`;
                        }).join('');
                    batchSelect.required = true;
                } else {
                    batchGroup.style.display = 'none';
                    batchSelect.required = false;
                }
            } else {
                batchGroup.style.display = 'none';
                batchSelect.required = false;
            }
        });
        
        // Handle form submission
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            await this.submitQuickHarvest(bedId, cropGroups);
        });
    }

    async submitQuickHarvest(bedId, cropGroups) {
        // Collect quick harvest form data with defensive checks
        const cropSelectEl = document.getElementById('harvest-crop-select');
        const batchSelectEl = document.getElementById('harvest-batch-select');
        const weightEl = document.getElementById('quick-harvest-weight');
        const qualityEl = document.getElementById('harvest-quality');
        const notesEl = document.getElementById('harvest-notes');

        if (!cropSelectEl || !batchSelectEl || !weightEl || !qualityEl) {
            this.showNotification('Quick harvest form elements not found. Please refresh the page.', 'error');
            return;
        }

        const cropType = cropSelectEl.value;
        const batchId = batchSelectEl.value;
        const weight = parseFloat(weightEl.value);
        const quality = qualityEl.value;
        const notes = notesEl ? notesEl.value : '';
        const harvestTypeElement = document.querySelector('input[name="harvest-type"]:checked');
        if (!harvestTypeElement) {
            this.showNotification('Please select a harvest type (Full Harvest or Partial Harvest)', 'error');
            return;
        }
        
        const harvestType = harvestTypeElement.value;
        const harvestCountEl = document.getElementById('harvest-count');
        const plantCount = harvestType === 'full-harvest' ? (harvestCountEl ? parseInt(harvestCountEl.value) || 0 : 0) : 0;
        
        // Debug validation
        
        // Validation
        if (!cropType || !weight || !quality) {
            console.error('‚ùå Validation failed:', { cropType: !!cropType, weight: !!weight, quality: !!quality });
            this.showNotification('Please fill in all required fields', 'error');
            return;
        }
        
        if (harvestType === 'full-harvest' && (!plantCount || plantCount <= 0)) {
            this.showNotification('Please enter the number of plants to harvest', 'error');
            return;
        }
        
        if (harvestType === 'full-harvest' && plantCount > cropGroups[cropType].total) {
            this.showNotification(`Cannot harvest ${plantCount} plants. Only ${cropGroups[cropType].total} available.`, 'error');
            return;
        }
        
        // Check batch requirement
        if (cropGroups[cropType].batches.length > 0 && !batchId) {
            this.showNotification('Please select a batch to harvest from', 'error');
            return;
        }
        
        try {
            // Prepare harvest data matching the existing recordHarvest structure
            const harvestData = {
                date: new Date().toISOString().split('T')[0],
                grow_bed_id: bedId,
                crop_type: cropType,
                plants_harvested: plantCount, // 0 for weight-only harvests, actual count for full harvests
                harvest_weight: weight * 1000, // Convert kg to grams
                health: quality,
                growth_stage: 'harvest',
                notes: notes || '',
                batch_id: batchId || null
            };
            
            
            const response = await fetch(`/api/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(harvestData)
            });
            
            if (response.ok) {
                const cropName = this.cleanCustomCropName(cropType);
                const weightMsg = `${weight.toFixed(1)}kg`;
                
                let successMsg;
                if (harvestType === 'weight-only') {
                    successMsg = `üçÖ Recorded harvest of ${weightMsg} ${cropName} produce (plants remain in bed)!`;
                } else {
                    successMsg = `ü•¨ Recorded harvest of ${weightMsg} from ${plantCount} ${cropName} plants!`;
                }
                
                this.showNotification(successMsg, 'success');
                
                // Close modal
                const harvestModal = document.getElementById('quick-harvest-modal');
                if (harvestModal) {
                    harvestModal.remove();
                } else if (window.errorManager) {
                    window.errorManager.warnOnce('quick_harvest_modal_missing', 'Quick harvest modal not found for removal', 'harvest');
                }
                
                // Refresh data and ensure bed overview stays visible
                await this.loadDataRecords();
                await this.updatePlantOverview();
                this.updateGrowBeds();
                this.updatePlantGrowthHistoryDisplay();
                this.updateRemainingPlantsDisplay();
                
                // Ensure plant overview tab is active and bed overview is visible
                const overviewTab = document.getElementById('plant-overview-tab');
                if (overviewTab) {
                    overviewTab.click();
                }
                
                // Refresh the bed overview specifically
                setTimeout(() => {
                    this.updateGrowBeds();
                    // Force refresh of the bed overview display
                    const bedOverview = document.querySelector('.grow-beds-overview');
                    if (bedOverview) {
                        bedOverview.style.display = 'block';
                    }
                }, 100);
                
            } else {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to record harvest');
            }
            
        } catch (error) {
            console.error('Error submitting harvest:', error);
            this.showNotification('Error recording harvest', 'error');
        }
    }

    showBedDetails(bedId) {
        
        try {
            // First ensure we're in the Plants view
            const plantsView = document.getElementById('plants');
            if (plantsView && !plantsView.classList.contains('active')) {
                const plantsNavBtn = document.querySelector('[data-view="plants"]') || document.getElementById('plants-btn');
                if (plantsNavBtn) {
                    plantsNavBtn.click();
                }
            }
            
            // Then click the Plant Overview tab to show bed details
            const overviewTab = document.getElementById('plant-overview-tab');
            if (overviewTab) {
                overviewTab.click();
            } else {
                console.error('‚ùå Plant Overview tab not found');
            }
            
            // Show notification about the bed
            const bed = this.allGrowBeds?.find(b => b.id == bedId);
            const bedName = bed?.bed_name || `Bed ${bed?.bed_number || bedId}`;
            
            this.showNotification(`üìã Viewing details for ${bedName}. Check the grow bed summary and plant batches in the overview.`, 'info');
            
            // Scroll to bed details after a moment
            setTimeout(() => {
                const bedOverview = document.querySelector('.grow-beds-overview') || 
                                 document.querySelector('.plant-overview-section');
                if (bedOverview) {
                    bedOverview.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 300);
            
        } catch (error) {
            console.error('‚ùå Error in showBedDetails:', error);
            this.showNotification('Error showing bed details', 'error');
        }
    }

    getTankSpecificFishData(tankNumber, latestFishData) {
        // If we have fish health data, check if it's specific to this tank
        if (!latestFishData) return null;

        // Check if the fish health data is specifically for this tank
        if (latestFishData.fish_tank_id && latestFishData.fish_tank_id === tankNumber) {

            return latestFishData;
        }
        
        // If no specific tank ID is set, assume it's for tank 1 (legacy data)
        if (!latestFishData.fish_tank_id && tankNumber === 1) {

            return latestFishData;
        }
        
        // For all other cases, this tank has no fish

        return null;
    }

    calculateDailyFeedAmount(fishCount, avgWeightGrams, fishType) {
        if (fishCount === 0 || avgWeightGrams === 0) return 0;
        
        // Feed rate as percentage of body weight per day
        const feedRates = {
            'tilapia': this.getTilapiaFeedRate(avgWeightGrams),
            'trout': this.getTroutFeedRate(avgWeightGrams),
            'catfish': this.getCatfishFeedRate(avgWeightGrams),
            'default': 0.025 // 2.5% default
        };
        
        const feedRate = feedRates[fishType?.toLowerCase()] || feedRates.default;
        const totalBiomassGrams = fishCount * avgWeightGrams;
        const dailyFeedGrams = totalBiomassGrams * feedRate;
        
        return Math.round(dailyFeedGrams);
    }

    getTilapiaFeedRate(weightGrams) {
        // Tilapia feed rates based on size
        if (weightGrams < 50) return 0.08;      // 8% for fry
        if (weightGrams < 100) return 0.06;     // 6% for juveniles
        if (weightGrams < 250) return 0.04;     // 4% for growing
        return 0.025;                           // 2.5% for adults
    }

    getTroutFeedRate(weightGrams) {
        // Trout feed rates based on size
        if (weightGrams < 30) return 0.10;      // 10% for fry
        if (weightGrams < 80) return 0.07;      // 7% for juveniles
        if (weightGrams < 200) return 0.04;     // 4% for growing
        return 0.02;                            // 2% for adults
    }

    getCatfishFeedRate(weightGrams) {
        // Catfish feed rates based on size
        if (weightGrams < 100) return 0.07;     // 7% for juveniles
        if (weightGrams < 300) return 0.04;     // 4% for growing
        return 0.025;                           // 2.5% for adults
    }

    async initializeFishDensityChart() {
        const canvas = document.getElementById('fish-density-chart');
        if (!canvas) {
            console.log('‚ö†Ô∏è Fish density canvas not found - skipping chart initialization');
            return;
        }

        // Check if canvas already has a chart instance
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
            console.log('‚ö†Ô∏è Canvas already in use, destroying existing chart first');
            existingChart.destroy();
        }

        // Prevent multiple simultaneous initializations
        if (this.fishDensityChartInitializing) {
            console.log('‚ö†Ô∏è Chart initialization already in progress - skipping');
            return;
        }
        this.fishDensityChartInitializing = true;

        try {
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (this.fishDensityChart) {
                this.fishDensityChart.destroy();
                this.fishDensityChart = null;
            }
        
        const systemConfig = this.loadSystemConfig();
        const fishVolumeM3 = (systemConfig?.total_fish_volume || 1000) / 1000;
        
        // Try to get fish inventory data first (same as card uses)
        let densityData = [];
        try {
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`);
            
            if (fishInventoryData && fishInventoryData.tanks && fishInventoryData.tanks.length > 0) {
                // Use fish inventory data (comprehensive data across all tanks)
                
                // Create a single data point representing current system density
                const totalFish = fishInventoryData.tanks.reduce((sum, tank) => sum + (parseInt(tank.current_count) || 0), 0);
                const totalBiomass = fishInventoryData.tanks.reduce((sum, tank) => sum + (parseFloat(tank.biomass_kg) || 0), 0);
                
                if (totalFish > 0 && totalBiomass > 0) {
                    const density = fishVolumeM3 > 0 ? totalBiomass / fishVolumeM3 : 0;
                    densityData = [{ date: 'Current', density: density, source: 'inventory' }];
                }
            }
        } catch (error) {
        }
        
        // Fall back to fish health data if no inventory data
        if (densityData.length === 0) {
            const fishHealthData = this.dataRecords?.fishHealth || [];
            
            // Filter to only include entries with valid weight data
            const validHealthData = fishHealthData.filter(entry => 
                entry.average_weight !== null && entry.average_weight > 0 && entry.count > 0
            );
            
            densityData = validHealthData.map(entry => {
                const totalWeight = (entry.count * entry.average_weight) / 1000; // Convert to kg
                const density = fishVolumeM3 > 0 ? totalWeight / fishVolumeM3 : 0;
                return { date: entry.date, density: density, source: 'health' };
            }).reverse(); // Reverse to show chronological order
        }
        
        // If no density data available, show a message instead of empty chart
        if (densityData.length === 0) {
            
            // Create a simple message chart
            this.fishDensityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data Available'],
                    datasets: [{
                        label: 'Fish Density (kg/m¬≥)',
                        data: [0],
                        borderColor: '#7BAAEE',
                        backgroundColor: '#7BAAEE20',
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Fish weight data needed for density calculation',
                            color: '#666',
                            font: { size: 12 }
                        },
                        legend: { display: false }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            display: true,
                            title: { display: true, text: 'Density (kg/m¬≥)' },
                            ticks: { display: false }
                        },
                        x: { 
                            display: true,
                            ticks: { display: false }
                        }
                    }
                }
            });
            return;
        }
        
        // Prepare chart data from unified density data
        const chartData = densityData.map(entry => entry.density);
        const labels = densityData.map(entry => {
            if (entry.date === 'Current') {
                return 'Current';
            }
            return this.formatDateDDMMYYYY(new Date(entry.date));
        });

        // Create and store chart instance
        this.fishDensityChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Fish Density (kg/m¬≥)',
                    data: chartData,
                    borderColor: '#7BAAEE',
                    backgroundColor: '#7BAAEE20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Density (kg/m¬≥)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `Density: ${context.parsed.y.toFixed(2)} kg/m¬≥`;
                            }
                        }
                    }
                }
            }
        });
        
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('fish_density_chart_failed', 'Error initializing fish density chart', this.activeSystemId);
            } else {
                console.error('üêü Error initializing fish density chart:', error);
            }
        } finally {
            // Reset initialization flag
            this.fishDensityChartInitializing = false;
        }
    }

    generateMonthlyComparison() {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth();
        const currentYear = currentDate.getFullYear();
        
        // Calculate current month and previous month date ranges
        const currentMonthStart = new Date(currentYear, currentMonth, 1);
        const currentMonthEnd = new Date(currentYear, currentMonth + 1, 0);
        const previousMonthStart = new Date(currentYear, currentMonth - 1, 1);
        const previousMonthEnd = new Date(currentYear, currentMonth, 0);
        
        // Calculate feed consumption
        const feedComparison = this.calculateFeedComparison(currentMonthStart, currentMonthEnd, previousMonthStart, previousMonthEnd);
        
        // Calculate harvest amounts
        const harvestComparison = this.calculateHarvestComparison(currentMonthStart, currentMonthEnd, previousMonthStart, previousMonthEnd);
        
        return `
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h5><img src="/icons/new-icons/Afraponix Go Icons_feeding.svg" alt="Feed" class="heading-icon" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.25em;"> Feed Consumption</h5>
                    <div class="current-stat">This Month: ${feedComparison.current}g</div>
                    <div class="previous-stat">Last Month: ${feedComparison.previous}g</div>
                    <div class="comparison-change ${feedComparison.trend}">
                        ${feedComparison.change}
                    </div>
                </div>
                
                <div class="comparison-card">
                    <h5><img src="/icons/new-icons/Afraponix Go Icons_harvest.svg" alt="Harvest" class="heading-icon" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.25em;"> Plant Harvest</h5>
                    <div class="current-stat">This Month: ${harvestComparison.current}kg</div>
                    <div class="previous-stat">Last Month: ${harvestComparison.previous}kg</div>
                    <div class="comparison-change ${harvestComparison.trend}">
                        ${harvestComparison.change}
                    </div>
                </div>
            </div>
        `;
    }

    calculateFeedComparison(currentStart, currentEnd, previousStart, previousEnd) {
        const fishHealthData = this.dataRecords?.fishHealth || [];
        
        // Calculate total feed consumption for current month
        const currentMonthData = fishHealthData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate >= currentStart && entryDate <= currentEnd;
        });
        
        const currentFeed = currentMonthData.reduce((total, entry) => {
            return total + (entry.feed_consumption || 0);
        }, 0);
        
        // Calculate total feed consumption for previous month
        const previousMonthData = fishHealthData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate >= previousStart && entryDate <= previousEnd;
        });
        
        const previousFeed = previousMonthData.reduce((total, entry) => {
            return total + (entry.feed_consumption || 0);
        }, 0);
        
        // Calculate change and trend
        const change = currentFeed - previousFeed;
        const percentChange = previousFeed > 0 ? ((change / previousFeed) * 100).toFixed(1) : 0;
        const trend = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
        const changeText = change === 0 ? 'No change' : 
                          `${change > 0 ? '+' : ''}${change}g (${percentChange}%)`;
        
        return {
            current: currentFeed.toFixed(0),
            previous: previousFeed.toFixed(0),
            change: changeText,
            trend
        };
    }

    calculateHarvestComparison(currentStart, currentEnd, previousStart, previousEnd) {
        const plantData = this.dataRecords.plantGrowth || [];
        
        // Calculate total harvest for current month
        const currentMonthData = plantData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate >= currentStart && entryDate <= currentEnd;
        });
        
        const currentHarvest = currentMonthData.reduce((total, entry) => {
            return total + (entry.harvest_weight || 0);
        }, 0);
        
        // Calculate total harvest for previous month
        const previousMonthData = plantData.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate >= previousStart && entryDate <= previousEnd;
        });
        
        const previousHarvest = previousMonthData.reduce((total, entry) => {
            return total + (entry.harvest_weight || 0);
        }, 0);
        
        // Calculate change and trend (convert grams to kg)
        const currentKg = currentHarvest / 1000;
        const previousKg = previousHarvest / 1000;
        const change = currentKg - previousKg;
        const percentChange = previousKg > 0 ? ((change / previousKg) * 100).toFixed(1) : 0;
        const trend = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
        const changeText = change === 0 ? 'No change' : 
                          `${change > 0 ? '+' : ''}${change.toFixed(1)}kg (${percentChange}%)`;
        
        return {
            current: currentKg.toFixed(1),
            previous: previousKg.toFixed(1),
            change: changeText,
            trend
        };
    }

    setupDataEditTabs() {
        console.log('üîß Setting up Data Editing tabs...');
        const editTabs = document.querySelectorAll('.edit-tab');
        const contents = document.querySelectorAll('.edit-content');

        editTabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                const targetContent = tab.getAttribute('data-target') || tab.id.replace('-tab', '-content');
                console.log('üìû Data Editing tab clicked:', targetContent);

                // Remove active states
                editTabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active states
                tab.classList.add('active');
                const targetElement = document.getElementById(targetContent);
                if (targetElement) {
                    targetElement.classList.add('active');
                }

                // Load data for specific tabs
                if (targetContent === 'edit-water-quality-content') {
                    console.log('üì° Loading loadDataEditInterface...');
                    await this.loadDataEditInterface('water-quality');
                }
                else if (targetContent === 'edit-fish-health-content') {
                    console.log('üì° Loading loadDataEditInterface...');
                    await this.loadDataEditInterface('fish-health');
                }
                else if (targetContent === 'edit-operations-content') {
                    console.log('üì° Loading loadDataEditInterface...');
                    await this.loadDataEditInterface('operations');
                }

                // Legacy support for existing data-category implementation
                const category = tab.dataset.category;
                if (category) {
                    await this.loadDataEditInterface(category);
                }
            });
        });
        
        // Load initial interface
        this.loadDataEditInterface('water-quality');
    }

    loadDataEditInterface(category) {
        const container = document.getElementById('data-edit-container');
        if (!this.activeSystemId) {
            container.innerHTML = '<div class="no-data-edit-message">Please select a system to edit data.</div>';
            return;
        }

        let data = [];
        let categoryName = '';
        
        switch(category) {
            case 'water-quality':
                data = this.dataRecords.waterQuality || [];
                categoryName = 'Water Quality';
                break;
            case 'fish-health':
                data = []; // TODO: Load fish events data
                categoryName = 'Fish Events';
                break;
            case 'plant-growth':
                data = this.dataRecords.plantGrowth || [];
                categoryName = 'Plant Growth';
                break;
            case 'operations':
                data = this.dataRecords.operations || [];
                categoryName = 'Operations';
                break;
        }

        if (data.length === 0) {
            container.innerHTML = `
                <div class="no-data-edit-message">
                    No ${categoryName.toLowerCase()} data entries to edit yet.
                </div>
            `;
            return;
        }

        const itemsHtml = data.slice(0, 20).map((item, index) => `
            <div class="edit-data-item" data-category="${category}" data-id="${item.id}" data-index="${index}">
                <div class="edit-item-header">
                    <div class="edit-item-date">${this.formatEntryDate(item.date)}</div>
                    <div class="edit-item-actions">
                        <button class="edit-btn" onclick="app.editDataEntry('${category}', ${item.id}, ${index})">Edit</button>
                        <button class="delete-btn" onclick="app.deleteDataEntry('${category}', ${item.id})">Delete</button>
                    </div>
                </div>
                <div class="edit-item-content">
                    ${this.formatDataEntryForEdit(category, item)}
                </div>
            </div>
        `).join('');

        container.innerHTML = `
            <div class="data-edit-list">
                ${itemsHtml}
            </div>
        `;
    }

    formatDataEntryForEdit(category, item) {
        switch(category) {
            case 'water-quality':
                return this.formatWaterQualityEntry(item);
            case 'fish-health':
                return this.formatFishHealthEntry(item);
            case 'plant-growth':
                return this.formatPlantGrowthEntry(item);
            case 'operations':
                return this.formatOperationsEntry(item);
            default:
                return 'Unknown data format';
        }
    }

    async editDataEntry(category, id, index) {
        const data = this.getDataByCategory(category);
        const item = data.find(d => d.id === id);
        if (!item) return;

        const formHtml = this.generateEditForm(category, item);
        const itemElement = document.querySelector(`[data-id="${id}"]`);
        
        // Replace content with edit form
        itemElement.innerHTML = `
            <div class="edit-item-header">
                <div class="edit-item-date">${this.formatEntryDate(item.date)}</div>
                <div class="edit-item-actions">
                    <span style="color: #666; font-size: 0.8rem;">Editing...</span>
                </div>
            </div>
            ${formHtml}
        `;
    }

    generateEditForm(category, item) {
        return this.formGenerator.generateEditForm(category, item);
    }

    generateWaterQualityEditForm(item) {
        return this.formGenerator.generateWaterQualityEditForm(item);
    }

    _originalGenerateWaterQualityEditForm(item) {
        return `
            <div class="edit-form">
                <div class="edit-form-grid">
                    <div class="form-field">
                        <label>Date & Time:</label>
                        <input type="datetime-local" id="edit-date" value="${item.date.slice(0, 16)}">
                    </div>
                    <div class="form-field">
                        <label>pH Level:</label>
                        <input type="number" id="edit-ph" value="${item.ph || ''}" step="0.1">
                    </div>
                    <div class="form-field">
                        <label>Temperature (¬∞C):</label>
                        <input type="number" id="edit-temperature" value="${item.temperature || ''}" step="0.1">
                    </div>
                    <div class="form-field">
                        <label>Dissolved Oxygen (mg/L):</label>
                        <input type="number" id="edit-dissolved-oxygen" value="${item.dissolved_oxygen || ''}" step="0.1">
                    </div>
                    <div class="form-field">
                        <label>EC/TDS (ppm):</label>
                        <input type="number" id="edit-ec" value="${item.ec || ''}" step="10">
                    </div>
                    <div class="form-field">
                        <label>Ammonia (ppm):</label>
                        <input type="number" id="edit-ammonia" value="${item.ammonia || ''}" step="0.01">
                    </div>
                    <div class="form-field">
                        <label>Nitrite (ppm):</label>
                        <input type="number" id="edit-nitrite" value="${item.nitrite || ''}" step="0.01">
                    </div>
                    <div class="form-field">
                        <label>Nitrate (ppm):</label>
                        <input type="number" id="edit-nitrate" value="${item.nitrate || ''}" step="0.1">
                    </div>
                </div>
                <div class="edit-form-actions">
                    <button class="save-btn" onclick="app.saveDataEdit('water-quality', ${item.id})">Save Changes</button>
                    <button class="cancel-btn" onclick="app.cancelDataEdit('water-quality')">Cancel</button>
                </div>
            </div>
        `;
    }

    generateFishHealthEditForm(item) {
        return this.formGenerator.generateFishHealthEditForm(item);
    }

    _originalGenerateFishHealthEditForm(item) {
        const systemConfig = this.loadSystemConfig();
        let tankOptions = '';
        for (let i = 1; i <= (systemConfig.fish_tank_count || 1); i++) {
            const selected = item.fish_tank_id === i ? 'selected' : '';
            tankOptions += `<option value="${i}" ${selected}>Tank ${i}</option>`;
        }

        return `
            <div class="edit-form">
                <div class="edit-form-grid">
                    <div class="form-field">
                        <label>Date & Time:</label>
                        <input type="datetime-local" id="edit-date" value="${item.date.slice(0, 16)}">
                    </div>
                    <div class="form-field">
                        <label>Fish Tank:</label>
                        <select id="edit-fish-tank">${tankOptions}</select>
                    </div>
                    <div class="form-field">
                        <label>Fish Count:</label>
                        <input type="number" id="edit-count" value="${item.count || ''}" min="0">
                    </div>
                    <div class="form-field">
                        <label>Mortality:</label>
                        <input type="number" id="edit-mortality" value="${item.mortality || ''}" min="0">
                    </div>
                    <div class="form-field">
                        <label>Average Weight (g):</label>
                        <input type="number" id="edit-weight" value="${item.average_weight || ''}" step="0.1">
                    </div>
                    <div class="form-field">
                        <label>Feed Consumption (g):</label>
                        <input type="number" id="edit-feed" value="${item.feed_consumption || ''}" step="0.1">
                    </div>
                    <div class="form-field">
                        <label>Behavior:</label>
                        <select id="edit-behavior">
                            <option value="normal" ${item.behavior === 'normal' ? 'selected' : ''}>Normal</option>
                            <option value="active" ${item.behavior === 'active' ? 'selected' : ''}>Active</option>
                            <option value="lethargic" ${item.behavior === 'lethargic' ? 'selected' : ''}>Lethargic</option>
                            <option value="aggressive" ${item.behavior === 'aggressive' ? 'selected' : ''}>Aggressive</option>
                        </select>
                    </div>
                </div>
                <div class="edit-form-actions">
                    <button class="save-btn" onclick="app.saveDataEdit('fish-health', ${item.id})">Save Changes</button>
                    <button class="cancel-btn" onclick="app.cancelDataEdit('fish-health')">Cancel</button>
                </div>
            </div>
        `;
    }

    getDataByCategory(category) {
        switch(category) {
            case 'water-quality': return this.dataRecords.waterQuality;
            case 'fish-health': return []; // TODO: Return fish events data
            case 'plant-growth': return this.dataRecords.plantGrowth;
            case 'operations': return this.dataRecords.operations;
            default: return [];
        }
    }

    async saveDataEdit(category, id) {
        // Collect form data
        const formData = this.collectEditFormData(category);
        
        try {
            const endpoint = this.getCategoryEndpoint(category);
            await this.makeApiCall(`${endpoint}/${this.activeSystemId}/${id}`, {
                method: 'PUT',
                body: JSON.stringify(formData)
            });
            
            // Reload data
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            
            // Refresh the edit interface
            const activeTab = document.querySelector('.edit-tab.active');
            this.loadDataEditInterface(activeTab.dataset.category);
            
            this.showNotification(`‚úÖ ${category.replace('-', ' ')} data updated successfully!`, 'success');
        } catch (error) {
            console.error('Failed to save data edit:', error);
            this.showNotification('‚ùå Failed to save changes. Please try again.', 'error');
        }
    }

    collectEditFormData(category) {
        // Collect edit form data with defensive checks
        const editDateEl = document.getElementById('edit-date');
        if (!editDateEl) {
            if (window.errorManager) {
                window.errorManager.warnOnce('edit_date_missing', 'Edit date field not found', category);
            } else {
                console.warn('Edit date field not found');
            }
            return null;
        }

        const data = {
            date: editDateEl.value
        };

        switch(category) {
            case 'water-quality':
                // Water quality form elements with defensive access
                const wqElements = {
                    'edit-ph': (val) => parseFloat(val) || null,
                    'edit-temperature': (val) => parseFloat(val) || null,
                    'edit-dissolved-oxygen': (val) => parseFloat(val) || null,
                    'edit-ec': (val) => parseFloat(val) || null,
                    'edit-ammonia': (val) => parseFloat(val) || null,
                    'edit-nitrite': (val) => parseFloat(val) || null,
                    'edit-nitrate': (val) => parseFloat(val) || null
                };
                
                Object.keys(wqElements).forEach(elementId => {
                    const element = document.getElementById(elementId);
                    const fieldName = elementId.replace('edit-', '').replace('-', '_');
                    if (element) {
                        data[fieldName] = wqElements[elementId](element.value);
                    } else {
                        if (window.errorManager) {
                            window.errorManager.warnOnce(`${elementId}_missing`, `Edit form field ${elementId} not found`, 'water-quality-edit');
                        }
                        data[fieldName] = null;
                    }
                });
                break;
                
            case 'fish-health':
                // Fish health form elements with defensive access
                const fishElements = {
                    'edit-fish-tank': (val) => parseInt(val),
                    'edit-count': (val) => parseInt(val) || null,
                    'edit-mortality': (val) => parseInt(val) || null,
                    'edit-weight': (val) => parseFloat(val) || null,
                    'edit-feed': (val) => parseFloat(val) || null,
                    'edit-behavior': (val) => val
                };
                
                Object.keys(fishElements).forEach(elementId => {
                    const element = document.getElementById(elementId);
                    const fieldName = elementId.replace('edit-', '').replace('fish-tank', 'fish_tank_id')
                                                 .replace('weight', 'average_weight')
                                                 .replace('feed', 'feed_consumption');
                    if (element) {
                        data[fieldName] = fishElements[elementId](element.value);
                    } else {
                        if (window.errorManager) {
                            window.errorManager.warnOnce(`${elementId}_missing`, `Edit form field ${elementId} not found`, 'fish-health-edit');
                        }
                        // Set appropriate defaults for required fields
                        if (elementId === 'edit-fish-tank') data.fish_tank_id = null;
                        else if (elementId === 'edit-behavior') data.behavior = '';
                        else data[fieldName] = null;
                    }
                });
                break;
        }

        return data;
    }

    getCategoryEndpoint(category) {
        const endpoints = {
            'water-quality': '/data/water-quality',
            'fish-inventory': '/fish-inventory',
            'plant-growth': '/data/plant-growth',
            'operations': '/data/operations'
        };
        return endpoints[category];
    }

    cancelDataEdit(category) {
        // Refresh the current tab to cancel editing
        this.loadDataEditInterface(category);
    }

    async deleteDataEntry(category, id) {
        if (!confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
            return;
        }

        try {
            const endpoint = this.getCategoryEndpoint(category);
            await this.makeApiCall(`${endpoint}/${this.activeSystemId}/${id}`, {
                method: 'DELETE'
            });
            
            // Reload data
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            
            // Refresh the edit interface
            const activeTab = document.querySelector('.edit-tab.active');
            this.loadDataEditInterface(activeTab.dataset.category);
            
            this.showNotification(`${category.replace('-', ' ')} entry deleted successfully!`, 'success');
        } catch (error) {
            console.error('Failed to delete data entry:', error);
            this.showNotification('‚ùå Failed to delete entry. Please try again.', 'error');
        }
    }

    async updatePlantManagement() {
        // Only update plant overview if the overview tab is active
        const overviewTab = document.getElementById('plant-overview-tab');
        const overviewContent = document.getElementById('plant-overview-content');
        
        if (overviewTab && overviewTab.classList.contains('active') && overviewContent && overviewContent.classList.contains('active')) {
            await this.updatePlantOverview();
        }
        
        this.updateGrowBeds();
        this.updatePlantGrowthHistoryDisplay();
        this.updatePlantRecommendations();
        this.updateRecentPlantEntries();
    }

    async updatePlantNutrientData() {
        try {
            const plantData = this.dataRecords.plantGrowth || [];
            const crops = this.getCurrentCrops(plantData);
            
            // Get the most recent value for each nutrient (may come from different entries)
            const recentNutrients = await this.getLatestNutrientValues();
        
        // Update plant nutrient displays with latest readings and status indicators
        this.updateNutrientStatus('nitrate', recentNutrients.nitrate.value, this.analyzeNitrate(recentNutrients.nitrate.value, crops), recentNutrients.nitrate.source);
        this.updateNutrientStatus('phosphorus', recentNutrients.phosphorus.value, await this.analyzePhosphorus(recentNutrients.phosphorus.value, crops), recentNutrients.phosphorus.source);
        this.updateNutrientStatus('potassium', recentNutrients.potassium.value, await this.analyzePotassium(recentNutrients.potassium.value, crops), recentNutrients.potassium.source);
        this.updateNutrientStatus('iron', recentNutrients.iron.value, await this.analyzeIron(recentNutrients.iron.value, crops), recentNutrients.iron.source);
        this.updateNutrientStatus('calcium', recentNutrients.calcium.value, await this.analyzeCalcium(recentNutrients.calcium.value, crops), recentNutrients.calcium.source);
        this.updateNutrientStatus('ec', recentNutrients.ec?.value, this.analyzeEC(recentNutrients.ec?.value, crops), recentNutrients.ec?.source);
        this.updateNutrientStatus('ph', recentNutrients.ph.value, await this.analyzePH(recentNutrients.ph.value, crops), recentNutrients.ph.source);
        this.updateNutrientStatus('humidity', recentNutrients.humidity.value, this.analyzeHumidity(recentNutrients.humidity.value, crops), recentNutrients.humidity.source);
        this.updateNutrientStatus('salinity', recentNutrients.salinity.value, this.analyzeSalinity(recentNutrients.salinity.value, crops), recentNutrients.salinity.source);
        
        // Update nutrient charts
        await this.updateNutrientCharts();
        
            // Update nutrient recommendations
            this.updateNutrientRecommendations();
            
        } catch (error) {
            console.error('Error in updatePlantNutrientData:', error);
            // Set default "No data" values for all nutrients
            ['nitrate', 'phosphorus', 'potassium', 'iron', 'calcium', 'ec', 'ph', 'humidity', 'salinity'].forEach(nutrient => {
                const valueElement = document.getElementById(`plant-${nutrient}`);
                const timestampElement = document.getElementById(`plant-${nutrient}-chart-timestamp`);
                const statusElement = document.getElementById(`${nutrient}-status-text`);
                
                if (valueElement) valueElement.textContent = 'No data';
                if (timestampElement) timestampElement.textContent = 'Last updated: No data available';
                if (statusElement) statusElement.textContent = 'No data';
            });
        }
    }

    async getLatestNutrientValues() {
        return this.waterQuality.getLatestNutrientValues();
    }

    getDefaultNutrientValues() {
        return this.waterQuality.getDefaultNutrientValues();
    }

    updateNutrientStatus(nutrientName, value, analysis, source = null) {
        return this.waterQuality.updateNutrientStatus(nutrientName, value, analysis, source);
    }

    updateRecentPlantEntries() {

        try {
            this.updateRecentPlantEntry();
            this.updateRecentHarvestEntry();

        } catch (error) {
            console.error('‚ùå Error updating recent plant entries:', error);
        }
    }

    updateRecentPlantEntry() {

        const container = document.getElementById('recent-plant-entry');
        if (!container) {

            return;
        }

        const latestPlantData = this.getLatestPlantData('planting');

        if (!latestPlantData) {
            container.innerHTML = `
                <div class="no-data-message">
                    <h5>Recent Planting/Transplant</h5>
                    <p>No planting data available. Record your first planting above.</p>
                </div>
            `;
            return;
        }

        const entryDate = new Date(latestPlantData.date);
        const formattedDate = this.formatDateDDMMYYYY(entryDate) + ' ' + entryDate.toLocaleTimeString();

        container.innerHTML = `
            <div class="plant-entry">
                <div class="entry-header">
                    <div class="entry-title">
                        <h5>Latest Planting - ${formattedDate}</h5>
                        <span class="status-badge latest">LATEST PLANTING</span>
                    </div>
                    <div class="entry-actions">
                        <button class="edit-btn" onclick="app.editPlantEntry(${latestPlantData.id})">${SVGIcons.getIcon('edit', 'btn-icon-svg')}Edit</button>
                        <button class="delete-btn" onclick="app.deletePlantEntry(${latestPlantData.id})">${SVGIcons.getIcon('delete', 'btn-icon-svg')}Delete</button>
                    </div>
                </div>
                <div class="entry-data">
                    <div class="data-grid">
                        <div class="data-item">
                            <span class="data-label">Crop Type:</span>
                            <span class="data-value">${latestPlantData.crop_type || 'Not specified'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Plants Added:</span>
                            <span class="data-value">${latestPlantData.new_seedlings || latestPlantData.count || 0}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Growth Stage:</span>
                            <span class="data-value">${latestPlantData.growth_stage || 'Not specified'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Grow Bed:</span>
                            <span class="data-value">Bed ${latestPlantData.grow_bed_id || 'Not specified'}</span>
                        </div>
                        ${latestPlantData.notes ? `
                        <div class="data-item notes">
                            <span class="data-label">Notes:</span>
                            <span class="data-value">${latestPlantData.notes}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    updateRecentHarvestEntry() {

        const container = document.getElementById('recent-harvest-entry');
        if (!container) {

            return;
        }

        const latestHarvestData = this.getLatestPlantData('harvest');

        if (!latestHarvestData) {
            container.innerHTML = `
                <div class="no-data-message">
                    <h5>Recent Harvest</h5>
                    <p>No harvest data available. Record your first harvest above.</p>
                </div>
            `;
            return;
        }

        const entryDate = new Date(latestHarvestData.date);
        const formattedDate = this.formatDateDDMMYYYY(entryDate) + ' ' + entryDate.toLocaleTimeString();

        container.innerHTML = `
            <div class="plant-entry">
                <div class="entry-header">
                    <div class="entry-title">
                        <h5>Latest Harvest - ${formattedDate}</h5>
                        <span class="status-badge harvest">LATEST HARVEST</span>
                    </div>
                    <div class="entry-actions">
                        <button class="edit-btn" onclick="app.editPlantEntry(${latestHarvestData.id})">${SVGIcons.getIcon('edit', 'btn-icon-svg')}Edit</button>
                        <button class="delete-btn" onclick="app.deletePlantEntry(${latestHarvestData.id})">${SVGIcons.getIcon('delete', 'btn-icon-svg')}Delete</button>
                    </div>
                </div>
                <div class="entry-data">
                    <div class="data-grid">
                        <div class="data-item">
                            <span class="data-label">Crop Type:</span>
                            <span class="data-value">${latestHarvestData.crop_type || 'Not specified'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Plants Harvested:</span>
                            <span class="data-value">${latestHarvestData.plants_harvested || 0}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Harvest Weight:</span>
                            <span class="data-value">${latestHarvestData.harvest_weight ? (latestHarvestData.harvest_weight/1000).toFixed(1) + ' kg' : 'Not recorded'}</span>
                        </div>
                        <div class="data-item">
                            <span class="data-label">Grow Bed:</span>
                            <span class="data-value">Bed ${latestHarvestData.grow_bed_id || 'Not specified'}</span>
                        </div>
                        ${latestHarvestData.notes ? `
                        <div class="data-item notes">
                            <span class="data-label">Notes:</span>
                            <span class="data-value">${latestHarvestData.notes}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    getLatestPlantData(type) {

        if (!this.dataRecords.plantGrowth || this.dataRecords.plantGrowth.length === 0) {

            return null;
        }

        // Filter by type: planting entries have new_seedlings > 0, harvest entries have plants_harvested > 0
        const filteredData = this.dataRecords.plantGrowth.filter(entry => {
            if (type === 'planting') {
                return entry.new_seedlings > 0;
            } else if (type === 'harvest') {
                return entry.plants_harvested > 0;
            }
            return false;
        });

        if (filteredData.length === 0) {

            return null;
        }

        // Return the most recent entry (data is ordered DESC by date)
        const latestEntry = filteredData[0];

        return latestEntry;
    }

    async editPlantEntry(entryId) {
        try {
            // Find the plant entry in the current data records
            const plantData = this.dataRecords.plantGrowth || [];
            const plantEntry = plantData.find(entry => entry.id == entryId);

            if (!plantEntry) {
                this.showNotification('‚ùå Plant entry not found', 'error');
                return;
            }

            // Show the edit modal for plant entries
            this.showPlantEditModal(plantEntry);
            
        } catch (error) {
            console.error('Error loading plant entry for edit:', error);
            this.showNotification('‚ùå Failed to load plant entry', 'error');
        }
    }

    async showPlantEditModal(plantEntry) {
        // Remove existing modal if any
        const existingModal = document.getElementById('plant-edit-modal');
        if (existingModal) {
            existingModal.remove();
        }

        // Get grow bed options
        const growBedOptions = await this.generateGrowBedOptions(plantEntry.grow_bed_id);

        // Create modal HTML
        const modalHtml = `
            <div id="plant-edit-modal" class="modal-overlay">
                <div class="modal-content plant-edit-modal">
                    <div class="modal-header">
                        <h3>Edit Plant Entry</h3>
                        <button class="modal-close" onclick="document.getElementById('plant-edit-modal').remove()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <form id="plant-edit-form">
                            <div class="form-group">
                                <label for="edit-date">Date & Time</label>
                                <input type="datetime-local" id="edit-date" name="date" value="${this.formatDateTimeForInput(plantEntry.date)}" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="edit-grow-bed">Grow Bed</label>
                                <select id="edit-grow-bed" name="grow_bed_id" required>
                                    ${growBedOptions}
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="edit-crop-type">Crop Type</label>
                                <input type="text" id="edit-crop-type" name="crop_type" value="${plantEntry.crop_type || ''}" required>
                            </div>
                            
                            ${plantEntry.new_seedlings ? `
                                <div class="form-group">
                                    <label for="edit-new-seedlings">New Seedlings</label>
                                    <input type="number" id="edit-new-seedlings" name="new_seedlings" value="${plantEntry.new_seedlings || 0}" min="0">
                                </div>
                            ` : ''}
                            
                            ${plantEntry.plants_harvested ? `
                                <div class="form-group">
                                    <label for="edit-plants-harvested">Plants Harvested</label>
                                    <input type="number" id="edit-plants-harvested" name="plants_harvested" value="${plantEntry.plants_harvested || 0}" min="0">
                                </div>
                                
                                <div class="form-group">
                                    <label for="edit-harvest-weight">Harvest Weight (kg)</label>
                                    <input type="number" id="edit-harvest-weight" name="harvest_weight" value="${(plantEntry.harvest_weight || 0) / 1000}" step="0.01" min="0">
                                </div>
                            ` : ''}
                            
                            <div class="form-group">
                                <label for="edit-health">Health Status</label>
                                <select id="edit-health" name="health">
                                    <option value="">Select health status</option>
                                    <option value="excellent" ${plantEntry.health === 'excellent' ? 'selected' : ''}>Excellent</option>
                                    <option value="good" ${plantEntry.health === 'good' ? 'selected' : ''}>Good</option>
                                    <option value="fair" ${plantEntry.health === 'fair' ? 'selected' : ''}>Fair</option>
                                    <option value="poor" ${plantEntry.health === 'poor' ? 'selected' : ''}>Poor</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="edit-notes">Notes</label>
                                <textarea id="edit-notes" name="notes" rows="3">${plantEntry.notes || ''}</textarea>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn-secondary" onclick="document.getElementById('plant-edit-modal').remove()">Cancel</button>
                        <button type="button" class="btn-primary" onclick="app.savePlantEntryEdit(${plantEntry.id})">Save Changes</button>
                    </div>
                </div>
            </div>
        `;

        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal with animation
        setTimeout(() => {
            const modal = document.getElementById('plant-edit-modal');
            if (modal) {
                modal.classList.add('show');
            }
        }, 10);
    }

    formatDateTimeForInput(dateString) {
        // Convert the date string to the format required by datetime-local input
        if (!dateString) return '';
        
        try {
            const date = new Date(dateString);
            // Format as YYYY-MM-DDTHH:MM
            return date.getFullYear() + '-' + 
                   String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                   String(date.getDate()).padStart(2, '0') + 'T' + 
                   String(date.getHours()).padStart(2, '0') + ':' + 
                   String(date.getMinutes()).padStart(2, '0');
        } catch (error) {
            console.error('Error formatting date:', error);
            return '';
        }
    }

    async generateGrowBedOptions(selectedBedId) {
        let growBeds = [];
        
        try {
            // Get grow beds for the current system
            growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
        } catch (error) {

        }

        let options = '<option value="">Select grow bed</option>';
        
        if (growBeds && growBeds.length > 0) {
            growBeds.forEach(bed => {
                const selected = bed.id == selectedBedId ? 'selected' : '';
                options += `<option value="${bed.id}" ${selected}>${bed.bed_name || `Bed ${bed.bed_number}`}</option>`;
            });
        } else {
            // Fallback if no beds loaded
            for (let i = 1; i <= 4; i++) {
                const selected = i == selectedBedId ? 'selected' : '';
                options += `<option value="${i}" ${selected}>Bed ${i}</option>`;
            }
        }
        
        return options;
    }

    async savePlantEntryEdit(entryId) {
        try {
            const form = document.getElementById('plant-edit-form');
            const formData = new FormData(form);
            
            // Convert form data to object
            const updateData = {};
            for (let [key, value] of formData.entries()) {
                updateData[key] = value;
            }

            // Convert harvest weight from kg to grams for storage
            if (updateData.harvest_weight) {
                updateData.harvest_weight = parseFloat(updateData.harvest_weight) * 1000;
            }

            // Update the plant entry via API
            const response = await this.makeApiCall(`/data/plant-growth/${entryId}`, {
                method: 'PUT',
                body: JSON.stringify(updateData)
            });

            if (response) {
                this.showNotification('‚úÖ Plant entry updated successfully', 'success');
                
                // Close modal
                const plantEditModal = document.getElementById('plant-edit-modal');
                if (plantEditModal) {
                    plantEditModal.remove();
                } else if (window.errorManager) {
                    window.errorManager.warnOnce('plant_edit_modal_missing', 'Plant edit modal not found for removal', 'plant-edit');
                }
                
                // Refresh the data and UI comprehensively
                await this.loadDataRecords();
                await this.updateDashboardFromData();
                // Update other plant management components (not overview to avoid double-render)
                this.updateGrowBeds();
                this.updatePlantGrowthHistoryDisplay();
                this.updatePlantRecommendations();
                this.updateRecentPlantEntries();
                await this.updatePlantOverview(); // Force update plant overview to refresh batch data
                this.updateRemainingPlantsDisplay(); // Update remaining plants display
            }

        } catch (error) {
            console.error('Error saving plant entry edit:', error);
            this.showNotification('‚ùå Failed to save changes', 'error');
        }
    }

    async deletePlantEntry(entryId) {
        if (!confirm('Are you sure you want to delete this plant entry? This action cannot be undone.')) {
            return;
        }

        try {
            await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}/${entryId}`, {
                method: 'DELETE'
            });
            
            // Reload data and update displays
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            
            this.showNotification('Plant entry deleted successfully!', 'success');
        } catch (error) {
            console.error('Failed to delete plant entry:', error);
            this.showNotification('‚ùå Failed to delete plant entry. Please try again.', 'error');
        }
    }

    createOrUpdateNutrientChart(canvasId, label, labels, data, color) {
        const ctx = document.getElementById(canvasId);
        if (!ctx) {
            console.error('Canvas not found:', canvasId);
            return;
        }

        // Filter out null/undefined values and their corresponding labels
        const filteredData = [];
        const filteredLabels = [];
        for (let i = 0; i < data.length; i++) {
            if (data[i] !== null && data[i] !== undefined && data[i] !== '' && !isNaN(data[i])) {
                filteredData.push(data[i]);
                filteredLabels.push(labels[i]);
            }
        }

        // Destroy existing chart if it exists
        if (this.chartInstances[canvasId]) {
            this.chartInstances[canvasId].destroy();
        }
        
        this.chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: filteredLabels,
                datasets: [{
                    label: label,
                    data: filteredData,
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    spanGaps: false  // Don't connect lines across null values (shows gaps)
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        display: false
                    },
                    x: {
                        display: false
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                },
                elements: {
                    point: {
                        radius: 0
                    }
                },
                onClick: (event, elements) => {

                    this.chartModal.openDetailModal(canvasId, label, filteredLabels, filteredData, color);
                }
            }
        });
        
        // Add cursor pointer to indicate clickability
        ctx.style.cursor = 'pointer';
        
        // Add direct click handler as fallback
        ctx.addEventListener('click', (e) => {

            this.chartModal.openDetailModal(canvasId, label, filteredLabels, filteredData, color);
        });

    }

    async updateNutrientRecommendations() {
        const container = document.getElementById('nutrient-recommendations-container');
        if (!container) return;

        const latestData = this.getLatestWaterQualityData();
        const plantData = this.dataRecords.plantGrowth || [];
        
        if (!latestData) {
            container.innerHTML = `
                <div class="recommendation-card">
                    <div class="recommendation-header">
                        <span class="recommendation-icon">üìä</span>
                        <span class="recommendation-title">No Data Available</span>
                    </div>
                    <div class="recommendation-content">
                        Add water quality measurements in the Data Entry tab to receive personalized nutrient recommendations.
                    </div>
                </div>
            `;
            return;
        }

        // Get current crops from recent plant data
        const currentCrops = this.getCurrentCrops(plantData);
        const recommendations = await this.generateNutrientRecommendations(latestData, currentCrops);

        container.innerHTML = `
            <div class="nutrient-recommendations-grid">
                ${recommendations.map(rec => this.generateRecommendationCard(rec)).join('')}
            </div>
        `;
    }

    getCurrentCrops(plantData) {
        // Get unique crop types from recent plant data (last 30 days)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const recentPlantData = plantData.filter(entry => 
            new Date(entry.date) >= thirtyDaysAgo && entry.crop_type
        );
        
        const cropTypes = [...new Set(recentPlantData.map(entry => entry.crop_type))];
        return cropTypes.length > 0 ? cropTypes : ['general'];
    }

    async generateNutrientRecommendations(data, crops) {
        const recommendations = [];
        
        // pH Recommendations (highest priority as it affects all nutrient uptake)
        const pHRec = await this.analyzePH(data.ph, crops);
        if (pHRec) recommendations.push(pHRec);
        
        // Nitrogen Recommendations (baseline for ratio calculations)
        const nitrogenRec = await this.analyzeNitrogen(data.nitrogen || data.nitrate, crops, data);
        if (nitrogenRec) recommendations.push(nitrogenRec);
        
        // Ratio-based nutrient recommendations (use nitrogen as baseline)
        const nitrogenLevel = data.nitrogen || data.nitrate || 100; // Default for ratio calculations
        
        // Phosphorus Recommendations
        const phosphorusRec = await this.analyzePhosphorus(data.phosphorus, crops, data, nitrogenLevel);
        if (phosphorusRec) recommendations.push(phosphorusRec);
        
        // Potassium Recommendations
        const potassiumRec = await this.analyzePotassium(data.potassium, crops, data, nitrogenLevel);
        if (potassiumRec) recommendations.push(potassiumRec);
        
        // Iron Recommendations
        const ironRec = await this.analyzeIron(data.iron, crops, data, nitrogenLevel);
        if (ironRec) recommendations.push(ironRec);
        
        // Calcium Recommendations
        const calciumRec = await this.analyzeCalcium(data.calcium, crops, data, nitrogenLevel);
        if (calciumRec) recommendations.push(calciumRec);
        
        // Magnesium Recommendations  
        const magnesiumRec = await this.analyzeMagnesium(data.magnesium, crops, data, nitrogenLevel);
        if (magnesiumRec) recommendations.push(magnesiumRec);
        
        // Overall system recommendation
        const systemRec = this.generateSystemRecommendation(data, crops);
        if (systemRec) recommendations.push(systemRec);
        
        return recommendations;
    }

    async analyzePH(ph, crops) {
        if (!ph) return null;
        
        // Convert to number and validate
        const phValue = parseFloat(ph);
        if (isNaN(phValue)) return null;
        
        const cropOptimal = await this.getOptimalPH(crops);
        let status, icon, action, content;
        
        if (phValue < 5.5) {
            status = 'critical';
            icon = '‚ö†Ô∏è';
            action = 'Add pH buffer or reduce acid input';
            content = `pH is critically low at ${phValue.toFixed(1)}. Most plants cannot absorb nutrients effectively below 5.5.`;
        } else if (phValue < cropOptimal.min) {
            status = 'warning';
            icon = 'üìâ';
            action = 'Gradually increase pH';
            content = `pH is slightly low at ${phValue.toFixed(1)} for your crops. Optimal range is ${cropOptimal.min}-${cropOptimal.max}.`;
        } else if (phValue > cropOptimal.max) {
            status = 'caution';
            icon = 'üìà';
            action = 'Gradually decrease pH';
            content = `pH is slightly high at ${phValue.toFixed(1)} for your crops. Optimal range is ${cropOptimal.min}-${cropOptimal.max}.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `pH is optimal at ${phValue.toFixed(1)} for your crops. Plants can efficiently absorb nutrients.`;
        }
        
        return {
            title: 'pH Level',
            status,
            icon,
            level: `Current: ${phValue.toFixed(1)}`,
            content,
            action,
            cropNote: crops.length > 1 ? `Optimized for: ${crops.join(', ')}` : null
        };
    }

    async analyzeNitrogen(nitrogen, crops, environmentalData) {
        if (nitrogen === null || nitrogen === undefined) return null;
        
        // Convert to number and validate
        const nitrogenValue = parseFloat(nitrogen);
        if (isNaN(nitrogenValue)) return null;
        
        // Get optimal nitrogen range for crops (baseline for ratio calculations)
        const optimalRange = await this.getCropNutrientRange(crops, 'nitrogen');
        let status, icon, action, content;
        
        if (nitrogenValue < optimalRange.min * 0.6) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Increase fish feeding or add nitrogen supplement';
            content = `Nitrogen is critically low at ${nitrogenValue.toFixed(0)} ppm. This serves as the baseline for all other nutrient ratios. Target: ${optimalRange.min}-${optimalRange.max} ppm.`;
        } else if (nitrogenValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Gradually increase nitrogen levels';
            content = `Nitrogen is below optimal at ${nitrogenValue.toFixed(0)} ppm. All other nutrients are calculated as ratios to nitrogen. Target: ${optimalRange.min}-${optimalRange.max} ppm.`;
        } else if (nitrogenValue > optimalRange.max * 1.5) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce feeding or increase plant density';
            content = `Nitrogen is high at ${nitrogenValue.toFixed(0)} ppm. High nitrogen can promote excessive leaf growth at expense of fruiting. Target: ${optimalRange.min}-${optimalRange.max} ppm.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Nitrogen is optimal at ${nitrogenValue.toFixed(0)} ppm. This provides a good baseline for calculating all other nutrient requirements.`;
        }
        
        return {
            title: 'Nitrogen (N) - Baseline',
            status,
            icon,
            level: `Current: ${nitrogenValue.toFixed(0)} ppm`,
            content,
            action,
            cropNote: `Target for your crops: ${optimalRange.min}-${optimalRange.max} ppm ‚Ä¢ Base for all nutrient ratios`
        };
    }

    async analyzeIron(iron, crops, environmentalData, nitrogenLevel) {
        if (iron === null || iron === undefined) return null;
        
        // Convert to number and validate
        const ironValue = parseFloat(iron);
        if (isNaN(ironValue)) return null;
        
        const optimalRange = await this.getCropNutrientRange(crops, 'iron');
        
        // Calculate ratio-based recommendation if nitrogen level is available
        let ratioNote = '';
        if (nitrogenLevel && nitrogenLevel > 0) {
            const currentRatio = ironValue / nitrogenLevel;
            const expectedMinRatio = optimalRange.min / nitrogenLevel;
            const expectedMaxRatio = optimalRange.max / nitrogenLevel;
            ratioNote = ` ‚Ä¢ Current ratio: ${currentRatio.toFixed(3)}:1 (Fe:N)`;
        }
        
        let status, icon, action, content;
        
        if (ironValue < optimalRange.min * 0.5) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Add iron chelate supplement immediately';
            content = `Iron is critically low at ${ironValue.toFixed(1)} mg/L. Plants will show yellowing leaves (chlorosis) and stunted growth. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (ironValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Consider iron chelate supplementation';
            content = `Iron is below optimal at ${ironValue.toFixed(1)} mg/L. Essential for chlorophyll synthesis and enzyme function. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (ironValue > optimalRange.max * 2) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce iron inputs to prevent toxicity';
            content = `Iron is high at ${ironValue.toFixed(1)} mg/L. Excessive iron can block phosphorus and zinc uptake. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Iron is optimal at ${ironValue.toFixed(1)} mg/L. Plants have adequate iron for healthy chlorophyll synthesis and enzyme function.`;
        }
        
        return {
            title: 'Iron (Fe)',
            status,
            icon,
            level: `Current: ${ironValue.toFixed(1)} mg/L`,
            content,
            action,
            cropNote: `Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L${ratioNote}`
        };
    }

    async analyzePotassium(potassium, crops, environmentalData, nitrogenLevel) {
        if (potassium === null || potassium === undefined) return null;
        
        // Convert to number and validate
        const potassiumValue = parseFloat(potassium);
        if (isNaN(potassiumValue)) return null;
        
        const optimalRange = await this.getCropNutrientRange(crops, 'potassium');
        
        // Calculate ratio-based recommendation if nitrogen level is available
        let ratioNote = '';
        if (nitrogenLevel && nitrogenLevel > 0) {
            const currentRatio = potassiumValue / nitrogenLevel;
            ratioNote = ` ‚Ä¢ Current ratio: ${currentRatio.toFixed(2)}:1 (K:N)`;
        }
        
        let status, icon, action, content;
        
        if (potassiumValue < optimalRange.min * 0.6) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Add potassium supplement or increase fish feeding';
            content = `Potassium is critically low at ${potassiumValue.toFixed(0)} mg/L. Essential for fruit development, disease resistance, and water regulation. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else if (potassiumValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase potassium gradually with supplementation';
            content = `Potassium is below optimal at ${potassiumValue.toFixed(0)} mg/L. Important for fruit quality and plant vigor. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else if (potassiumValue > optimalRange.max * 1.5) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce potassium inputs to prevent nutrient imbalance';
            content = `Potassium is high at ${potassiumValue.toFixed(0)} mg/L. Excessive K can interfere with calcium and magnesium uptake. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Potassium is optimal at ${potassiumValue.toFixed(0)} mg/L. Plants have adequate K for metabolism, fruit development, and disease resistance.`;
        }
        
        return {
            title: 'Potassium (K)',
            status,
            icon,
            level: `Current: ${potassiumValue.toFixed(0)} mg/L`,
            content,
            action,
            cropNote: `Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L${ratioNote}`
        };
    }

    async analyzeCalcium(calcium, crops, environmentalData, nitrogenLevel) {
        if (calcium === null || calcium === undefined) return null;
        
        // Convert to number and validate
        const calciumValue = parseFloat(calcium);
        if (isNaN(calciumValue)) return null;
        
        const optimalRange = await this.getCropNutrientRange(crops, 'calcium');
        
        // Calculate ratio-based recommendation if nitrogen level is available
        let ratioNote = '';
        if (nitrogenLevel && nitrogenLevel > 0) {
            const currentRatio = calciumValue / nitrogenLevel;
            ratioNote = ` ‚Ä¢ Current ratio: ${currentRatio.toFixed(2)}:1 (Ca:N)`;
        }
        
        let status, icon, action, content;
        
        if (calciumValue < optimalRange.min * 0.5) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Add calcium supplement immediately';
            content = `Calcium is critically low at ${calciumValue.toFixed(0)} mg/L. Plants will develop weak cell walls and blossom end rot. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else if (calciumValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase calcium levels with supplementation';
            content = `Calcium is below optimal at ${calciumValue.toFixed(0)} mg/L. Essential for cell wall strength and preventing disorders. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else if (calciumValue > optimalRange.max * 1.8) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce calcium inputs to prevent nutrient lockout';
            content = `Calcium is very high at ${calciumValue.toFixed(0)} mg/L. Excessive Ca can reduce magnesium and iron uptake. Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Calcium is optimal at ${calciumValue.toFixed(0)} mg/L. Plants have adequate Ca for strong cell walls and disease resistance.`;
        }
        
        return {
            title: 'Calcium (Ca)',
            status,
            icon,
            level: `Current: ${calciumValue.toFixed(0)} mg/L`,
            content,
            action,
            cropNote: `Target: ${optimalRange.min.toFixed(0)}-${optimalRange.max.toFixed(0)} mg/L${ratioNote}`
        };
    }

    analyzeEC(ec, crops) {
        if (ec === null || ec === undefined) return null;
        
        // Convert to number and validate
        const ecValue = parseFloat(ec);
        if (isNaN(ecValue)) return null;
        
        // EC optimal ranges for aquaponics (ŒºS/cm)
        // General aquaponics: 400-1500 ŒºS/cm
        // Leafy greens: 400-800 ŒºS/cm
        // Fruiting plants: 800-1500 ŒºS/cm
        let optimalMin = 400;
        let optimalMax = 1200;
        
        // Adjust range based on crop types
        const leafyGreens = ['lettuce', 'lettuce_batavian', 'lettuce_butter', 'lettuce_cos', 'lettuce_icty', 'lettuce_datem', 'lettuce_oak', 'spinach', 'kale', 'arugula', 'bok choy', 'basil', 'cilantro', 'mint', 'celery'];
        const fruitingPlants = ['tomato', 'cucumber', 'pepper', 'strawberry', 'eggplant'];
        
        const hasLeafyGreens = crops.some(crop => leafyGreens.includes(crop.toLowerCase()));
        const hasFruitingPlants = crops.some(crop => fruitingPlants.includes(crop.toLowerCase()));
        
        if (hasLeafyGreens && !hasFruitingPlants) {
            optimalMax = 800; // Lower EC for leafy greens only
        } else if (hasFruitingPlants) {
            optimalMin = 800; // Higher EC for fruiting plants
            optimalMax = 1500;
        }
        
        let status, icon, action, content;
        
        if (ecValue < 200) {
            status = 'critical';
            icon = '‚ö†Ô∏è';
            action = 'Add nutrients immediately';
            content = `EC is critically low at ${ecValue.toFixed(0)} ŒºS/cm. Plants cannot get sufficient nutrients for healthy growth.`;
        } else if (ecValue < optimalMin) {
            status = 'low';
            icon = 'üîµ';
            action = 'Increase nutrient concentration';
            content = `EC is low at ${ecValue.toFixed(0)} ŒºS/cm. Consider adding nutrients or reducing water dilution.`;
        } else if (ecValue > 2000) {
            status = 'critical';
            icon = '‚ö†Ô∏è';
            action = 'Dilute nutrients immediately';
            content = `EC is critically high at ${ecValue.toFixed(0)} ŒºS/cm. Risk of nutrient burn and plant stress.`;
        } else if (ecValue > optimalMax) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce nutrient concentration';
            content = `EC is high at ${ecValue.toFixed(0)} ŒºS/cm. Consider diluting nutrients to prevent plant stress.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `EC is optimal at ${ecValue.toFixed(0)} ŒºS/cm for your crop mix. Good nutrient availability for plants.`;
        }
        
        return {
            title: 'EC/TDS',
            status,
            icon,
            level: `Current: ${ecValue.toFixed(0)} ŒºS/cm`,
            content,
            action,
            cropNote: `Target range: ${optimalMin}-${optimalMax} ŒºS/cm for ${crops.join(', ')}`
        };
    }

    analyzeNitrate(nitrate, crops) {
        if (nitrate === null || nitrate === undefined) return null;
        
        // Convert to number and validate
        const nitrateValue = parseFloat(nitrate);
        if (isNaN(nitrateValue)) return null;
        
        // Use proper aquaponics nitrate ranges (5-150 mg/L is typical for aquaponics)
        // These ranges are based on aquaponics best practices, not conversion from nitrogen targets
        let optimalMin = 10;  // Minimum for plant growth
        let optimalMax = 80;  // Maximum before potential issues
        
        // Adjust range slightly based on crop types
        const leafyGreens = ['lettuce', 'lettuce_batavian', 'lettuce_butter', 'lettuce_cos', 'lettuce_icty', 'lettuce_datem', 'lettuce_oak', 'spinach', 'kale', 'swiss_chard', 'arugula', 'watercress', 'celery'];
        const fruitingPlants = ['tomato', 'cucumber', 'pepper', 'strawberry', 'eggplant'];
        
        const hasLeafyGreens = crops.some(crop => leafyGreens.includes(crop.toLowerCase()));
        const hasFruitingPlants = crops.some(crop => fruitingPlants.includes(crop.toLowerCase()));
        
        if (hasLeafyGreens && !hasFruitingPlants) {
            // Leafy greens prefer lower nitrate levels
            optimalMin = 10;
            optimalMax = 60;
        } else if (hasFruitingPlants) {
            // Fruiting plants can handle higher nitrate levels
            optimalMin = 20;
            optimalMax = 100;
        }
        
        let status, icon, action, content;
        
        if (nitrateValue < 5) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Increase fish feeding or check system balance';
            content = `Nitrate is critically low at ${nitrateValue.toFixed(1)} mg/L. Plants need adequate nitrate for proper growth.`;
        } else if (nitrateValue < optimalMin) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase nitrate levels gradually';
            content = `Nitrate is below optimal at ${nitrateValue.toFixed(1)} mg/L. Target range is ${optimalMin}-${optimalMax} mg/L for your crops.`;
        } else if (nitrateValue > 150) {
            status = 'warning';
            icon = 'üü†';
            action = 'Reduce feeding or increase water changes';
            content = `Nitrate is excessively high at ${nitrateValue.toFixed(1)} mg/L. This can stress fish and cause algae growth.`;
        } else if (nitrateValue > optimalMax) {
            status = 'caution';
            icon = '‚ö†Ô∏è';
            action = 'Monitor nitrate levels';
            content = `Nitrate is slightly high at ${nitrateValue.toFixed(1)} mg/L. Consider reducing fish feeding or adding more plants.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Nitrate is optimal at ${nitrateValue.toFixed(1)} mg/L. Plants have excellent nitrate availability for growth.`;
        }
        
        return {
            title: 'Nitrate (NO‚ÇÉ)',
            status,
            icon,
            level: `Current: ${nitrateValue.toFixed(1)} mg/L`,
            content,
            action,
            cropNote: `Target range: ${optimalMin}-${optimalMax} mg/L for ${crops.join(', ')}`
        };
    }

    async analyzePhosphorus(phosphorus, crops, environmentalData, nitrogenLevel) {
        if (phosphorus === null || phosphorus === undefined) return null;
        
        // Convert to number and validate
        const phosphorusValue = parseFloat(phosphorus);
        if (isNaN(phosphorusValue)) return null;
        
        const optimalRange = await this.getCropNutrientRange(crops, 'phosphorus');
        
        // Calculate ratio-based recommendation if nitrogen level is available
        let ratioNote = '';
        if (nitrogenLevel && nitrogenLevel > 0) {
            const currentRatio = phosphorusValue / nitrogenLevel;
            ratioNote = ` ‚Ä¢ Current ratio: ${currentRatio.toFixed(3)}:1 (P:N)`;
        }
        
        let status, icon, action, content;
        
        if (phosphorusValue < optimalRange.min * 0.5) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Add phosphorus supplement immediately';
            content = `Phosphorus is critically low at ${phosphorusValue.toFixed(1)} mg/L. Essential for root development, flowering, and energy transfer. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (phosphorusValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase phosphorus levels with supplementation';
            content = `Phosphorus is below optimal at ${phosphorusValue.toFixed(1)} mg/L. Important for root growth and flower/fruit development. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (phosphorusValue > optimalRange.max * 1.5) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce phosphorus input to prevent algae growth';
            content = `Phosphorus is high at ${phosphorusValue.toFixed(1)} mg/L. Excess P can cause algae blooms and nutrient lockout. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Phosphorus is optimal at ${phosphorusValue.toFixed(1)} mg/L. Plants have adequate P for energy transfer and development.`;
        }
        
        return {
            title: 'Phosphorus (P)',
            status,
            icon,
            level: `Current: ${phosphorusValue.toFixed(1)} mg/L`,
            content,
            action,
            cropNote: `Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L${ratioNote}`
        };
    }

    analyzeHumidity(humidity, crops) {
        if (humidity === null || humidity === undefined) return null;
        
        // Convert to number and validate
        const humidityValue = parseFloat(humidity);
        if (isNaN(humidityValue)) return null;
        
        // Optimal humidity ranges for aquaponics (40-80%)
        let optimalMin = 40;
        let optimalMax = 80;
        
        let status, icon, action, content;
        
        if (humidityValue < 20) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Increase humidity immediately';
            content = `Humidity is critically low at ${humidityValue.toFixed(1)}%. Plants will experience severe water stress and may wilt.`;
        } else if (humidityValue < optimalMin) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase humidity levels';
            content = `Humidity is low at ${humidityValue.toFixed(1)}%. Target range is ${optimalMin}-${optimalMax}% for optimal plant growth.`;
        } else if (humidityValue > 95) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Reduce humidity to prevent mold';
            content = `Humidity is critically high at ${humidityValue.toFixed(1)}%. Risk of fungal diseases and poor plant health.`;
        } else if (humidityValue > optimalMax) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce humidity levels';
            content = `Humidity is high at ${humidityValue.toFixed(1)}%. May cause fungal issues and reduce nutrient uptake efficiency.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Humidity is optimal at ${humidityValue.toFixed(1)}%. Plants have ideal conditions for transpiration and growth.`;
        }
        
        return {
            title: 'Humidity',
            status,
            icon,
            level: `Current: ${humidityValue.toFixed(1)}%`,
            content,
            action,
            cropNote: `Optimal range: ${optimalMin}-${optimalMax}% for aquaponics systems`
        };
    }

    analyzeSalinity(salinity, crops) {
        if (salinity === null || salinity === undefined) return null;
        
        // Convert to number and validate
        const salinityValue = parseFloat(salinity);
        if (isNaN(salinityValue)) return null;
        
        // Optimal salinity ranges for aquaponics (0.0-1.0 ppt)
        let optimalMin = 0.0;
        let optimalMax = 1.0;
        
        let status, icon, action, content;
        
        if (salinityValue > 3.0) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Reduce salinity immediately';
            content = `Salinity is critically high at ${salinityValue.toFixed(1)} ppt. Both fish and plants will experience severe stress.`;
        } else if (salinityValue > optimalMax) {
            status = 'warning';
            icon = 'üü†';
            action = 'Reduce salinity levels';
            content = `Salinity is high at ${salinityValue.toFixed(1)} ppt. Target range is ${optimalMin}-${optimalMax} ppt for freshwater aquaponics.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Salinity is optimal at ${salinityValue.toFixed(1)} ppt. Ideal conditions for freshwater fish and plant growth.`;
        }
        
        return {
            title: 'Salinity',
            status,
            icon,
            level: `Current: ${salinityValue.toFixed(1)} ppt`,
            content,
            action,
            cropNote: `Optimal range: ${optimalMin}-${optimalMax} ppt for freshwater aquaponics`
        };
    }

    async analyzeMagnesium(magnesium, crops, environmentalData, nitrogenLevel) {
        if (magnesium === null || magnesium === undefined) return null;
        
        // Convert to number and validate
        const magnesiumValue = parseFloat(magnesium);
        if (isNaN(magnesiumValue)) return null;
        
        const optimalRange = await this.getCropNutrientRange(crops, 'magnesium');
        
        // Calculate ratio-based recommendation if nitrogen level is available
        let ratioNote = '';
        if (nitrogenLevel && nitrogenLevel > 0) {
            const currentRatio = magnesiumValue / nitrogenLevel;
            ratioNote = ` ‚Ä¢ Current ratio: ${currentRatio.toFixed(3)}:1 (Mg:N)`;
        }
        
        let status, icon, action, content;
        
        if (magnesiumValue < optimalRange.min * 0.5) {
            status = 'critical';
            icon = 'üî¥';
            action = 'Add magnesium supplement immediately';
            content = `Magnesium is critically low at ${magnesiumValue.toFixed(1)} mg/L. Essential for chlorophyll production and enzyme activation. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (magnesiumValue < optimalRange.min) {
            status = 'warning';
            icon = 'üü°';
            action = 'Increase magnesium levels with supplementation';
            content = `Magnesium is below optimal at ${magnesiumValue.toFixed(1)} mg/L. Important for photosynthesis and nutrient transport. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else if (magnesiumValue > optimalRange.max * 1.8) {
            status = 'caution';
            icon = 'üü†';
            action = 'Reduce magnesium inputs to prevent imbalance';
            content = `Magnesium is high at ${magnesiumValue.toFixed(1)} mg/L. Excessive Mg can interfere with calcium uptake. Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L.`;
        } else {
            status = 'optimal';
            icon = '‚úÖ';
            action = 'Maintain current levels';
            content = `Magnesium is optimal at ${magnesiumValue.toFixed(1)} mg/L. Plants have adequate Mg for chlorophyll synthesis and enzyme function.`;
        }
        
        return {
            title: 'Magnesium (Mg)',
            status,
            icon,
            level: `Current: ${magnesiumValue.toFixed(1)} mg/L`,
            content,
            action,
            cropNote: `Target: ${optimalRange.min.toFixed(1)}-${optimalRange.max.toFixed(1)} mg/L${ratioNote}`
        };
    }

    async getCropNutrientRange(crops, nutrient) {
        try {
            // Create cache key based on crops and nutrient
            const cacheKey = `${JSON.stringify(crops)}_${nutrient}`;
            
            // Check if we have a cached result (valid for 5 minutes)
            if (this.nutrientRangeCache && this.nutrientRangeCache[cacheKey]) {
                const cached = this.nutrientRangeCache[cacheKey];
                if (Date.now() - cached.timestamp < 300000) { // 5 minutes
                    return cached.data;
                }
            }
            
            // Initialize cache if it doesn't exist
            if (!this.nutrientRangeCache) {
                this.nutrientRangeCache = {};
            }
            
            // Get current water quality data for environmental factors
            const latestData = this.getLatestWaterQualityData();
            const environmentalParams = {
                temperature: latestData?.temperature || 22,  // Default 22¬∞C
                ph: latestData?.ph || 6.5,                 // Default 6.5 pH
                ec: latestData?.ec || 1.2                  // Default 1.2 EC
            };

            // Determine nitrogen baseline (assume 100 ppm as default for ratio calculations)
            const nitrogenBaseline = latestData?.nitrogen || 100;

            let minValues = [];
            let maxValues = [];
            
            // PERFORMANCE OPTIMIZED: Use batched API to calculate all crops in single request
            const batchResponse = await fetch(`/api/crop-knowledge/calculate/nutrient-ratios/batch`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken || ''}`
                },
                body: JSON.stringify({
                    base_nitrate_ppm: nitrogenBaseline,
                    crop_codes: crops.map(crop => crop.toLowerCase()),
                    growth_stage: 'general',
                    environmental_conditions: environmentalParams
                })
            });

            let cropResults = [];
            
            if (!batchResponse.ok) {
                console.warn('Batch nutrient calculation failed, falling back to individual requests');
                // Fallback to individual requests if batch fails
                const cropPromises = crops.map(crop => 
                    fetch(`/api/crop-knowledge/calculate/nutrient-ratios`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.authToken || ''}`
                        },
                        body: JSON.stringify({
                            base_nitrate_ppm: nitrogenBaseline,
                            crop_code: crop.toLowerCase(),
                            growth_stage: 'general',
                            environmental_conditions: environmentalParams
                        })
                    })
                    .then(response => response.ok ? response.json() : null)
                    .catch(error => {
                        console.warn(`Failed to fetch ratio calculation for crop: ${crop}`, error);
                        return null;
                    })
                );
                cropResults = await Promise.all(cropPromises);
            } else {
                const batchData = await batchResponse.json();
                if (!batchData.success) {
                    console.warn('Batch nutrient calculation unsuccessful');
                    return { min: 0, max: 0 };
                }
                
                // Convert batch results to expected format
                cropResults = crops.map(crop => {
                    const cropData = batchData.results[crop.toLowerCase()];
                    return cropData ? { success: true, ...cropData } : null;
                });
                
                console.log(`‚úÖ Batched API: ${crops.length} crops processed in 1 request (vs ${crops.length} individual requests)`);
            }
            
            // Process results from parallel requests
            cropResults.forEach(data => {
                if (data && data.success && data.calculations && data.calculations[nutrient]) {
                    const calc = data.calculations[nutrient];
                    
                    // Use the ratio-based calculated ranges from the API
                    if (calc.min_range && calc.max_range) {
                        minValues.push(calc.min_range);
                        maxValues.push(calc.max_range);
                    } else if (calc.calculated_ppm) {
                        // Fallback: use calculated value with ¬±15% tolerance
                        const adjustedConcentration = calc.calculated_ppm * (calc.environmental_adjustment || 1.0);
                        minValues.push(adjustedConcentration * 0.85);
                        maxValues.push(adjustedConcentration * 1.15);
                    }
                }
            });
            
            // If no ratio data found, fallback to simple API ranges
            if (minValues.length === 0) {
                return await this.getFallbackNutrientRangeFromAPI(crops, nutrient);
            }
            
            const result = {
                min: Math.min(...minValues),
                max: Math.max(...maxValues)
            };
            
            // Cache the result
            this.nutrientRangeCache[cacheKey] = {
                data: result,
                timestamp: Date.now()
            };
            
            return result;
            
        } catch (error) {
            console.warn('Failed to fetch ratio-based nutrient ranges, using fallback:', error);
            return this.getFallbackNutrientRange(nutrient);
        }
    }

    getCachedNutrientRange(crops, nutrient) {
        let minValues = [];
        let maxValues = [];
        
        crops.forEach(crop => {
            const cropData = this.cropKnowledgeCache.crops[crop.toLowerCase()];
            if (cropData && cropData.nutrients[nutrient]) {
                minValues.push(cropData.nutrients[nutrient].min);
                maxValues.push(cropData.nutrients[nutrient].max);
            }
        });
        
        if (minValues.length === 0) {
            return this.getFallbackNutrientRange(nutrient);
        }
        
        return {
            min: Math.min(...minValues),
            max: Math.max(...maxValues)
        };
    }

    async getFallbackNutrientRangeFromAPI(crops, nutrient) {
        try {
            let minValues = [];
            let maxValues = [];
            
            // Map common crop names to their database codes
            const cropCodeMap = {
                'tomato': 'tomatoes',
                'tomatoes': 'tomatoes',
                'pepper': 'peppers',
                'peppers': 'peppers',
                'cucumber': 'cucumbers',
                'cucumbers': 'cucumbers',
                'strawberry': 'strawberries',
                'strawberries': 'strawberries',
                'cherry tomato': 'cherry_tomatoes',
                'cherry tomatoes': 'cherry_tomatoes',
                'lettuce': 'lettuce',
                'lettuce_butter': 'lettuce',
                'lettuce_batavian': 'lettuce',
                'lettuce_cos': 'lettuce',
                'lettuce_icty': 'lettuce',
                'lettuce_datem': 'lettuce',
                'lettuce_oak': 'lettuce',
                'spinach': 'spinach',
                'kale': 'kale',
                'basil': 'basil',
                'mint': 'mint',
                'general': 'lettuce', // Fallback to lettuce for general requests
                'herbs': 'herbs_mix',
                'mixed herbs': 'herbs_mix'
            };
            
            // OPTIMIZED: Fetch data for all crops from simple API in parallel
            const cropApiPromises = crops.map(crop => {
                const cropLower = crop.toLowerCase();
                const cropCode = cropCodeMap[cropLower] || cropLower;
                
                return fetch(`/api/crop-knowledge/crops/${cropCode}/nutrient-ranges?stage=general`)
                    .then(response => response.ok ? response.json() : null)
                    .catch(error => {
                        console.warn(`Failed to fetch nutrient range for crop: ${crop}`, error);
                        return null;
                    });
            });

            const cropApiResults = await Promise.all(cropApiPromises);
            
            // Process results from parallel requests
            cropApiResults.forEach(data => {
                if (data && data.success && data.ranges[nutrient]) {
                    const range = data.ranges[nutrient];
                    minValues.push(range.min);
                    maxValues.push(range.max);
                }
            });
            
            // If no API data found, fallback to hardcoded ranges
            if (minValues.length === 0) {
                return this.getFallbackNutrientRange(nutrient);
            }
            
            return {
                min: Math.min(...minValues),
                max: Math.max(...maxValues)
            };
            
        } catch (error) {
            console.warn('Failed to fetch fallback nutrient range from API:', error);
            return this.getFallbackNutrientRange(nutrient);
        }
    }

    getFallbackNutrientRange(nutrient) {
        const generalRanges = {
            nitrogen: { min: 50, max: 100 },
            phosphorus: { min: 15, max: 30 },
            potassium: { min: 80, max: 180 },
            calcium: { min: 60, max: 120 },
            magnesium: { min: 12, max: 25 },
            iron: { min: 1.0, max: 2.5 }
        };
        return generalRanges[nutrient] || { min: 0, max: 100 };
    }

    generateSystemRecommendation(data, crops) {
        const issues = [];
        const strengths = [];
        
        // Analyze overall system health
        if (data.ph && (data.ph < 5.5 || data.ph > 8.0)) issues.push('pH imbalance');
        if (data.iron && data.iron < 0.1) issues.push('iron deficiency');
        if (data.potassium && data.potassium < 40) issues.push('potassium shortage');
        if (data.calcium && data.calcium < 50) issues.push('calcium deficiency');
        
        if (data.ph && data.ph >= 6.0 && data.ph <= 7.0) strengths.push('optimal pH');
        if (data.iron && data.iron >= 0.3 && data.iron <= 2.0) strengths.push('good iron levels');
        if (data.potassium && data.potassium >= 40 && data.potassium <= 70) strengths.push('adequate potassium');
        if (data.calcium && data.calcium >= 50 && data.calcium <= 100) strengths.push('sufficient calcium');
        
        let status, icon, content, action;
        
        if (issues.length >= 3) {
            status = 'critical';
            icon = 'üö®';
            content = `Multiple nutrient imbalances detected: ${issues.join(', ')}. Immediate attention required.`;
            action = 'Address critical issues first, then rebalance';
        } else if (issues.length >= 1) {
            status = 'warning';
            icon = '‚ö†Ô∏è';
            content = `System needs attention: ${issues.join(', ')}. ${strengths.length > 0 ? `Strengths: ${strengths.join(', ')}.` : ''}`;
            action = 'Focus on identified issues';
        } else {
            status = 'optimal';
            icon = 'üåü';
            content = `System is well-balanced with ${strengths.join(', ')}. Plants should thrive in these conditions.`;
            action = 'Continue current maintenance routine';
        }
        
        return {
            title: 'Overall System Health',
            status,
            icon,
            level: `${issues.length} issues, ${strengths.length} optimal`,
            content,
            action,
            cropNote: crops.length > 1 ? `Currently growing: ${crops.join(', ')}` : null
        };
    }

    async getOptimalPH(crops) {
        let minValues = [];
        let maxValues = [];
        
        // Map common crop names to their database codes
        const cropCodeMap = {
            'tomato': 'tomatoes',
            'tomatoes': 'tomatoes',
            'pepper': 'peppers',
            'peppers': 'peppers',
            'cucumber': 'cucumbers',
            'cucumbers': 'cucumbers',
            'strawberry': 'strawberries',
            'strawberries': 'strawberries',
            'cherry tomato': 'cherry_tomatoes',
            'cherry tomatoes': 'cherry_tomatoes',
            'lettuce': 'lettuce',
            'lettuce_butter': 'lettuce',
            'lettuce_batavian': 'lettuce',
            'lettuce_cos': 'lettuce',
            'lettuce_icty': 'lettuce',
            'lettuce_datem': 'lettuce',
            'lettuce_oak': 'lettuce',
            'spinach': 'spinach',
            'kale': 'kale',
            'basil': 'basil',
            'mint': 'mint',
            'general': 'lettuce', // Fallback to lettuce for general requests
            'herbs': 'herbs_mix',
            'mixed herbs': 'herbs_mix'
        };
        
        // OPTIMIZED: Fetch pH data for all crops in parallel
        const phPromises = crops.map(crop => {
            const cropLower = crop.toLowerCase();
            const cropCode = cropCodeMap[cropLower] || cropLower;
            
            return fetch(`/api/crop-knowledge/crops/${cropCode}`)
                .then(response => response.ok ? response.json() : null)
                .catch(error => {
                    console.warn(`Failed to fetch pH data for crop: ${crop}`, error);
                    return null;
                });
        });

        const phResults = await Promise.all(phPromises);
        
        // Process results from parallel requests
        phResults.forEach(data => {
            if (data && data.success && data.data.crop) {
                const cropData = data.data.crop;
                if (cropData.default_ph_min && cropData.default_ph_max) {
                    minValues.push(cropData.default_ph_min);
                    maxValues.push(cropData.default_ph_max);
                }
            }
        });
        
        if (minValues.length === 0) {
            // Default aquaponics pH range
            return { min: 6.0, max: 6.8 };
        }
        
        if (crops.length === 1) {
            return { min: minValues[0], max: maxValues[0] };
        }
        
        // For multiple crops, find safe overlap
        return { 
            min: Math.max(...minValues), 
            max: Math.min(...maxValues) 
        };
    }

    getIronNote(crops) {
        const highIronCrops = ['spinach', 'kale', 'lettuce', 'leafy_greens'];
        const hasHighIronCrop = crops.some(crop => highIronCrops.includes(crop.toLowerCase()));
        return hasHighIronCrop ? 'Leafy greens require higher iron for dark green color' : null;
    }

    getPotassiumNote(crops) {
        const highKCrops = ['tomato', 'peppers', 'cucumber'];
        const hasHighKCrop = crops.some(crop => highKCrops.includes(crop.toLowerCase()));
        return hasHighKCrop ? 'Fruiting plants need extra potassium for development' : null;
    }

    getCalciumNote(crops) {
        const highCaCrops = ['tomato', 'peppers'];
        const hasHighCaCrop = crops.some(crop => highCaCrops.includes(crop.toLowerCase()));
        return hasHighCaCrop ? 'Prevents blossom end rot in fruiting plants' : null;
    }

    generateRecommendationCard(rec) {
        return `
            <div class="recommendation-card ${rec.status}">
                <div class="recommendation-header">
                    <span class="recommendation-icon">${rec.icon}</span>
                    <span class="recommendation-title">${rec.title}</span>
                </div>
                <div class="recommendation-level">${rec.level}</div>
                <div class="recommendation-content">${rec.content}</div>
                <div class="recommendation-action">${rec.action}</div>
                ${rec.cropNote ? `<div class="crop-specific-note">${rec.cropNote}</div>` : ''}
            </div>
        `;
    }

    // Fallback function for opening nutrient modal
    openNutrientModal(canvasId, label, labels, data, color) {
        try {
            const modal = document.getElementById('nutrient-detail-modal');
            if (!modal) {
                console.error('Nutrient detail modal not found');
                return;
            }

            // Update modal title
            const titleEl = document.getElementById('nutrient-modal-title');
            if (titleEl) {
                titleEl.textContent = label || 'Parameter Details';
            }

            // Update current value
            const currentValue = data && data.length > 0 ? data[data.length - 1] : 'N/A';
            const valueEl = document.getElementById('nutrient-current-value');
            if (valueEl) {
                valueEl.textContent = currentValue !== null && currentValue !== undefined ? 
                    `${currentValue} ${this.getUnitForParameter(label)}` : 'No data';
            }

            // Update trend
            const trendEl = document.getElementById('nutrient-trend');
            if (trendEl && data && data.length > 1) {
                const change = data[data.length - 1] - data[data.length - 2];
                trendEl.innerHTML = change > 0 ? '‚Üë Increasing' : 
                                   change < 0 ? '‚Üì Decreasing' : 
                                   '‚Üí Stable';
                trendEl.className = change > 0 ? 'trend-up' : 
                                   change < 0 ? 'trend-down' : 
                                   'trend-stable';
            }

            // Show modal
            modal.style.display = 'flex';
            modal.classList.add('show');

            // Create chart after modal is visible
            setTimeout(() => {
                const chartCanvas = document.getElementById('nutrient-detail-chart');
                if (chartCanvas) {
                    // Destroy existing chart if any
                    if (this.modalChart) {
                        this.modalChart.destroy();
                    }

                    // Create new chart
                    this.modalChart = new Chart(chartCanvas.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: labels || [],
                            datasets: [{
                                label: label || 'Value',
                                data: data || [],
                                borderColor: color || '#0051b1',
                                backgroundColor: color ? `${color}20` : 'rgba(0, 81, 177, 0.1)',
                                tension: 0.3,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: { beginAtZero: false }
                            }
                        }
                    });
                }
            }, 100);

            // Set up close button
            const closeBtn = document.getElementById('close-nutrient-modal');
            if (closeBtn) {
                closeBtn.onclick = () => {
                    modal.style.display = 'none';
                    modal.classList.remove('show');
                    if (this.modalChart) {
                        this.modalChart.destroy();
                        this.modalChart = null;
                    }
                };
            }

            // Close on backdrop click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    modal.classList.remove('show');
                    if (this.modalChart) {
                        this.modalChart.destroy();
                        this.modalChart = null;
                    }
                }
            };

        } catch (error) {
            console.error('Error opening nutrient modal:', error);
        }
    }

    getUnitForParameter(label) {
        const units = {
            'Temperature': '¬∞C',
            'pH Level': '',
            'Dissolved Oxygen': 'mg/L',
            'Ammonia': 'ppm',
            'Humidity': '%',
            'Salinity': 'ppt',
            'EC': 'ŒºS/cm',
            'Nitrate': 'mg/L',
            'Nitrite': 'mg/L',
            'Phosphorus': 'mg/L',
            'Potassium': 'mg/L',
            'Calcium': 'mg/L',
            'Magnesium': 'mg/L',
            'Iron': 'mg/L'
        };
        
        for (const [key, unit] of Object.entries(units)) {
            if (label && label.includes(key)) {
                return unit;
            }
        }
        return '';
    }

    // getNutrientOptimalRange function moved to ChartModalComponent

    // getNutrientStatus function moved to ChartModalComponent

    // createDetailedChart function moved to ChartModalComponent

    // updateNutrientHistoryTable function moved to ChartModalComponent

    getChangeIndicator(current, previous) {
        const change = current - previous;
        const changePercent = ((change / previous) * 100).toFixed(1);
        
        if (Math.abs(change) < 0.1) {
            return `<span class="no-change">No change</span>`;
        } else if (change > 0) {
            return `<span class="increase">+${changePercent}%</span>`;
        } else {
            return `<span class="decrease">${changePercent}%</span>`;
        }
    }

    exportNutrientData() {
        const modal = document.getElementById('nutrient-detail-modal');
        const nutrientTitleEl = document.getElementById('nutrient-modal-title');
        const tbody = document.querySelector('#nutrient-modal-history tbody');
        
        if (!nutrientTitleEl) {
            if (window.errorManager) {
                window.errorManager.warnOnce('nutrient_modal_title_missing', 'Nutrient modal title not found', 'export');
            }
            return;
        }
        
        if (!tbody) {
            if (window.errorManager) {
                window.errorManager.warnOnce('nutrient_modal_history_missing', 'Nutrient modal history table not found', 'export');
            }
            return;
        }
        
        const nutrientName = nutrientTitleEl.textContent;

        // Collect data from the history table
        const rows = tbody.querySelectorAll('tr');
        const data = [];
        
        // Add CSV header
        data.push(['Date', 'Value', 'Status']);
        
        // Add data rows
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 2) {
                const date = cells[0].textContent.trim();
                const value = cells[1].textContent.trim();
                const status = cells[2].textContent.trim();
                data.push([date, value, status]);
            }
        });

        // Create CSV content
        const csvContent = data.map(row => row.join(',')).join('\n');
        
        // Create and download the file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `${nutrientName.replace(/\s+/g, '_')}_data_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Show success message
        this.showNotification(`${nutrientName} data exported successfully!`, 'success');
    }

    exportBatchData() {
        const plantData = this.dataRecords.plantGrowth || [];
        const batchMap = new Map();
        
        // Build comprehensive batch information
        plantData.forEach(record => {
            if (record.batch_id && record.new_seedlings > 0) {
                // This is a planting record
                if (!batchMap.has(record.batch_id)) {
                    batchMap.set(record.batch_id, {
                        batch_id: record.batch_id,
                        crop_type: record.crop_type,
                        seed_variety: record.seed_variety || '',
                        days_to_harvest: record.days_to_harvest || '',
                        planted_count: 0,
                        harvested_weight: 0,
                        date_planted: record.date,
                        grow_bed_id: record.grow_bed_id || '',
                        harvest_dates: []
                    });
                }
                
                const batch = batchMap.get(record.batch_id);
                batch.planted_count += record.new_seedlings || 0;
            } else if (record.batch_id && (record.plants_harvested > 0 || record.harvest_weight > 0)) {
                // This is a harvest record
                if (batchMap.has(record.batch_id)) {
                    const batch = batchMap.get(record.batch_id);
                    batch.harvested_weight += record.harvest_weight || 0;
                    batch.harvest_dates.push(record.date);
                }
            }
        });
        
        if (batchMap.size === 0) {
            this.showNotification('No batch data found to export.', 'warning');
            return;
        }
        
        // Prepare CSV data
        const data = [];
        data.push([
            'Batch ID',
            'Crop Type', 
            'Seed Variety',
            'Date Planted',
            'Days to Harvest',
            'Plants Planted',
            'Total Harvested (g)',
            'Age (days)',
            'Status',
            'Progress (%)',
            'Grow Bed ID',
            'Last Harvest Date'
        ]);
        
        // Sort batches by date planted
        const sortedBatches = Array.from(batchMap.values()).sort((a, b) => 
            new Date(b.date_planted) - new Date(a.date_planted)
        );
        
        sortedBatches.forEach(batch => {
            const age = this.calculateBatchAge(batch); // Pass full batch object
            let status = 'Growing';
            let progress = 0;
            
            if (batch.days_to_harvest) {
                progress = Math.min((age / batch.days_to_harvest) * 100, 100);
                
                if (age >= batch.days_to_harvest) {
                    status = 'Ready for Harvest';
                } else if (progress > 70) {
                    status = 'Approaching Harvest';
                }
            }
            
            const lastHarvestDate = batch.harvest_dates.length > 0 
                ? batch.harvest_dates[batch.harvest_dates.length - 1] 
                : '';
            
            data.push([
                batch.batch_id,
                batch.crop_type,
                batch.seed_variety,
                batch.date_planted,
                batch.days_to_harvest,
                batch.planted_count,
                batch.harvested_weight.toFixed(1),
                age,
                status,
                Math.round(progress),
                batch.grow_bed_id,
                lastHarvestDate
            ]);
        });
        
        // Create CSV content
        const csvContent = data.map(row => 
            row.map(cell => 
                typeof cell === 'string' && cell.includes(',') 
                    ? `"${cell}"` 
                    : cell
            ).join(',')
        ).join('\n');
        
        // Create and download the file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `plant_batch_data_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Show success message
        this.showNotification(`Batch data (${sortedBatches.length} batches) exported successfully!`, 'success');
    }

    async updatePlantOverview() {
        // Clear any pending render timeout
        if (this.plantOverviewRenderTimeout) {
            clearTimeout(this.plantOverviewRenderTimeout);
        }
        
        // Debounce multiple render requests
        this.plantOverviewRenderTimeout = setTimeout(async () => {
            await this._doPlantOverviewRender();
        }, 100); // Wait 100ms for more requests
    }

    async _doPlantOverviewRender() {
        // Prevent concurrent renders
        if (this.plantOverviewRendering) {
            return;
        }
        
        this.plantOverviewRendering = true;
        try {
            const container = document.getElementById('plant-overview-container');
            if (!container) {
                if (window.errorManager) {
                    window.errorManager.warnOnce('plant_overview_container_missing', 'Plant overview container not found', this.activeSystemId);
                } else {
                    console.warn('plant-overview-container not found');
                }
                return;
            }
            

            const systemConfig = this.loadSystemConfig();
            if (!systemConfig || systemConfig.system_name === 'No System Selected') {
                container.innerHTML = '<div class="no-plant-data">Please select a system to view plant information.</div>';
                return;
            }

            // Fetch fresh plant data like the Plants tab does
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            
            // Use the simple, correct function to count active batches
            const activeBatches = this.getActiveBatchCount(plantData);
            
            // Calculate total plants remaining
            let totalPlants = 0;
            const batches = new Map();
            
            plantData.forEach(entry => {
                if (!entry.batch_id) return;
                
                const key = `${entry.grow_bed_id}-${entry.batch_id}`;
                if (!batches.has(key)) {
                    batches.set(key, { planted: 0, harvested: 0 });
                }
                
                const batch = batches.get(key);
                if (entry.new_seedlings > 0) {
                    batch.planted += entry.new_seedlings;
                }
                if (entry.plants_harvested > 0) {
                    batch.harvested += entry.plants_harvested;
                }
            });
            
            // Calculate total remaining plants
            batches.forEach(batch => {
                const remaining = batch.planted - batch.harvested;
                if (remaining > 0) {
                    totalPlants += remaining;
                }
            });
            
            
            const activeGrowBeds = Math.min(systemConfig.grow_bed_count || 4, this.getActiveGrowBeds(plantData));
            const totalHarvested = this.calculateTotalHarvested(plantData);
            const lastHarvestDate = this.getLastHarvestDate(plantData);
            
            // Calculate unique crop varieties
            const uniqueCrops = new Set();
            plantData.forEach(entry => {
                if (entry.crop_type) {
                    uniqueCrops.add(entry.crop_type);
                }
            });
            
            // Update plant metrics summary at top of Plants tab
            const totalPlantsEl = document.getElementById('total-plants-growing');
            const totalHarvestedEl = document.getElementById('total-harvested');
            const activeGrowBedsEl = document.getElementById('active-grow-beds');
            const growingVarietiesEl = document.getElementById('growing-varieties');
            
            if (totalPlantsEl) totalPlantsEl.textContent = totalPlants.toLocaleString();
            if (totalHarvestedEl) totalHarvestedEl.textContent = this.formatWeight(totalHarvested);
            if (activeGrowBedsEl) activeGrowBedsEl.textContent = activeGrowBeds;
            if (growingVarietiesEl) {
                // Count unique crop types that have remaining plants
                const uniqueCrops = new Set();
                batches.forEach((batch, key) => {
                    const remaining = batch.planted - batch.harvested;
                    if (remaining > 0) {
                        // Extract crop type from the original data
                        const batchId = key.split('-').slice(1).join('-');
                        const bedId = key.split('-')[0];
                        const batchEntry = plantData.find(e => 
                            e.batch_id === batchId && 
                            e.grow_bed_id == bedId && 
                            e.crop_type
                        );
                        if (batchEntry && batchEntry.crop_type) {
                            uniqueCrops.add(batchEntry.crop_type);
                        }
                    }
                });
                growingVarietiesEl.textContent = uniqueCrops.size;
            }

            // Generate batch statistics using consistent method
            const batchStats = this.generateBatchStatistics(plantData);
            
            // Calculate grow bed capacity metrics
            const growBedsData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            const bedCapacityStats = this.calculateBedCapacityMetrics(growBedsData, plantData);
            
            // Unified grow bed overview moved to dedicated Beds Overview tab
            
            // Generate nutrient overview section  
            const nutrientOverviewHtml = await this.generateNutrientOverview();
            
            // Clear container and verify it's empty
            container.innerHTML = '';
            if (container.children.length > 0) {
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }
            
            
            // Generate plant metrics summary with design system cards
            container.innerHTML = `
                <div class="plant-metrics-summary">
                    <div class="metric-card clickable" onclick="window.app.navigateToTab('grow-beds-tab')" title="Click to view Plant Management" style="cursor: pointer;">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_number plants.svg" alt="Plants Growing" class="metric-icon-svg"></div>
                        <div class="metric-value">${totalPlants}</div>
                        <div class="metric-label">Plants Growing</div>
                    </div>
                    
                    <div class="metric-card clickable" onclick="window.app.navigateToTab('beds-overview-tab')" title="Click to view Beds Overview" style="cursor: pointer;">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_target.svg" alt="Active Batches" class="metric-icon-svg"></div>
                        <div class="metric-value">${batchStats.activeBatches}</div>
                        <div class="metric-label">Active Batches</div>
                    </div>
                    
                    <div class="metric-card clickable" onclick="window.app.navigateToHarvestReady()" title="Click to view harvest ready batches" style="cursor: pointer;">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_harvest.svg" alt="Ready for Harvest" class="metric-icon-svg"></div>
                        <div class="metric-value">${batchStats.readyForHarvest}</div>
                        <div class="metric-label">${batchStats.readyForHarvest === 0 ? 'No Batches Ready' : 'Ready for Harvest'}</div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_harvest.svg" alt="Total Harvested" class="metric-icon-svg"></div>
                        <div class="metric-value">${this.formatWeight(totalHarvested)}</div>
                        <div class="metric-label">Total Harvested</div>
                    </div>
                    
                    <div class="metric-card clickable" onclick="window.app.navigateToTab('beds-overview-tab')" title="Click to view Beds Overview" style="cursor: pointer;">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_growbed.svg" alt="Active Grow Beds" class="metric-icon-svg"></div>
                        <div class="metric-value">${activeGrowBeds}</div>
                        <div class="metric-label">Active Grow Beds</div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon"><img src="icons/new-icons/Afraponix Go Icons_crop.svg" alt="Crop Varieties" class="metric-icon-svg"></div>
                        <div class="metric-value">${uniqueCrops.size}</div>
                        <div class="metric-label">Crop Varieties</div>
                    </div>
                </div>
                
                <div class="grow-bed-capacity-stats">
                    <div class="capacity-stat-card clickable" onclick="window.app.navigateToTab('beds-overview-tab')" title="Click to view Beds Overview">
                        <h4><img src="/icons/new-icons/Afraponix Go Icons_growbed.svg" alt="Grow Beds" class="heading-icon" style="width: 1.2em; height: 1.2em; vertical-align: middle; margin-right: 0.5em;"> ${bedCapacityStats.totalBeds} Grow Beds</h4>
                        <div class="capacity-details">
                            <span class="bed-utilization" style="color: ${bedCapacityStats.utilizationColor}">
                                ${bedCapacityStats.utilizationPercent}% Utilized
                            </span>
                        </div>
                    </div>
                    
                    <div class="capacity-stat-card clickable" onclick="window.app.navigateToTab('beds-overview-tab')" title="Click to view available space">
                        <h4>üìê ${bedCapacityStats.availableSpace}m¬≤ Available</h4>
                        <div class="capacity-details">
                            <span class="space-breakdown">
                                ${bedCapacityStats.totalSpace}m¬≤ total ‚Ä¢ ${bedCapacityStats.occupiedSpace}m¬≤ occupied
                            </span>
                        </div>
                    </div>
                </div>
                
                ${nutrientOverviewHtml}
            `;
            
            // Initialize quick action buttons after rendering
            this.initializeQuickActions();
            
        } finally {
            this.plantOverviewRendering = false;
            this.plantOverviewRenderTimeout = null;
        }
    }

    async generateNutrientOverview() {
        // Generate HTML first, then update data after rendering
        const html = `
            <div class="nutrient-overview-section">
                <h3><img src="/icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Nutrients" class="heading-icon" style="width: 1.5em; height: 1.5em; vertical-align: middle; margin-right: 0.5em;"> Current Nutrient Status</h3>
                <p style="color: #666; margin-bottom: 1rem;">
                    Real-time nutrient levels and plant health indicators for optimal growth conditions.
                </p>
                <div class="nutrient-cards-grid">
                    <div class="nutrient-card clickable-nutrient-card" onclick="app.openComprehensiveNutrientModal('nitrate')" title="Click for detailed nutrient information">
                        <h4>Nitrate (NO‚ÇÉ)</h4>
                        <div class="nutrient-status" id="nitrate-status">
                            <span class="status-indicator" id="nitrate-indicator">‚óè</span>
                            <span class="status-text" id="nitrate-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-nitrate">Loading...</div>
                        <div class="chart-timestamp" id="plant-nitrate-chart-timestamp">Last updated: Loading...</div>
                    </div>
                    <div class="nutrient-card clickable-nutrient-card" onclick="app.openComprehensiveNutrientModal('phosphorus')" title="Click for detailed nutrient information">
                        <h4>Phosphorus (P)</h4>
                        <div class="nutrient-status" id="phosphorus-status">
                            <span class="status-indicator" id="phosphorus-indicator">‚óè</span>
                            <span class="status-text" id="phosphorus-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-phosphorus">Loading...</div>
                        <div class="chart-timestamp" id="plant-phosphorus-chart-timestamp">Last updated: Loading...</div>
                    </div>
                    <div class="nutrient-card clickable-nutrient-card" onclick="app.openComprehensiveNutrientModal('potassium')" title="Click for detailed nutrient information">
                        <h4>Potassium (K)</h4>
                        <div class="nutrient-status" id="potassium-status">
                            <span class="status-indicator" id="potassium-indicator">‚óè</span>
                            <span class="status-text" id="potassium-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-potassium">Loading...</div>
                        <div class="chart-timestamp" id="plant-potassium-chart-timestamp">Last updated: Loading...</div>
                    </div>
                    <div class="nutrient-card clickable-nutrient-card" onclick="app.openComprehensiveNutrientModal('iron')" title="Click for detailed nutrient information">
                        <h4>Iron (Fe)</h4>
                        <div class="nutrient-status" id="iron-status">
                            <span class="status-indicator" id="iron-indicator">‚óè</span>
                            <span class="status-text" id="iron-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-iron">Loading...</div>
                        <div class="chart-timestamp" id="plant-iron-chart-timestamp">Last updated: Loading...</div>
                    </div>
                    <div class="nutrient-card clickable-nutrient-card" onclick="app.openComprehensiveNutrientModal('calcium')" title="Click for detailed nutrient information">
                        <h4>Calcium (Ca)</h4>
                        <div class="nutrient-status" id="calcium-status">
                            <span class="status-indicator" id="calcium-indicator">‚óè</span>
                            <span class="status-text" id="calcium-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-calcium">Loading...</div>
                        <div class="chart-timestamp" id="plant-calcium-chart-timestamp">Last updated: Loading...</div>
                    </div>
                    <div class="nutrient-card">
                        <h4>EC/TDS</h4>
                        <div class="nutrient-status" id="ec-status">
                            <span class="status-indicator" id="ec-indicator">‚óè</span>
                            <span class="status-text" id="ec-status-text">No data</span>
                        </div>
                        <div class="stat-value" id="plant-ec">Loading...</div>
                        <div class="chart-timestamp" id="plant-ec-chart-timestamp">Last updated: Loading...</div>
                    </div>
                </div>
            </div>
        `;
        
        // Update nutrient data after a short delay to allow DOM rendering
        setTimeout(() => {
            this.updatePlantNutrientData().catch(console.error);
        }, 100);
        
        return html;
    }

    generateBatchStatistics(plantData) {
        const batchMap = new Map();
        let readyForHarvest = 0;
        
        
        // FIRST PASS: Process planting records to create all batches
        plantData.forEach(record => {
            if (record.batch_id && record.new_seedlings > 0) {
                // This is a planting record
                if (!batchMap.has(record.batch_id)) {
                    batchMap.set(record.batch_id, {
                        batch_id: record.batch_id,
                        crop_type: record.crop_type,
                        seed_variety: record.seed_variety,
                        days_to_harvest: record.days_to_harvest,
                        planted_count: 0,
                        harvested_count: 0,
                        date_planted: record.date
                    });
                }
                
                const batch = batchMap.get(record.batch_id);
                batch.planted_count += record.new_seedlings || 0;
            }
        });
        
        // SECOND PASS: Process harvest records now that all batches exist
        plantData.forEach(record => {
            if (record.batch_id && (record.plants_harvested > 0 || record.harvest_weight > 0)) {
                // This is a harvest record
                if (batchMap.has(record.batch_id)) {
                    const batch = batchMap.get(record.batch_id);
                    batch.harvested_count += record.plants_harvested || 0;
                }
            }
        });
        
        // Check which batches are ready for harvest
        batchMap.forEach(batch => {
            if (batch.days_to_harvest) {
                const age = this.calculateBatchAge(batch); // Pass full batch object
                if (age >= batch.days_to_harvest && batch.planted_count > batch.harvested_count) {
                    readyForHarvest++;
                }
            }
        });
        
        // Count only batches with remaining plants (not fully harvested)
        let activeBatchesCount = 0;
        batchMap.forEach(batch => {
            const remainingPlants = batch.planted_count - batch.harvested_count;
            if (remainingPlants > 0) {
                activeBatchesCount++;
            }
        });
        
        return {
            activeBatches: activeBatchesCount,
            readyForHarvest: readyForHarvest
        };
    }

    async generateBatchOverview(plantData) {
        return this.plantManagement.generateBatchOverview(plantData);
    }

    switchToPlantHarvestTab() {
        try {
            // First, switch to plants view if not already active
            const plantsView = document.getElementById('plants');
            if (plantsView && !plantsView.classList.contains('active')) {
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                plantsView.classList.add('active');
                const plantsNavBtn = document.querySelector('[data-view="plants"]');
                if (plantsNavBtn) plantsNavBtn.classList.add('active');
            }
            
            // Switch to Plant & Harvest management tab
            const plantingHarvestingTab = document.getElementById('planting-harvesting-tab');
            if (plantingHarvestingTab) {
                // Remove active from all plant management tabs and contents
                document.querySelectorAll('.plant-mgmt-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.plant-mgmt-content').forEach(c => c.classList.remove('active'));
                
                // Activate Plant & Harvest tab
                plantingHarvestingTab.classList.add('active');
                const plantingHarvestingContent = document.getElementById('planting-harvesting-content');
                if (plantingHarvestingContent) {
                    plantingHarvestingContent.classList.add('active');
                }
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('Error switching to plant harvest tab:', error);
            return false;
        }
    }
    
    switchToHarvestSubTab() {
        try {
            // Switch to harvesting sub-tab within Plant & Harvest
            const harvestingTab = document.getElementById('harvesting-tab');
            if (harvestingTab && !harvestingTab.classList.contains('active')) {
                // Remove active from all plant action tabs and contents
                document.querySelectorAll('.plant-action-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.plant-action-content').forEach(c => c.classList.remove('active'));
                
                // Activate harvesting tab
                harvestingTab.classList.add('active');
                const harvestingContent = document.getElementById('harvesting-form-content');
                if (harvestingContent) {
                    harvestingContent.classList.add('active');
                }
                
                return true;
            }
            
            return harvestingTab && harvestingTab.classList.contains('active');
        } catch (error) {
            console.error('Error switching to harvest sub-tab:', error);
            return false;
        }
    }

    harvestBatch(batchId, cropType, growBedId, remainingPlants) {
        try {
            // Show inline harvest modal instead of switching tabs
            this.showInlineHarvestModal(batchId, cropType, growBedId, remainingPlants);
        } catch (error) {
            console.error('Harvest batch error:', error);
            this.showNotification('‚ùå Could not open harvest form', 'error');
        }
    }
    
    showInlineHarvestModal(batchId, cropType, growBedId, remainingPlants) {
        
        // Hide any existing modals first
        this.hideAllModals();
        
        // Create harvest modal HTML
        const modalHtml = `
            <div class="inline-harvest-modal" id="inline-harvest-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üåæ Harvest Batch ${batchId}</h3>
                        <button class="modal-close" onclick="window.app.hideInlineHarvestModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="harvest-info">
                            <p><strong>Crop:</strong> ${this.formatCropName(cropType)}</p>
                            <p><strong>Grow Bed:</strong> ${growBedId}</p>
                            <p><strong>Available to harvest:</strong> ${remainingPlants} plants</p>
                        </div>
                        <form class="inline-harvest-form" onsubmit="event.preventDefault(); window.app.submitInlineHarvest('${batchId}', ${growBedId}, ${remainingPlants})">
                            <div class="form-group">
                                <label for="inline-harvest-count">Number of Plants to Harvest:</label>
                                <input type="number" id="inline-harvest-count" min="1" max="${remainingPlants}" required>
                                <small>Maximum: ${remainingPlants} plants</small>
                            </div>
                            <div class="form-group">
                                <label for="inline-harvest-weight">Total Weight (kg):</label>
                                <input type="number" id="inline-harvest-weight" step="0.1" min="0.1" required>
                            </div>
                            <div class="form-actions">
                                <button type="submit" class="btn-submit">üåæ Record Harvest</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = document.getElementById('inline-harvest-modal');
        
        if (modal) {
            modal.style.display = 'flex';
        } else {
            console.error('‚ùå CRITICAL: Modal element not found after creation!');
            return;
        }
        
        // Focus on first input
        const countInput = document.getElementById('inline-harvest-count');
        if (countInput) {
            countInput.focus();
        }
        
        // Add ESC key support to close modal
        const handleEscKey = (e) => {
            if (e.key === 'Escape') {
                this.hideInlineHarvestModal();
                document.removeEventListener('keydown', handleEscKey);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click-outside-to-close support
        modal.onclick = (e) => {
            if (e.target === modal) {
                this.hideInlineHarvestModal();
            }
        };
    }
    
    hideInlineHarvestModal() {
        const modal = document.getElementById('inline-harvest-modal');
        if (modal) {
            modal.remove();
        }
    }
    
    async submitInlineHarvest(batchId, growBedId, maxPlants) {
        const countInput = document.getElementById('inline-harvest-count');
        const weightInput = document.getElementById('inline-harvest-weight');
        
        const harvestCount = parseInt(countInput.value);
        const harvestWeight = parseFloat(weightInput.value);
        
        if (!harvestCount || !harvestWeight) {
            this.showNotification('Please fill in all fields', 'error');
            return;
        }
        
        if (harvestCount > maxPlants) {
            this.showNotification(`Cannot harvest more than ${maxPlants} plants`, 'error');
            return;
        }
        
        try {
            // Record the harvest using the same format as quickHarvestSubmit
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 16);
            
            
            const harvestData = {
                system_id: this.activeSystemId,
                grow_bed_id: growBedId,
                date: dateStr,
                crop_type: null, // Not needed for harvest records
                count: null, // Not applicable for harvest
                harvest_weight: harvestWeight * 1000, // Convert kg to grams
                plants_harvested: harvestCount,
                new_seedlings: null, // Not applicable for harvest
                pest_control: null,
                health: 'good',
                growth_stage: null,
                notes: null,
                batch_id: batchId,
                seed_variety: null,
                batch_created_date: null,
                days_to_harvest: null
            };
            
            
            const response = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(harvestData)
            });
            
            
            if (response) {
                this.showNotification(`‚úÖ Harvested ${harvestCount} plants (${harvestWeight}kg) from batch ${batchId}`, 'success');
                this.hideInlineHarvestModal();
                
                // Refresh plant data
                this.plantData = null; // Clear cache
                this.growBeds = null; // Clear cache
                await this.updatePlantOverview();
                
                // Refresh current tabs
                if (this.activePlantTab === 'grow-beds') {
                    await this.loadGrowBedsTab();
                }
                
                // Also refresh Beds Overview tab if it has been loaded
                const bedsOverviewContent = document.getElementById('beds-overview');
                if (bedsOverviewContent && bedsOverviewContent.innerHTML.trim() !== '') {
                    await this.loadBedsOverview();
                }
            }
        } catch (error) {
            console.error('Inline harvest error:', error);
            this.showNotification('‚ùå Failed to record harvest', 'error');
        }
    }
    
    hideAllModals() {
        // Hide any existing inline harvest modals
        const existingModal = document.getElementById('inline-harvest-modal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Hide any existing inline plant modals
        const existingPlantModal = document.getElementById('inline-plant-modal');
        if (existingPlantModal) {
            existingPlantModal.remove();
        }
        
        // Hide any existing batch selection modals
        const existingBatchModal = document.getElementById('batch-selection-modal');
        if (existingBatchModal) {
            existingBatchModal.remove();
        }
    }

    async showInlinePlantModal(bedId, bedName) {
        // Hide any existing modals first
        this.hideAllModals();
        
        // Get bed information for the modal
        const bed = this.allGrowBeds?.find(b => b.id === parseInt(bedId));
        
        // Create plant modal HTML
        const modalHtml = `
            <div class="inline-harvest-modal" id="inline-plant-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" style="width: 1.2em; height: 1.2em; vertical-align: middle; margin-right: 0.5em;"> Plant in ${bedName}</h3>
                        <button class="modal-close" onclick="window.app.hideInlinePlantModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="harvest-info">
                            <p><strong>Grow Bed:</strong> ${bedName}</p>
                            <p><strong>Bed Type:</strong> ${bed?.bed_type || 'Not specified'}</p>
                            <p><strong>Available Space:</strong> ${bed?.dimensions || 'Not specified'}</p>
                        </div>
                        <form class="inline-harvest-form" onsubmit="event.preventDefault(); window.app.submitInlinePlant('${bedId}')">
                            <div class="form-group">
                                <label for="inline-plant-crop">Crop Type:</label>
                                <select id="inline-plant-crop" required>
                                    <option value="">Select crop type...</option>
                                    <optgroup label="Leafy Greens">
                                        <option value="lettuce">Lettuce (General)</option>
                                        <option value="spinach">Spinach</option>
                                        <option value="kale">Kale</option>
                                        <option value="chard">Swiss Chard</option>
                                        <option value="arugula">Arugula</option>
                                    </optgroup>
                                    <optgroup label="Herbs">
                                        <option value="basil">Basil</option>
                                        <option value="cilantro">Cilantro</option>
                                        <option value="parsley">Parsley</option>
                                        <option value="mint">Mint</option>
                                    </optgroup>
                                    <optgroup label="Fruiting Plants">
                                        <option value="tomato">Tomato</option>
                                        <option value="pepper">Pepper</option>
                                        <option value="cucumber">Cucumber</option>
                                        <option value="strawberry">Strawberry</option>
                                    </optgroup>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="inline-plant-variety">Seed Variety (Optional):</label>
                                <input type="text" id="inline-plant-variety" placeholder="e.g., Red Oak Leaf, Cherry Tomato">
                            </div>
                            <div class="form-group">
                                <label for="inline-plant-count">Number of Plants:</label>
                                <input type="number" id="inline-plant-count" min="1" required>
                                <small>How many plants are you planting?</small>
                            </div>
                            <div class="form-group">
                                <label for="inline-plant-source">Plant Source:</label>
                                <select id="inline-plant-source">
                                    <option value="seed">From Seed</option>
                                    <option value="seedling">Seedlings</option>
                                    <option value="transplant">Transplant</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="inline-plant-notes">Notes (Optional):</label>
                                <input type="text" id="inline-plant-notes" placeholder="Any additional notes...">
                            </div>
                            <div class="form-actions">
                                <button type="submit" class="btn-submit"><img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.5em;"> Record Planting</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = document.getElementById('inline-plant-modal');
        modal.style.display = 'flex';
        
        // Focus on first input
        document.getElementById('inline-plant-crop').focus();
        
        // Add ESC key support to close modal
        const handleEscKey = (e) => {
            if (e.key === 'Escape') {
                this.hideInlinePlantModal();
                document.removeEventListener('keydown', handleEscKey);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click-outside-to-close support
        modal.onclick = (e) => {
            if (e.target === modal) {
                this.hideInlinePlantModal();
            }
        };
    }
    
    hideInlinePlantModal() {
        const modal = document.getElementById('inline-plant-modal');
        if (modal) {
            modal.remove();
        }
    }

    async showHarvestModalForBed(bedId, bedName) {
        try {
            
            // Get plant data to find harvestable batches in this bed
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            // Find active batches (planted but not fully harvested) for this bed
            const activeBatches = this.getActiveBatchesForBed(plantData, bedId);
            
            if (activeBatches.length === 0) {
                this.showNotification(`No harvestable plants found in ${bedName}`, 'info');
                return;
            }
            
            if (activeBatches.length === 1) {
                // Single batch - show harvest modal directly
                const batch = activeBatches[0];
                this.showInlineHarvestModal(batch.batchId, batch.cropType, bedId, batch.remainingPlants);
            } else {
                // Multiple batches - show selection modal
                this.showBatchSelectionModalForBed(bedName, activeBatches, bedId);
            }
            
        } catch (error) {
            console.error('‚ùå CRITICAL ERROR in showHarvestModalForBed:', error);
            console.error('‚ùå Error stack:', error.stack);
            this.showNotification('‚ùå Could not load harvest options for this bed', 'error');
        }
    }

    showBatchSelectionModalForBed(bedName, batches, bedId) {
        // Hide any existing modals first
        this.hideAllModals();
        
        const modalHtml = `
            <div class="inline-harvest-modal" id="batch-selection-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><img src="icons/new-icons/Afraponix Go Icons_harvest.svg" alt="Harvest" style="width: 1.2em; height: 1.2em; vertical-align: middle; margin-right: 0.5em;"> Select Batch to Harvest from ${bedName}</h3>
                        <button class="modal-close" onclick="window.app.hideBatchSelectionModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="harvest-info">
                            <p>Multiple batches are available for harvest in this bed. Select which batch you'd like to harvest:</p>
                        </div>
                        <div class="batch-options">
                            ${batches.map(batch => `
                                <button class="batch-option-btn" onclick="window.app.selectBatchForHarvest('${batch.batchId}', '${batch.cropType}', '${bedId}', ${batch.remainingPlants})">
                                    <div class="batch-option-header">
                                        <strong>${this.formatCropName(batch.cropType)}</strong>
                                        <span class="batch-id">Batch ${batch.batchId}</span>
                                    </div>
                                    <div class="batch-option-details">
                                        <span>üìÖ Planted: ${this.formatDate(batch.plantedDate)}</span>
                                        <span>üå± Available: ${batch.remainingPlants} plants</span>
                                    </div>
                                </button>
                            `).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = document.getElementById('batch-selection-modal');
        modal.style.display = 'flex';
        
        // Add ESC key support
        const handleEscKey = (e) => {
            if (e.key === 'Escape') {
                this.hideBatchSelectionModal();
                document.removeEventListener('keydown', handleEscKey);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click-outside-to-close support
        modal.onclick = (e) => {
            if (e.target === modal) {
                this.hideBatchSelectionModal();
            }
        };
    }

    async submitInlinePlant(bedId) {
        const cropSelect = document.getElementById('inline-plant-crop');
        const varietyInput = document.getElementById('inline-plant-variety');
        const countInput = document.getElementById('inline-plant-count');
        const sourceSelect = document.getElementById('inline-plant-source');
        const notesInput = document.getElementById('inline-plant-notes');
        
        const cropType = cropSelect.value;
        const variety = varietyInput.value.trim();
        const plantCount = parseInt(countInput.value);
        const source = sourceSelect.value;
        const notes = notesInput.value.trim();
        
        if (!cropType || !plantCount) {
            this.showNotification('Please fill in all required fields', 'error');
            return;
        }
        
        try {
            // Generate batch ID
            const now = new Date();
            const timestamp = now.getTime();
            const batchId = `${cropType}_${bedId}_${timestamp}`;
            
            const plantData = {
                grow_bed_id: parseInt(bedId),
                crop_type: cropType,
                seed_variety: variety || null,
                plant_count: plantCount,
                plants_harvested: 0,
                harvest_weight: 0,
                date_planted: now.toISOString().split('T')[0],
                expected_harvest_date: this.calculateExpectedHarvestDate(cropType),
                health: 'good',
                growth_stage: 'seedling',
                notes: notes || null,
                batch_id: batchId,
                source: source
            };
            
            
            const response = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(plantData)
            });
            
            
            if (response) {
                this.showNotification(`‚úÖ Planted ${plantCount} ${this.formatCropName(cropType)} in ${this.allGrowBeds?.find(b => b.id === parseInt(bedId))?.bed_name || `Bed ${bedId}`}`, 'success');
                this.hideInlinePlantModal();
                
                // Refresh plant data
                this.plantData = null; // Clear cache
                this.growBeds = null; // Clear cache
                await this.updatePlantOverview();
                
                // Refresh current tabs
                if (this.activePlantTab === 'grow-beds') {
                    await this.loadGrowBedsTab();
                }
                
                // Also refresh Beds Overview tab if it has been loaded
                const bedsOverviewContent = document.getElementById('beds-overview');
                if (bedsOverviewContent && bedsOverviewContent.innerHTML.trim() !== '') {
                    await this.loadBedsOverview();
                }
            }
        } catch (error) {
            console.error('Inline plant error:', error);
            this.showNotification('‚ùå Failed to record planting', 'error');
        }
    }

    calculateExpectedHarvestDate(cropType) {
        // Basic harvest timeline estimates (days to maturity)
        const harvestDays = {
            lettuce: 45,
            spinach: 40,
            kale: 55,
            chard: 50,
            arugula: 35,
            basil: 60,
            cilantro: 35,
            parsley: 70,
            mint: 80,
            tomato: 75,
            pepper: 70,
            cucumber: 55,
            strawberry: 90
        };
        
        const daysToHarvest = harvestDays[cropType] || 60; // Default to 60 days
        const harvestDate = new Date();
        harvestDate.setDate(harvestDate.getDate() + daysToHarvest);
        
        return harvestDate.toISOString().split('T')[0];
    }
    
    // Navigate to harvest ready plants with filter enabled
    navigateToHarvestReady() {
        // First navigate to the plants main tab
        const plantsBtn = document.querySelector('[data-view="plants"]');
        if (plantsBtn) {
            plantsBtn.click();
        }
        
        // Then navigate to the Plant Management tab
        setTimeout(() => {
            const plantManagementTab = document.getElementById('grow-beds-tab');
            if (plantManagementTab) {
                plantManagementTab.click();
                
                // Finally, set the filter to harvest-ready
                setTimeout(() => {
                    const filterSelect = document.getElementById('plants-filter');
                    if (filterSelect) {
                        filterSelect.value = 'harvest-ready';
                        filterSelect.dispatchEvent(new Event('change'));
                    }
                    
                    // Scroll to top after navigation
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
            }
        }, 100);
    }

    // Navigate to specific tab from stat card clicks
    navigateToTab(tabId) {
        // Handle beds overview subtab navigation
        if (tabId === 'beds-overview-tab') {
            // First activate the Plants main tab
            const plantsTab = document.getElementById('grow-beds-tab');
            if (plantsTab) {
                plantsTab.click();
                // Then activate the Beds Overview subtab
                setTimeout(() => {
                    const bedsOverviewSubtab = document.getElementById('beds-overview-subtab');
                    if (bedsOverviewSubtab) {
                        bedsOverviewSubtab.click();
                    }
                    // Scroll to top after navigation
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
            }
            return;
        }
        
        const tab = document.getElementById(tabId);
        if (tab) {
            // Handle plant management tabs (like grow-beds-tab)
            if (tabId === 'grow-beds-tab') {
                tab.click();
            }
            // Generic fallback
            else {
                tab.click();
            }
            
            // Always scroll to top when programmatically navigating to tabs
            setTimeout(() => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, 100);
        } else {
            console.error(`Tab with ID ${tabId} not found`);
        }
    }
    
    // Navigate to Fish Management tab and Tank Information subtab
    navigateToFishManagement() {
        // First, make sure the fish-tank section is visible
        const fishTankSection = document.getElementById('fish-tank');
        if (fishTankSection) {
            // Hide all other views/sections
            const allViews = document.querySelectorAll('.view');
            allViews.forEach(view => {
                view.classList.remove('active');
            });
            
            // Show the fish-tank section
            fishTankSection.classList.add('active');
            
            // Then activate the Tank Information subtab
            setTimeout(() => {
                const tankInfoTab = document.getElementById('tank-information-tab');
                if (tankInfoTab) {
                    tankInfoTab.click();
                }
                // Scroll to top after navigation
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, 100);
        } else {
            console.error('Fish tank section not found');
            // Fallback: try the direct tab approach
            this.navigateToTab('tank-information-tab');
        }
    }
    
    // Calculate grow bed capacity metrics
    calculateBedCapacityMetrics(growBeds, plantData) {
        if (!growBeds || growBeds.length === 0) {
            return {
                totalBeds: 0,
                totalSpace: 0,
                occupiedSpace: 0,
                availableSpace: 0,
                utilizationPercent: 0,
                utilizationColor: '#999'
            };
        }
        
        // Calculate total space using correct field names from grow_beds table
        const totalSpace = growBeds.reduce((sum, bed) => {
            let area = 0;
            
            // Use equivalent_m2 if available (calculated planting area)
            if (bed.equivalent_m2 && !isNaN(bed.equivalent_m2)) {
                area = parseFloat(bed.equivalent_m2);
            }
            // Fall back to area_m2 (total bed area)
            else if (bed.area_m2 && !isNaN(bed.area_m2)) {
                area = parseFloat(bed.area_m2);
            }
            // Calculate from dimensions if available
            else if (bed.length_meters && bed.width_meters && !isNaN(bed.length_meters) && !isNaN(bed.width_meters)) {
                area = parseFloat(bed.length_meters) * parseFloat(bed.width_meters);
            }
            
            return sum + area;
        }, 0);
        
        // Calculate occupied space using same method as bed displays
        let occupiedSpace = 0;
        
        // Calculate occupied space from plant data
        if (plantData && plantData.length > 0) {
            // Count total active plants (planted - harvested)
            let totalActivePlants = 0;
            const plantCounts = new Map(); // batch_id -> count
            
            plantData.forEach(entry => {
                if (entry.batch_id) {
                    // Add planted plants
                    if (entry.new_seedlings && entry.new_seedlings > 0) {
                        const existing = plantCounts.get(entry.batch_id) || 0;
                        plantCounts.set(entry.batch_id, existing + entry.new_seedlings);
                    }
                    
                    // Subtract harvested plants
                    if (entry.plants_harvested && entry.plants_harvested > 0) {
                        const existing = plantCounts.get(entry.batch_id) || 0;
                        plantCounts.set(entry.batch_id, Math.max(0, existing - entry.plants_harvested));
                    }
                }
            });
            
            // Sum up all active plants
            plantCounts.forEach(count => {
                totalActivePlants += count;
            });
            
            // Use same calculation as bed displays: average 20cm spacing = 0.04m¬≤ per plant
            const avgSpacingM2 = 0.04;
            occupiedSpace = totalActivePlants * avgSpacingM2;
        }
        
        const availableSpace = Math.max(0, totalSpace - occupiedSpace);
        const utilizationPercent = totalSpace > 0 ? Math.round((occupiedSpace / totalSpace) * 100) : 0;
        
        // Color coding for utilization
        let utilizationColor;
        if (utilizationPercent >= 70) {
            utilizationColor = '#e74c3c'; // Red - high utilization
        } else if (utilizationPercent >= 30) {
            utilizationColor = '#f39c12'; // Orange - medium utilization
        } else {
            utilizationColor = '#27ae60'; // Green - low utilization
        }
        
        // Ensure all values are numbers before formatting
        const safeTotal = isNaN(totalSpace) ? 0 : totalSpace;
        const safeOccupied = isNaN(occupiedSpace) ? 0 : occupiedSpace;
        const safeAvailable = isNaN(availableSpace) ? 0 : availableSpace;
        const safeUtilization = isNaN(utilizationPercent) ? 0 : utilizationPercent;

        return {
            totalBeds: growBeds.length,
            totalSpace: safeTotal.toFixed(1),
            occupiedSpace: safeOccupied.toFixed(1),
            availableSpace: safeAvailable.toFixed(1),
            utilizationPercent: safeUtilization,
            utilizationColor
        };
    }
    
    // Main Dashboard Farm Layout Methods
    async updateMainFarmLayout() {
        try {
            // Initialize layout controls for main dashboard
            this.setupMainLayoutControls();
            
            // Load and render farm components for main dashboard
            await this.renderMainFarmLayout();
            
        } catch (error) {
            console.error('Error updating main farm layout:', error);
            this.showMainFarmLayoutError('Failed to load farm layout');
        }
    }
    
    setupMainLayoutControls() {
        // Initialize layout variables for main dashboard
        this.mainLayoutScale = 1;
        this.mainLayoutPanX = 0;
        this.mainLayoutPanY = 0;
        this.mainLabelsVisible = true;
        
        // Get control elements
        const zoomInBtn = document.getElementById('main-zoom-in-btn');
        const zoomOutBtn = document.getElementById('main-zoom-out-btn');
        const resetViewBtn = document.getElementById('main-reset-view-btn');
        const toggleLabelsBtn = document.getElementById('main-toggle-labels-btn');
        
        // Add event listeners (remove existing ones first)
        if (zoomInBtn) {
            const newZoomInBtn = zoomInBtn.cloneNode(true);
            zoomInBtn.replaceWith(newZoomInBtn);
            newZoomInBtn.addEventListener('click', () => this.zoomMainLayout(1.2));
        }
        if (zoomOutBtn) {
            const newZoomOutBtn = zoomOutBtn.cloneNode(true);
            zoomOutBtn.replaceWith(newZoomOutBtn);
            newZoomOutBtn.addEventListener('click', () => this.zoomMainLayout(0.8));
        }
        if (resetViewBtn) {
            const newResetViewBtn = resetViewBtn.cloneNode(true);
            resetViewBtn.replaceWith(newResetViewBtn);
            newResetViewBtn.addEventListener('click', () => this.resetMainLayoutView());
        }
        if (toggleLabelsBtn) {
            const newToggleLabelsBtn = toggleLabelsBtn.cloneNode(true);
            toggleLabelsBtn.replaceWith(newToggleLabelsBtn);
            newToggleLabelsBtn.addEventListener('click', () => this.toggleMainLayoutLabels());
        }
        
        // Add pan functionality
        this.setupMainPanControls();
    }
    
    setupMainPanControls() {
        const svg = document.getElementById('main-farm-layout-svg');
        if (!svg) return;
        
        // Remove existing event listeners by cloning
        const newSvg = svg.cloneNode(true);
        svg.parentNode.replaceChild(newSvg, svg);
        
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        
        const currentSvg = document.getElementById('main-farm-layout-svg');
        
        currentSvg.addEventListener('mousedown', (e) => {
            isPanning = true;
            startX = e.clientX - this.mainLayoutPanX;
            startY = e.clientY - this.mainLayoutPanY;
            currentSvg.style.cursor = 'grabbing';
        });
        
        currentSvg.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            this.mainLayoutPanX = e.clientX - startX;
            this.mainLayoutPanY = e.clientY - startY;
            this.updateMainLayoutTransform();
        });
        
        currentSvg.addEventListener('mouseup', () => {
            isPanning = false;
            currentSvg.style.cursor = 'grab';
        });
        
        currentSvg.addEventListener('mouseleave', () => {
            isPanning = false;
            currentSvg.style.cursor = 'grab';
        });
        
        // Touch support
        currentSvg.addEventListener('touchstart', (e) => {
            isPanning = true;
            const touch = e.touches[0];
            startX = touch.clientX - this.mainLayoutPanX;
            startY = touch.clientY - this.mainLayoutPanY;
            e.preventDefault();
        });
        
        currentSvg.addEventListener('touchmove', (e) => {
            if (!isPanning) return;
            
            const touch = e.touches[0];
            this.mainLayoutPanX = touch.clientX - startX;
            this.mainLayoutPanY = touch.clientY - startY;
            this.updateMainLayoutTransform();
            e.preventDefault();
        });
        
        currentSvg.addEventListener('touchend', () => {
            isPanning = false;
        });
    }
    
    async renderMainFarmLayout() {
        try {
            // Early return if no active system selected
            if (!this.activeSystemId || this.activeSystemId === 'undefined') {
                return;
            }
            
            // Fetch system data
            const [fishTanksResponse, growBeds, plantData] = await Promise.all([
                this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}`).catch(() => ({ tanks: [] })),
                this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`),
                this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`)
            ]);
            
            // Extract fish tanks array from response object, with fallback to system config
            let fishTanks = fishTanksResponse?.tanks || [];
            
            // If no tank data from API, create fallback tanks from system configuration
            if (!fishTanks || fishTanks.length === 0) {
                const systemData = this.getActiveSystem();
                if (systemData && systemData.fish_tank_count > 0) {
                    const tankCount = systemData.fish_tank_count || 1;
                    const tankVolume = systemData.total_fish_volume || 1000;
                    const volumePerTankLiters = Math.floor(tankVolume / tankCount);
                    const volumePerTankM3 = volumePerTankLiters / 1000;
                    
                    fishTanks = [];
                    for (let i = 1; i <= tankCount; i++) {
                        fishTanks.push({
                            id: i,
                            tank_number: i,
                            size_m3: volumePerTankM3,
                            volume_liters: volumePerTankLiters,
                            fish_type: 'tilapia' // default fish type
                        });
                    }
                }
            }
            
            // Calculate layout bounds and positioning
            const layoutData = this.calculateLayoutPositions(fishTanks, growBeds, plantData);
            
            // Render components
            this.renderMainFarmComponents(layoutData);
            
            // Update scale and stats
            this.updateMainLayoutScale(layoutData.bounds);
            this.updateMainLayoutStats(layoutData);
            
        } catch (error) {
            console.error('Error rendering main farm layout:', error);
            this.showMainFarmLayoutError('Failed to render components');
        }
    }
    
    renderMainFarmComponents(layoutData) {
        const svg = document.getElementById('main-farm-layout-svg');
        const componentsGroup = document.getElementById('main-farm-components');
        
        if (!svg || !componentsGroup) return;
        
        // Clear existing components
        componentsGroup.innerHTML = '';
        
        // Update SVG viewBox to fit all components
        const bounds = layoutData.bounds;
        svg.setAttribute('viewBox', `${bounds.minX} ${bounds.minY} ${bounds.width} ${bounds.height}`);
        
        // Render each component
        layoutData.components.forEach(comp => {
            if (comp.type === 'tank') {
                this.renderMainTank(componentsGroup, comp);
            } else {
                this.renderMainGrowBed(componentsGroup, comp);
            }
        });
    }
    
    renderMainTank(parent, tank) {
        const tankGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        tankGroup.setAttribute('class', 'farm-tank-group');
        
        // Tank circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', tank.x);
        circle.setAttribute('cy', tank.y);
        circle.setAttribute('r', tank.diameter / 2);
        circle.setAttribute('class', 'farm-tank');
        circle.setAttribute('data-tank-id', tank.id);
        
        // Add circle first (background layer)
        tankGroup.appendChild(circle);
        
        // Tank labels (foreground layer)
        if (this.mainLabelsVisible) {
            // Tank number above the tank
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', tank.x);
            label.setAttribute('y', tank.y - tank.diameter/2 - 25);
            label.setAttribute('class', 'tank-header-label');
            label.setAttribute('text-anchor', 'middle');
            label.textContent = `Tank ${tank.name}`;
            tankGroup.appendChild(label);
            
            // Fish count on top of tank
            const fishInfo = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            fishInfo.setAttribute('x', tank.x);
            fishInfo.setAttribute('y', tank.y - 5);
            fishInfo.setAttribute('class', 'tank-overlay-text');
            fishInfo.setAttribute('text-anchor', 'middle');
            fishInfo.textContent = `${tank.fishCount} fish`;
            tankGroup.appendChild(fishInfo);
            
            // Density info on top of tank (below fish count)
            const densityInfo = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            densityInfo.setAttribute('x', tank.x);
            densityInfo.setAttribute('y', tank.y + 10);
            densityInfo.setAttribute('class', 'tank-overlay-text');
            densityInfo.setAttribute('text-anchor', 'middle');
            densityInfo.textContent = `${tank.density} kg/m¬≥`;
            tankGroup.appendChild(densityInfo);
        }
        parent.appendChild(tankGroup);
        
        // Add hover/click handlers
        this.addMainComponentInteractions(circle, tank);
    }
    
    renderMainGrowBed(parent, bed) {
        const bedGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        bedGroup.setAttribute('class', 'farm-bed-group');
        
        // Base bed rectangle (always gray)
        const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        baseRect.setAttribute('x', bed.x);
        baseRect.setAttribute('y', bed.y);
        baseRect.setAttribute('width', bed.width);
        baseRect.setAttribute('height', bed.height);
        baseRect.setAttribute('class', 'farm-grow-bed empty');
        baseRect.setAttribute('data-bed-id', bed.id);
        
        // Apply pattern based on bed type
        if (bed.bedType === 'nft') {
            baseRect.setAttribute('fill', 'url(#main-nft-pattern)');
        } else if (bed.bedType === 'dwc') {
            baseRect.setAttribute('fill', 'url(#main-dwc-pattern)');
        }
        
        bedGroup.appendChild(baseRect);
        
        // Add green fill overlay for planted percentage
        if (bed.plantedPercentage > 0) {
            const plantedRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            plantedRect.setAttribute('x', bed.x);
            plantedRect.setAttribute('y', bed.y);
            plantedRect.setAttribute('width', bed.width * (bed.plantedPercentage / 100));
            plantedRect.setAttribute('height', bed.height);
            plantedRect.setAttribute('class', 'farm-grow-bed planted');
            plantedRect.setAttribute('pointer-events', 'none'); // Don't interfere with base rect interactions
            plantedRect.setAttribute('fill-opacity', '0.7');
            bedGroup.appendChild(plantedRect);
        }
        
        // Add batch visualization with dotted lines and labels
        let totalBatchWidth = 0;
        if (bed.batches && bed.batches.length > 0) {
            let accumulatedWidth = 0;
            bed.batches.forEach((batch, index) => {
                // Calculate batch width based on its area proportion
                const batchWidth = bed.width * (batch.area / bed.equivalentArea);
                
                // Add dotted line separator (except for the first batch)
                if (index > 0) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', bed.x + accumulatedWidth);
                    line.setAttribute('y1', bed.y);
                    line.setAttribute('x2', bed.x + accumulatedWidth);
                    line.setAttribute('y2', bed.y + bed.height);
                    line.setAttribute('stroke', '#ffffff');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-dasharray', '4,4');
                    line.setAttribute('opacity', '0.8');
                    line.setAttribute('pointer-events', 'none');
                    bedGroup.appendChild(line);
                }
                
                // Add invisible rect for batch hover
                const batchRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                batchRect.setAttribute('x', bed.x + accumulatedWidth);
                batchRect.setAttribute('y', bed.y);
                batchRect.setAttribute('width', batchWidth);
                batchRect.setAttribute('height', bed.height);
                batchRect.setAttribute('fill', 'transparent');
                batchRect.setAttribute('class', 'batch-hover-area');
                batchRect.setAttribute('data-batch-id', batch.id);
                
                // Add batch hover events
                batchRect.addEventListener('mouseenter', (e) => {
                    this.showBatchTooltip(e, batch, bed);
                });
                batchRect.addEventListener('mouseleave', () => {
                    this.hideLayoutTooltip();
                });
                
                // Add batch click event
                batchRect.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent bed click handler
                    this.modalManager.showBatchModal(batch, bed);
                });
                
                bedGroup.appendChild(batchRect);
                
                // Add batch label if labels are visible
                if (this.mainLabelsVisible && batchWidth > 30) { // Only show if batch is wide enough
                    const batchLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    batchLabel.setAttribute('x', bed.x + accumulatedWidth + batchWidth / 2);
                    batchLabel.setAttribute('y', bed.y + bed.height / 2);
                    batchLabel.setAttribute('class', 'batch-label');
                    batchLabel.setAttribute('text-anchor', 'middle');
                    batchLabel.setAttribute('pointer-events', 'none');
                    const cropName = this.cleanCustomCropName ? this.cleanCustomCropName(batch.cropName) : batch.cropName;
                    batchLabel.textContent = cropName;
                    bedGroup.appendChild(batchLabel);
                }
                
                accumulatedWidth += batchWidth;
            });
            totalBatchWidth = accumulatedWidth;
        }
        
        // Add hover area for empty space (if any)
        if (totalBatchWidth < bed.width) {
            const emptyWidth = bed.width - totalBatchWidth;
            const emptyRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            emptyRect.setAttribute('x', bed.x + totalBatchWidth);
            emptyRect.setAttribute('y', bed.y);
            emptyRect.setAttribute('width', emptyWidth);
            emptyRect.setAttribute('height', bed.height);
            emptyRect.setAttribute('fill', 'transparent');
            emptyRect.setAttribute('class', 'empty-space-hover-area');
            
            // Add empty space hover events
            emptyRect.addEventListener('mouseenter', (e) => {
                this.showEmptySpaceTooltip(e, bed);
            });
            emptyRect.addEventListener('mouseleave', () => {
                this.hideLayoutTooltip();
            });
            
            bedGroup.appendChild(emptyRect);
            
            // Add "Available" label if space is wide enough
            if (this.mainLabelsVisible && emptyWidth > 60) {
                const availableLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                availableLabel.setAttribute('x', bed.x + totalBatchWidth + emptyWidth / 2);
                availableLabel.setAttribute('y', bed.y + bed.height / 2);
                availableLabel.setAttribute('class', 'available-space-label');
                availableLabel.setAttribute('text-anchor', 'middle');
                availableLabel.setAttribute('pointer-events', 'none');
                availableLabel.textContent = 'Available';
                bedGroup.appendChild(availableLabel);
            }
        }
        
        // Bed label (above the bed)
        if (this.mainLabelsVisible) {
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', bed.x + bed.width / 2);
            label.setAttribute('y', bed.y - 10);
            label.setAttribute('class', 'bed-header-label');
            label.setAttribute('text-anchor', 'middle');
            label.textContent = bed.name;
            bedGroup.appendChild(label);
        }
        
        parent.appendChild(bedGroup);
        
        // Add hover/click handlers to the base rect
        this.addMainComponentInteractions(baseRect, bed);
    }
    
    addMainComponentInteractions(element, component) {
        // Hover tooltip
        element.addEventListener('mouseenter', (e) => {
            this.showLayoutTooltip(e, component);
        });
        
        element.addEventListener('mouseleave', () => {
            this.hideLayoutTooltip();
        });
        
        // Click handler
        element.addEventListener('click', () => {
            this.handleComponentClick(component);
        });
    }
    
    zoomMainLayout(factor) {
        this.mainLayoutScale *= factor;
        this.mainLayoutScale = Math.max(0.5, Math.min(2, this.mainLayoutScale)); // Limit zoom range
        this.updateMainLayoutTransform();
    }
    
    resetMainLayoutView() {
        this.mainLayoutScale = 1;
        this.mainLayoutPanX = 0;
        this.mainLayoutPanY = 0;
        this.updateMainLayoutTransform();
    }
    
    toggleMainLayoutLabels() {
        this.mainLabelsVisible = !this.mainLabelsVisible;
        const labels = document.querySelectorAll('#main-farm-components .component-label, #main-farm-components .component-info');
        labels.forEach(label => {
            label.style.display = this.mainLabelsVisible ? 'block' : 'none';
        });
        
        // Update button appearance
        const btn = document.getElementById('main-toggle-labels-btn');
        if (btn) {
            btn.style.opacity = this.mainLabelsVisible ? '1' : '0.6';
        }
    }
    
    updateMainLayoutTransform() {
        const componentsGroup = document.getElementById('main-farm-components');
        if (componentsGroup) {
            componentsGroup.style.transform = `translate(${this.mainLayoutPanX}px, ${this.mainLayoutPanY}px) scale(${this.mainLayoutScale})`;
        }
    }
    
    updateMainLayoutScale(bounds) {
        const scaleIndicator = document.getElementById('main-scale-indicator');
        const scaleText = document.getElementById('main-scale-text');
        
        if (scaleIndicator && scaleText && bounds) {
            // Position scale indicator closer to content at bottom left
            const bottomY = bounds.maxY - 30;
            const leftX = bounds.minX + 20;
            scaleIndicator.setAttribute('transform', `translate(${leftX}, ${bottomY})`);
            
            // Update scale text
            const pixelsPerMeter = 50;
            const actualScale = pixelsPerMeter * this.mainLayoutScale;
            scaleText.textContent = `Scale: 1cm = ${(50/actualScale).toFixed(1)}m`;
        }
    }
    
    updateMainLayoutStats(layoutData) {
        const statsElement = document.getElementById('main-layout-stats');
        if (statsElement) {
            statsElement.innerHTML = `
                <span>Tanks: ${layoutData.fishTanks}</span>
                <span>Beds: ${layoutData.growBeds}</span>
                <span>Total Area: ${layoutData.totalArea.toFixed(1)}m¬≤</span>
            `;
        }
    }
    
    showMainFarmLayoutError(message) {
        const componentsGroup = document.getElementById('main-farm-components');
        if (componentsGroup) {
            componentsGroup.innerHTML = `
                <text x="400" y="300" text-anchor="middle" fill="#ef4444" font-size="16">
                    ‚ö†Ô∏è ${message}
                </text>
            `;
        }
    }
    
    // Farm Layout Dashboard Methods
    async initializeFarmLayout() {
        try {
            // Initialize layout controls
            this.setupLayoutControls();
            
            // Load and render farm components
            await this.renderFarmLayout();
            
        } catch (error) {
            console.error('Error initializing farm layout:', error);
            this.showFarmLayoutError('Failed to load farm layout');
        }
    }
    
    setupLayoutControls() {
        // Initialize layout variables
        this.layoutScale = 1;
        this.layoutPanX = 0;
        this.layoutPanY = 0;
        this.labelsVisible = true;
        
        // Get control elements
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const toggleLabelsBtn = document.getElementById('toggle-labels-btn');
        
        // Add event listeners
        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => this.zoomLayout(1.2));
        }
        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => this.zoomLayout(0.8));
        }
        if (resetViewBtn) {
            resetViewBtn.addEventListener('click', () => this.resetLayoutView());
        }
        if (toggleLabelsBtn) {
            toggleLabelsBtn.addEventListener('click', () => this.toggleLayoutLabels());
        }
        
        // Add pan functionality
        this.setupPanControls();
    }
    
    setupPanControls() {
        const svg = document.getElementById('farm-layout-svg');
        if (!svg) return;
        
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        
        svg.addEventListener('mousedown', (e) => {
            isPanning = true;
            startX = e.clientX - this.layoutPanX;
            startY = e.clientY - this.layoutPanY;
            svg.style.cursor = 'grabbing';
        });
        
        svg.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            this.layoutPanX = e.clientX - startX;
            this.layoutPanY = e.clientY - startY;
            this.updateLayoutTransform();
        });
        
        svg.addEventListener('mouseup', () => {
            isPanning = false;
            svg.style.cursor = 'grab';
        });
        
        svg.addEventListener('mouseleave', () => {
            isPanning = false;
            svg.style.cursor = 'grab';
        });
        
        // Touch support
        svg.addEventListener('touchstart', (e) => {
            isPanning = true;
            const touch = e.touches[0];
            startX = touch.clientX - this.layoutPanX;
            startY = touch.clientY - this.layoutPanY;
            e.preventDefault();
        });
        
        svg.addEventListener('touchmove', (e) => {
            if (!isPanning) return;
            
            const touch = e.touches[0];
            this.layoutPanX = touch.clientX - startX;
            this.layoutPanY = touch.clientY - startY;
            this.updateLayoutTransform();
            e.preventDefault();
        });
        
        svg.addEventListener('touchend', () => {
            isPanning = false;
        });
    }
    
    async renderFarmLayout() {
        return this.farmLayoutRenderer.renderFarmLayout();
    }
    
    calculateLayoutPositions(fishTanks, growBeds, plantData) {
        return this.farmLayoutRenderer.calculateLayoutPositions(fishTanks, growBeds, plantData);
    }
    
    calculateTankDiameter(volume) {
        return this.farmLayoutRenderer.calculateTankDiameter(volume);
    }
    
    getFishCount(tankId, plantData) {
        return this.farmLayoutRenderer.getFishCount(tankId, plantData);
    }
    
    getBedBatches(bedId, plantData, spacing) {
        if (!Array.isArray(plantData) || plantData.length === 0) {
            return [];
        }
        
        const batches = new Map();
        
        // Collect batch data
        plantData.forEach(entry => {
            if (entry.grow_bed_id == bedId && entry.batch_id) {
                if (!batches.has(entry.batch_id)) {
                    // Debug: log available fields for the first entry
                    if (Object.keys(batches).length === 0) {
                    }
                    
                    // Try multiple possible field names for crop
                    const cropName = entry.crop_name || entry.crop_type || entry.plant_name || entry.variety || 'Unknown';
                    batches.set(entry.batch_id, {
                        id: entry.batch_id,
                        plantCount: 0,
                        cropName: cropName,
                        plantedDate: entry.planting_date || entry.date_planted || entry.created_at
                    });
                }
                
                // Update crop name if we find a better one in subsequent entries
                const batch = batches.get(entry.batch_id);
                if (batch.cropName === 'Unknown' && entry.crop_name) {
                    batch.cropName = entry.crop_name;
                } else if (batch.cropName === 'Unknown' && entry.crop_type) {
                    batch.cropName = entry.crop_type;
                } else if (batch.cropName === 'Unknown' && entry.plant_name) {
                    batch.cropName = entry.plant_name;
                } else if (batch.cropName === 'Unknown' && entry.variety) {
                    batch.cropName = entry.variety;
                }
                
                // Add planted plants
                if (entry.new_seedlings && entry.new_seedlings > 0) {
                    batch.plantCount += entry.new_seedlings;
                }
                
                // Subtract harvested plants
                if (entry.plants_harvested && entry.plants_harvested > 0) {
                    batch.plantCount = Math.max(0, batch.plantCount - entry.plants_harvested);
                }
            }
        });
        
        // Convert to array and calculate area for each batch
        const batchArray = [];
        batches.forEach(batch => {
            if (batch.plantCount > 0) {
                batch.area = batch.plantCount * spacing;
                batchArray.push(batch);
            }
        });
        
        return batchArray;
    }
    
    getBedPlantCount(bedId, plantData) {
        if (!Array.isArray(plantData) || plantData.length === 0) {
            return 0;
        }
        
        let plantCount = 0;
        const plantCounts = new Map();
        
        
        plantData.forEach(entry => {
            // Use == for type coercion since bed IDs might be strings or numbers
            if (entry.grow_bed_id == bedId && entry.batch_id) {
                
                // Add planted plants
                if (entry.new_seedlings && entry.new_seedlings > 0) {
                    const existing = plantCounts.get(entry.batch_id) || 0;
                    plantCounts.set(entry.batch_id, existing + entry.new_seedlings);
                }
                
                // Subtract harvested plants
                if (entry.plants_harvested && entry.plants_harvested > 0) {
                    const existing = plantCounts.get(entry.batch_id) || 0;
                    const newCount = Math.max(0, existing - entry.plants_harvested);
                    plantCounts.set(entry.batch_id, newCount);
                }
            }
        });
        
        
        plantCounts.forEach(count => {
            plantCount += count;
        });
        
        return plantCount;
    }
    
    calculateBounds(components, margin) {
        return this.farmLayoutRenderer.calculateBounds(components, margin);
    }
    
    calculateTotalArea(growBeds) {
        return this.farmLayoutRenderer.calculateTotalArea(growBeds);
    }
    
    renderFarmComponents(layoutData) {
        const svg = document.getElementById('farm-layout-svg');
        const componentsGroup = document.getElementById('farm-components');
        
        if (!svg || !componentsGroup) return;
        
        // Clear existing components
        componentsGroup.innerHTML = '';
        
        // Update SVG viewBox to fit all components
        const bounds = layoutData.bounds;
        svg.setAttribute('viewBox', `${bounds.minX} ${bounds.minY} ${bounds.width} ${bounds.height}`);
        
        // Render each component
        layoutData.components.forEach(comp => {
            if (comp.type === 'tank') {
                this.renderTank(componentsGroup, comp);
            } else {
                this.renderGrowBed(componentsGroup, comp);
            }
        });
    }
    
    renderTank(parent, tank) {
        const tankGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        tankGroup.setAttribute('class', 'farm-tank-group');
        
        // Tank circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', tank.x);
        circle.setAttribute('cy', tank.y);
        circle.setAttribute('r', tank.diameter / 2);
        circle.setAttribute('class', 'farm-tank');
        circle.setAttribute('data-tank-id', tank.id);
        
        // Tank label
        if (this.labelsVisible) {
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', tank.x);
            label.setAttribute('y', tank.y - 5);
            label.setAttribute('class', 'component-label');
            label.textContent = tank.name;
            tankGroup.appendChild(label);
            
            // Tank info
            const info = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            info.setAttribute('x', tank.x);
            info.setAttribute('y', tank.y + 20);
            info.setAttribute('class', 'component-info');
            info.textContent = `${tank.fishCount} fish ‚Ä¢ ${tank.density} kg/m¬≥`;
            tankGroup.appendChild(info);
        }
        
        tankGroup.appendChild(circle);
        parent.appendChild(tankGroup);
        
        // Add hover/click handlers
        this.addComponentInteractions(circle, tank);
    }
    
    renderGrowBed(parent, bed) {
        const bedGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        bedGroup.setAttribute('class', 'farm-bed-group');
        
        // Bed rectangle
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', bed.x);
        rect.setAttribute('y', bed.y);
        rect.setAttribute('width', bed.width);
        rect.setAttribute('height', bed.height);
        rect.setAttribute('class', `farm-grow-bed ${bed.status}`);
        rect.setAttribute('data-bed-id', bed.id);
        
        // Apply pattern based on bed type
        if (bed.bedType === 'nft') {
            rect.setAttribute('fill', 'url(#nft-pattern)');
        } else if (bed.bedType === 'dwc') {
            rect.setAttribute('fill', 'url(#dwc-pattern)');
        }
        
        // Bed label
        if (this.labelsVisible) {
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', bed.x + bed.width / 2);
            label.setAttribute('y', bed.y + bed.height / 2 - 5);
            label.setAttribute('class', 'component-label');
            label.textContent = bed.name;
            bedGroup.appendChild(label);
            
            // Bed info
            const info = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            info.setAttribute('x', bed.x + bed.width / 2);
            info.setAttribute('y', bed.y + bed.height / 2 + 15);
            info.setAttribute('class', 'component-info');
            const availableText = bed.availableArea ? ` ‚Ä¢ ${bed.availableArea.toFixed(1)}m¬≤ available` : '';
            info.textContent = `${bed.dimensions} ‚Ä¢ ${bed.plantCount} plants${availableText}`;
            bedGroup.appendChild(info);
        }
        
        bedGroup.appendChild(rect);
        parent.appendChild(bedGroup);
        
        // Add hover/click handlers
        this.addComponentInteractions(rect, bed);
    }
    
    addComponentInteractions(element, component) {
        // Hover tooltip
        element.addEventListener('mouseenter', (e) => {
            this.showLayoutTooltip(e, component);
        });
        
        element.addEventListener('mouseleave', () => {
            this.hideLayoutTooltip();
        });
        
        // Click handler
        element.addEventListener('click', () => {
            this.handleComponentClick(component);
        });
    }
    
    showEmptySpaceTooltip(event, bed) {
        // Remove any existing tooltip first
        this.hideLayoutTooltip();
        
        const tooltip = document.createElement('div');
        tooltip.className = 'layout-tooltip';
        tooltip.id = 'layout-tooltip';
        tooltip.style.position = 'fixed';
        tooltip.style.zIndex = '10000';
        tooltip.style.pointerEvents = 'none';
        
        const availableArea = bed.availableArea || 0;
        const avgSpacing = 0.04; // Same spacing used in calculations
        const availablePlants = Math.floor(availableArea / avgSpacing);
        
        tooltip.innerHTML = `
            <strong>Available Space</strong><br>
            Bed: ${bed.name}<br>
            Area: ${availableArea.toFixed(2)}m¬≤<br>
            Capacity: ~${availablePlants} plants<br>
            Status: Ready for planting
        `;
        
        document.body.appendChild(tooltip);
        
        // Position tooltip
        const rect = event.target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Keep tooltip within viewport
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
    }
    
    showBatchTooltip(event, batch, bed) {
        // Remove any existing tooltip first
        this.hideLayoutTooltip();
        
        const tooltip = document.createElement('div');
        tooltip.className = 'layout-tooltip';
        tooltip.id = 'layout-tooltip';
        tooltip.style.position = 'fixed';
        tooltip.style.zIndex = '10000';
        tooltip.style.pointerEvents = 'none';
        
        const cropName = this.cleanCustomCropName ? this.cleanCustomCropName(batch.cropName) : batch.cropName;
        const plantedDate = batch.plantedDate ? new Date(batch.plantedDate).toLocaleDateString() : 'Unknown';
        
        tooltip.innerHTML = `
            <strong>Batch #${batch.id}</strong><br>
            Crop: ${cropName}<br>
            Plants: ${batch.plantCount}<br>
            Area: ${batch.area.toFixed(2)}m¬≤<br>
            Planted: ${plantedDate}
        `;
        
        document.body.appendChild(tooltip);
        
        // Position tooltip
        const rect = event.target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Keep tooltip within viewport
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
    }
    
    showLayoutTooltip(event, component) {
        // Remove any existing tooltip first
        this.hideLayoutTooltip();
        
        // Implementation for tooltip display
        const tooltip = document.createElement('div');
        tooltip.className = 'layout-tooltip';
        tooltip.id = 'layout-tooltip';
        tooltip.style.position = 'fixed';
        tooltip.style.zIndex = '10000';
        tooltip.style.pointerEvents = 'none';
        
        if (component.type === 'tank') {
            tooltip.innerHTML = `
                <strong>Tank ${component.name}</strong><br>
                Fish: ${component.fishCount}<br>
                Density: ${component.density} kg/m¬≥<br>
                Type: ${component.fishType}
            `;
        } else {
            const percentageText = component.plantedPercentage !== undefined 
                ? `${component.plantedPercentage.toFixed(0)}%` 
                : 'N/A';
            const availableText = component.availableArea !== undefined 
                ? `${component.availableArea.toFixed(1)}m¬≤` 
                : 'N/A';
            tooltip.innerHTML = `
                <strong>${component.name}</strong><br>
                Type: ${component.bedType.toUpperCase()}<br>
                Size: ${component.dimensions}<br>
                Plants: ${component.plantCount} (${percentageText} planted)<br>
                Available: ${availableText}<br>
                Status: ${component.status}
            `;
        }
        
        document.body.appendChild(tooltip);
        
        // Position tooltip with better calculation
        const rect = event.target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Keep tooltip within viewport
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = rect.bottom + 10; // Show below if no space above
        }
        
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.style.opacity = '1';
    }
    
    hideLayoutTooltip() {
        const tooltip = document.getElementById('layout-tooltip');
        if (tooltip) {
            tooltip.remove();
        }
    }
    
    showTankModal(tank) {
        // Hide any tooltips first
        this.hideLayoutTooltip();
        
        // Debug: Log tank data to understand structure
        
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.id = 'component-modal-overlay';
        
        // Create modal content
        const modal = document.createElement('div');
        modal.className = 'modal-content';
        
        const cropName = this.cleanCustomCropName ? this.cleanCustomCropName(tank.fishType) : tank.fishType;
        
        modal.innerHTML = `
            <div class="modal-header">
                <h2><img src="/icons/new-icons/Afraponix Go Icons_fish.svg" alt="Fish" class="heading-icon" style="width: 1.5em; height: 1.5em; vertical-align: middle; margin-right: 0.5em;"> Tank ${tank.name} Details</h2>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="modal-info-grid">
                    <div class="info-item">
                        <label>Tank Number:</label>
                        <span>${tank.name}</span>
                    </div>
                    <div class="info-item">
                        <label>Fish Type:</label>
                        <span>${cropName}</span>
                    </div>
                    <div class="info-item">
                        <label>Fish Count:</label>
                        <span>${tank.fishCount} fish</span>
                    </div>
                    <div class="info-item">
                        <label>Volume:</label>
                        <span>${(tank.volume && typeof tank.volume === 'number' && tank.volume > 0) ? tank.volume.toFixed(2) + ' m¬≥' : 'Not configured'}</span>
                    </div>
                    <div class="info-item">
                        <label>Density:</label>
                        <span>${(tank.density && tank.density !== '0.0') ? tank.density + ' kg/m¬≥' : 'No fish or volume not configured'}</span>
                    </div>
                    <div class="info-item">
                        <label>Diameter:</label>
                        <span>${(tank.diameter && typeof tank.diameter === 'number' && tank.diameter > 0) ? (tank.diameter / 50).toFixed(1) + ' meters' : 'Not configured'}</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="this.closest('.modal-overlay').remove()">Close</button>
                <button class="btn-primary" onclick="app.navigateToFishManagement(); this.closest('.modal-overlay').remove();">Manage Tank</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        });
        
        // Close on escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }
    
    // showBatchModal function moved to ModalManagerComponent
    
    showBedModal(bed) {
        // Hide any tooltips first
        this.hideLayoutTooltip();
        
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.id = 'component-modal-overlay';
        
        // Create modal content
        const modal = document.createElement('div');
        modal.className = 'modal-content';
        
        const utilizationPercent = bed.plantedPercentage || 0;
        const batchList = bed.batches && bed.batches.length > 0 
            ? bed.batches.map(b => this.cleanCustomCropName ? this.cleanCustomCropName(b.cropName) : b.cropName).join(', ')
            : 'No active batches';
        
        modal.innerHTML = `
            <div class="modal-header">
                <h2><img src="/icons/new-icons/Afraponix Go Icons_growbed.svg" alt="Grow Bed" class="heading-icon" style="width: 1.5em; height: 1.5em; vertical-align: middle; margin-right: 0.5em;"> ${bed.name} Details</h2>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="modal-info-grid">
                    <div class="info-item">
                        <label>Bed Name:</label>
                        <span>${bed.name}</span>
                    </div>
                    <div class="info-item">
                        <label>Dimensions:</label>
                        <span>${bed.dimensions}</span>
                    </div>
                    <div class="info-item">
                        <label>Bed Type:</label>
                        <span>${bed.bedType.toUpperCase()}</span>
                    </div>
                    <div class="info-item">
                        <label>Total Area:</label>
                        <span>${bed.equivalentArea.toFixed(2)} m¬≤</span>
                    </div>
                    <div class="info-item">
                        <label>Plant Count:</label>
                        <span>${bed.plantCount} plants</span>
                    </div>
                    <div class="info-item">
                        <label>Utilization:</label>
                        <span>${utilizationPercent.toFixed(1)}%</span>
                    </div>
                    <div class="info-item">
                        <label>Available Space:</label>
                        <span>${bed.availableArea.toFixed(2)} m¬≤</span>
                    </div>
                    <div class="info-item">
                        <label>Active Crops:</label>
                        <span>${batchList}</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="this.closest('.modal-overlay').remove()">Close</button>
                <button class="btn-primary" onclick="app.navigateToTab('grow-beds-tab'); this.closest('.modal-overlay').remove();">Manage Bed</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        });
        
        // Close on escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }
    
    handleComponentClick(component) {
        if (component.type === 'tank') {
            this.showTankModal(component);
        } else {
            this.showBedModal(component);
        }
    }
    
    zoomLayout(factor) {
        this.layoutScale *= factor;
        this.layoutScale = Math.max(0.5, Math.min(2, this.layoutScale)); // Limit zoom range
        this.updateLayoutTransform();
    }
    
    resetLayoutView() {
        this.layoutScale = 1;
        this.layoutPanX = 0;
        this.layoutPanY = 0;
        this.updateLayoutTransform();
    }
    
    toggleLayoutLabels() {
        this.labelsVisible = !this.labelsVisible;
        const labels = document.querySelectorAll('.component-label, .component-info');
        labels.forEach(label => {
            label.style.display = this.labelsVisible ? 'block' : 'none';
        });
        
        // Update button appearance
        const btn = document.getElementById('toggle-labels-btn');
        if (btn) {
            btn.style.opacity = this.labelsVisible ? '1' : '0.6';
        }
    }
    
    updateLayoutTransform() {
        const componentsGroup = document.getElementById('farm-components');
        if (componentsGroup) {
            componentsGroup.style.transform = `translate(${this.layoutPanX}px, ${this.layoutPanY}px) scale(${this.layoutScale})`;
        }
    }
    
    updateLayoutScale(bounds) {
        const scaleText = document.getElementById('scale-text');
        if (scaleText && bounds) {
            const pixelsPerMeter = 50;
            const actualScale = pixelsPerMeter * this.layoutScale;
            scaleText.textContent = `Scale: ${(actualScale/50).toFixed(1)}cm = 1m`;
        }
    }
    
    updateLayoutStats(layoutData) {
        const statsElement = document.getElementById('layout-stats');
        if (statsElement) {
            statsElement.innerHTML = `
                <span>Tanks: ${layoutData.fishTanks}</span>
                <span>Beds: ${layoutData.growBeds}</span>
                <span>Total Area: ${layoutData.totalArea.toFixed(1)}m¬≤</span>
            `;
        }
    }
    
    showFarmLayoutError(message) {
        const componentsGroup = document.getElementById('farm-components');
        if (componentsGroup) {
            componentsGroup.innerHTML = `
                <text x="400" y="300" text-anchor="middle" fill="#ef4444" font-size="16">
                    ‚ö†Ô∏è ${message}
                </text>
            `;
        }
    }
    
    // Legacy function - keeping for compatibility but replacing functionality  
    harvestBatchOld(batchId, cropType, growBedId, remainingPlants) {
        try {
            // Switch to Plant & Harvest tab first
            const mainTabSwitched = this.switchToPlantHarvestTab();
            if (!mainTabSwitched) {
                this.showNotification('‚ùå Could not switch to Plant & Harvest tab', 'error');
                return;
            }
            
            // Wait for main tab to load, then switch to harvest sub-tab
            setTimeout(() => {
                const harvestSubTabSwitched = this.switchToHarvestSubTab();
                if (!harvestSubTabSwitched) {
                    this.showNotification('‚ùå Could not switch to harvest sub-tab', 'error');
                    return;
                }
                
                // Wait a bit more for the harvest form to be visible, then populate
                setTimeout(() => {
                    this.populateHarvestForm(batchId, cropType, growBedId, remainingPlants);
                }, 300);
            }, 200);
            
        } catch (error) {
            console.error('Error in harvestBatch:', error);
            this.showNotification('‚ùå Error opening harvest form', 'error');
        }
    }
    
    populateHarvestForm(batchId, cropType, growBedId, remainingPlants) {
        try {
            // Get form elements
            const harvestBedSelect = document.getElementById('harvest-grow-bed');
            const harvestCropSelect = document.getElementById('harvest-crop-type');
            const harvestPlantCountInput = document.getElementById('harvest-plant-count');
            const harvestDateInput = document.getElementById('harvest-date');

            // Set up pending batch preselection first
            this.pendingBatchPreselection = batchId;
            
            if (harvestBedSelect) {
                harvestBedSelect.value = growBedId;
                harvestBedSelect.dispatchEvent(new Event('change'));
            }
            
            // Wait longer for bed change to complete and crop dropdown to rebuild
            setTimeout(() => {
                if (harvestCropSelect) {
                    const formattedCropType = cropType.toLowerCase().replace(/\s+/g, '_');
                    harvestCropSelect.value = formattedCropType;
                    harvestCropSelect.dispatchEvent(new Event('change'));
                }
                
                // Pre-fill form fields after batch summary updates
                setTimeout(() => {
                    if (harvestPlantCountInput) {
                        harvestPlantCountInput.value = remainingPlants;
                    }
                    
                    if (harvestDateInput) {
                        harvestDateInput.value = new Date().toISOString().slice(0, 16);
                    }
                    
                    // Show success notification
                    this.showNotification(`üåæ Harvest form populated for batch ${batchId}`, 'success');
                    
                }, 100);
            }, 800); // Increased timeout to allow bed change to complete
            
        } catch (error) {
            console.error('Error populating harvest form:', error);
            this.showNotification('‚ùå Error populating harvest form', 'error');
        }
    }

    // Generate unified bed overview that includes all bed info and batches
    async generateUnifiedBedOverview(plantData, idPrefix = '') {
        if (!this.activeSystemId) {
            return '<div class="unified-bed-overview"><div class="no-data">Please select a system to view grow bed information.</div></div>';
        }

        try {
            // Get allocations, grow beds, and fresh plant data
            const [allocations, growBeds] = await Promise.all([
                this.makeApiCall(`/plants/allocations/${this.activeSystemId}`),
                this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`)
            ]);

            if (!growBeds || growBeds.length === 0) {
                return '<div class="unified-bed-overview"><div class="no-data">No grow beds configured for this system.</div></div>';
            }

            // Create batch map for quick lookup
            const batchMap = new Map();
            plantData.forEach(entry => {
                if (entry.batch_id && entry.crop_type) {
                    const key = `${entry.grow_bed_id}-${entry.batch_id}`;
                    if (!batchMap.has(key)) {
                        batchMap.set(key, {
                            batchId: entry.batch_id,
                            cropType: entry.crop_type,
                            growBedId: entry.grow_bed_id,
                            dateFirst: entry.date,
                            plantCount: 0,
                            harvestedCount: 0,
                            seedVariety: entry.seed_variety || '',
                            daysToHarvest: entry.days_to_harvest || null,
                            entries: []
                        });
                    }
                    
                    const batch = batchMap.get(key);
                    batch.entries.push(entry);
                    
                    if (entry.plants_harvested > 0) {
                        batch.harvestedCount += entry.plants_harvested;
                    } else {
                        // Use correct field names from database schema
                        batch.plantCount += entry.new_seedlings || entry.count || 0;
                    }
                    
                    // Keep earliest date
                    if (new Date(entry.date) < new Date(batch.dateFirst)) {
                        batch.dateFirst = entry.date;
                    }
                }
            });

            let summaryHtml = `
                <div class="unified-bed-overview">
                    <div class="unified-bed-grid">
            `;

            // Generate card for each grow bed
            growBeds.forEach(bed => {
                // Get plant data for this bed
                const bedPlantData = plantData.filter(p => p.grow_bed_id == bed.id);
                
                // Get batches for this bed
                const bedBatches = Array.from(batchMap.values()).filter(batch => batch.growBedId == bed.id);
                
                // Calculate bed statistics based on actual plantings from batches
                const totalActualPlants = bedBatches.reduce((sum, batch) => {
                    const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                    return sum + remainingPlants;
                }, 0);
                const bedArea = parseFloat(bed.area_m2) || parseFloat(bed.equivalent_m2) || 0;
                const estimatedCapacity = bed.plant_capacity || Math.floor(bedArea * 25); // Rough estimate: 25 plants per m¬≤
                const spaceUtilization = estimatedCapacity > 0 ? Math.round((totalActualPlants / estimatedCapacity) * 100) : 0;
                
                const bedTypeName = bed.bed_type?.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                
                // Calculate space usage based on bed type
                let spaceUsageDisplay = '';
                const isVertical = bed.bed_type && (bed.bed_type.toLowerCase().includes('vertical') || 
                                                    bed.bed_type.toLowerCase().includes('tower') ||
                                                    bed.bed_type.toLowerCase().includes('nft'));
                
                if (isVertical) {
                    // For vertical systems, use database settings
                    let totalUnits = bed.vertical_count || 0;
                    let plantsPerUnit = bed.plants_per_vertical || 6; // Default to 6 if not set
                    
                    // If no vertical_count set, try to calculate from capacity
                    if (!totalUnits && estimatedCapacity > 0) {
                        totalUnits = Math.ceil(estimatedCapacity / plantsPerUnit);
                    }
                    
                    const unitsUsed = plantsPerUnit > 0 ? Math.ceil(totalActualPlants / plantsPerUnit) : 0;
                    spaceUsageDisplay = `${unitsUsed}/${totalUnits} verticals`;
                } else {
                    // For horizontal beds, calculate m¬≤ used
                    // Using average plant spacing to estimate area usage
                    const avgSpacingM2 = 0.04; // Average 20cm spacing = 0.04m¬≤ per plant
                    const m2Used = (totalActualPlants * avgSpacingM2).toFixed(1);
                    spaceUsageDisplay = `${m2Used}/${bedArea.toFixed(1)}m¬≤ used`;
                }
                
                summaryHtml += `
                    <div class="unified-bed-card" data-bed-id="${bed.id}">
                        <div class="bed-header-compact">
                            <div class="bed-title-compact">
                                <h4>${bed.bed_name || `Bed ${bed.bed_number}`}</h4>
                                <span class="bed-type-badge">${bedTypeName}</span>
                                <span class="bed-area">${bedArea.toFixed(1)}m¬≤</span>
                            </div>
                            <div class="bed-summary-stats">
                                <span class="plants-summary">${totalActualPlants} plants</span>
                                <span class="space-usage">${spaceUsageDisplay}</span>
                                <span class="space-available">${estimatedCapacity - totalActualPlants} space left</span>
                                <span class="progress-percentage ${spaceUtilization >= 80 ? 'good' : spaceUtilization >= 50 ? 'medium' : 'low'}">${spaceUtilization}% full</span>
                            </div>
                        </div>
                        
                        ${(() => {
                            // Filter out fully harvested batches (0 plants remaining)
                            const activeBatches = bedBatches.filter(batch => {
                                const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                                return remainingPlants > 0;
                            });
                            
                            return activeBatches.length > 0 ? `
                                <div class="bed-batches-compact">
                                    <h6>üì¶ Batches (${activeBatches.length})</h6>
                                    <div class="batches-list">
                                        ${activeBatches.map(batch => {
                                            const daysSincePlanted = Math.floor((new Date() - new Date(batch.dateFirst)) / (1000 * 60 * 60 * 24));
                                            const daysToHarvest = batch.daysToHarvest || 'Unknown';
                                            const isReady = batch.daysToHarvest && daysSincePlanted >= batch.daysToHarvest;
                                            const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                                            
                                            return `
                                                <div class="batch-line ${isReady ? 'ready-harvest' : ''}" data-batch-id="${batch.batchId}">
                                                    <div class="batch-header">
                                                        <span class="batch-crop-name">${this.cleanCustomCropName(batch.cropType)}</span>
                                                        <span class="batch-id">ID: ${batch.batchId}</span>
                                                        ${isReady ? '<span class="ready-badge-small">Ready!</span>' : ''}
                                                    </div>
                                                    <div class="batch-details">
                                                        <span class="batch-plants">${remainingPlants} plants remaining</span>
                                                        <span class="batch-age">${daysSincePlanted}d old</span>
                                                        <span class="batch-harvest-info">${daysToHarvest !== 'Unknown' ? `Harvest in ${Math.max(0, daysToHarvest - daysSincePlanted)}d` : 'Harvest time unknown'}</span>
                                                        <span class="batch-planted">Planted: ${new Date(batch.dateFirst).toLocaleDateString()}</span>
                                                    </div>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : '';
                        })()}
                        
                        <!-- Quick Action Buttons -->
                        <div class="tank-actions">
                            <div class="quick-actions-dropdown">
                                <button class="quick-actions-btn" onclick="app.toggleBedQuickActions(${bed.id})">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                        <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                                    </svg>
                                    Quick Actions
                                    <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor" style="margin-left: 4px;">
                                        <path d="M7 10l5 5 5-5z"/>
                                    </svg>
                                </button>
                                <div class="quick-actions-menu" id="bed-quick-actions-${bed.id}" style="display: none;">
                                    <button class="quick-action-item quick-plant-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                        </svg>
                                        Plant
                                    </button>
                                    <button class="quick-action-item quick-harvest-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M12 2L13.09 8.26L22 9L14 14.74L16.18 22L12 18.27L7.82 22L10 14.74L2 9L10.91 8.26L12 2z"/>
                                        </svg>
                                        Harvest
                                    </button>
                                    <button class="quick-action-item quick-move-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                                        </svg>
                                        Move Batch
                                    </button>
                                    <button class="quick-action-item quick-details-btn" data-bed-id="${bed.id}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M13 17.5c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm0-9c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm-6 0c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2z"/>
                                        </svg>
                                        Details
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Quick Plant Form (Hidden by default) -->
                        <div class="inline-quick-form plant-form" id="${idPrefix}quick-plant-${bed.id}" style="display: none;">
                            <h5>Quick Plant - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="quick-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}quick-crop-${bed.id}" onchange="window.app.onQuickCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        <optgroup label="Leafy Greens">
                                            <option value="lettuce">Lettuce (General)</option>
                                            <option value="lettuce_batavian">Lettuce - Batavian</option>
                                            <option value="lettuce_butter">Lettuce - Butter</option>
                                            <option value="lettuce_cos">Lettuce - Cos/Romaine</option>
                                            <option value="lettuce_icty">Lettuce - Little Gem</option>
                                            <option value="spinach">Spinach</option>
                                            <option value="kale">Kale</option>
                                            <option value="swiss_chard">Swiss Chard</option>
                                            <option value="arugula">Arugula</option>
                                            <option value="pac_choi">Pac Choi</option>
                                            <option value="watercress">Watercress</option>
                                        </optgroup>
                                        <optgroup label="Herbs">
                                            <option value="basil">Basil</option>
                                            <option value="cilantro">Cilantro</option>
                                            <option value="parsley">Parsley</option>
                                            <option value="mint">Mint</option>
                                            <option value="chives">Chives</option>
                                        </optgroup>
                                        <optgroup label="Fruiting Plants">
                                            <option value="tomatoes">Tomatoes</option>
                                            <option value="cucumber">Cucumber</option>
                                            <option value="pepper">Peppers</option>
                                            <option value="strawberry">Strawberry</option>
                                        </optgroup>
                                        <optgroup label="Other">
                                            <option value="celery">Celery</option>
                                            <option value="spring_onion">Spring Onion</option>
                                            <option value="leeks">Leeks</option>
                                            <option value="other">Other (Custom)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                
                                <div class="form-group variety-group">
                                    <label for="quick-variety-${bed.id}" class="form-label">Seed Variety</label>
                                    <div class="variety-input-group">
                                        <select class="quick-seed-variety" id="${idPrefix}quick-variety-${bed.id}" disabled onchange="window.app.onQuickVarietyChange('${bed.id}', '${idPrefix}')">
                                            <option value="">Select variety (optional)...</option>
                                            <option value="_new">+ Add New Variety</option>
                                        </select>
                                        <input type="text" class="quick-new-variety" id="${idPrefix}quick-new-variety-${bed.id}" placeholder="Enter new variety name" style="display: none;">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-count-${bed.id}" class="form-label">Plant Count</label>
                                        <input type="number" class="quick-plant-count" id="${idPrefix}quick-count-${bed.id}" placeholder="Number of plants" min="1">
                                    </div>
                                    ${!isVertical ? `
                                    <div class="form-group">
                                        <label for="quick-spacing-${bed.id}" class="form-label">Plant Spacing (cm)</label>
                                        <input type="number" class="quick-plant-spacing" id="${idPrefix}quick-spacing-${bed.id}" placeholder="e.g., 20" min="5" max="50" step="0.5">
                                    </div>
                                    ` : ''}
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-days-${bed.id}" class="form-label">Days to Harvest</label>
                                        <input type="number" class="quick-days-harvest" id="${idPrefix}quick-days-${bed.id}" placeholder="e.g., 45" min="1" max="365">
                                    </div>
                                    <div class="form-group">
                                        <label for="quick-date-${bed.id}" class="form-label">Planting Date</label>
                                        <input type="datetime-local" class="quick-plant-date" id="${idPrefix}quick-date-${bed.id}" value="${new Date().toISOString().slice(0, 16)}">
                                    </div>
                                </div>
                                
                                <input type="text" class="quick-custom-crop" id="${idPrefix}quick-custom-${bed.id}" placeholder="Enter custom crop name" style="display: none;">
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickPlantSubmit('${bed.id}')"><img src="/icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" class="btn-icon-svg" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.5em;"> Plant</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}plant-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Inline Quick Harvest Form (Hidden by default) -->
                        <div class="inline-quick-form harvest-form" id="${idPrefix}quick-harvest-${bed.id}" style="display: none;">
                            <h5>Quick Harvest - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="harvest-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}harvest-crop-${bed.id}" onchange="window.app.onHarvestCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        ${[...new Set(bedPlantData.filter(p => p.crop_type && !p.plants_harvested).map(p => p.crop_type))].map(crop => `
                                            <option value="${crop}">${this.cleanCustomCropName(crop)}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="harvest-batch-${bed.id}" class="form-label">Select Batch</label>
                                    <select class="quick-batch-select" id="${idPrefix}harvest-batch-${bed.id}" disabled onchange="window.app.onHarvestBatchChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop first...</option>
                                    </select>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="harvest-count-${bed.id}" class="form-label">Plants to Harvest</label>
                                        <input type="number" class="quick-harvest-count" id="${idPrefix}harvest-count-${bed.id}" placeholder="0" min="0" max="0">
                                        <small class="form-help" id="${idPrefix}harvest-help-${bed.id}">Select batch first</small>
                                    </div>
                                    <div class="form-group">
                                        <label for="harvest-weight-${bed.id}" class="form-label">Total Weight (kg)</label>
                                        <input type="number" class="quick-harvest-weight" id="${idPrefix}harvest-weight-${bed.id}" placeholder="0.0" min="0" step="0.1">
                                    </div>
                                </div>
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickHarvestSubmit('${bed.id}')">üåæ Harvest</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}harvest-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Bed Details Section (Hidden by default) -->
                        <div class="bed-details-section" id="${idPrefix}bed-details-${bed.id}" style="display: none;">
                            <div class="details-loading">Loading bed details...</div>
                        </div>
                    </div>
                `;
            });

            summaryHtml += `
                    </div>
                </div>
            `;

            return summaryHtml;

        } catch (error) {
            console.error('Error generating unified bed overview:', error);
            return '<div class="unified-bed-overview"><div class="error">Error loading grow bed information.</div></div>';
        }
    }

    async generateGrowBedSummary() {
        if (!this.activeSystemId) {
            return '<div class="grow-bed-summary"><div class="no-data">Please select a system to view grow bed summary.</div></div>';
        }

        try {
            // Get allocations, grow beds, and fresh plant data
            const [allocations, growBeds, plantData] = await Promise.all([
                this.makeApiCall(`/plants/allocations/${this.activeSystemId}`),
                this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`),
                this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`)
            ]);

            if (!growBeds || growBeds.length === 0) {
                return '<div class="grow-bed-summary"><div class="no-data">No grow beds configured for this system.</div></div>';
            }

            // Check for plant entries without grow_bed_id
            const entriesWithoutBedId = plantData.filter(p => !p.grow_bed_id);
            if (entriesWithoutBedId.length > 0) {
                console.warn('‚ö†Ô∏è Found plant entries without grow_bed_id:', entriesWithoutBedId.length);
            }

            let summaryHtml = `
                <div class="grow-bed-summary">
                    <h3>Grow Bed Planting Summary</h3>
                    <div class="bed-summary-grid">
            `;

            growBeds.forEach(bed => {
                const bedAllocations = allocations.filter(a => a.grow_bed_id == bed.id); // Use == for type coercion
                const bedPlantData = plantData.filter(p => p.grow_bed_id == bed.id); // Use == for type coercion

                // Calculate totals
                const totalAllocatedPlants = bedAllocations.reduce((sum, alloc) => sum + (alloc.plants_planted || 0), 0);
                const totalActualPlants = this.calculateCurrentPlantCount(bedPlantData);
                const plantedPercentage = totalAllocatedPlants > 0 ? Math.round((totalActualPlants / totalAllocatedPlants) * 100) : 0;

                // Get bed utilization
                const totalAllocatedPercentage = (bedAllocations && Array.isArray(bedAllocations)) 
                    ? bedAllocations.reduce((sum, alloc) => {
                        const percentage = parseFloat(alloc.percentage_allocated) || 0;
                        return sum + percentage;
                    }, 0)
                    : 0;
                
                const bedTypeName = bed.bed_type?.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                
                summaryHtml += `
                    <div class="bed-summary-card" data-bed-id="${bed.id}">
                        <div class="bed-summary-header">
                            <h4>${bed.bed_name || `Bed ${bed.bed_number}`}</h4>
                            <span class="bed-type-badge">${bedTypeName}</span>
                        </div>
                        
                        <div class="bed-summary-stats">
                            <div class="bed-stat">
                                <span class="stat-label">Area:</span>
                                <span class="stat-value">${(parseFloat(bed.area_m2) || parseFloat(bed.equivalent_m2) || 0).toFixed(1)}m¬≤</span>
                            </div>
                            <div class="bed-stat">
                                <span class="stat-label">Allocated:</span>
                                <span class="stat-value">${(Number(totalAllocatedPercentage) || 0).toFixed(1)}%</span>
                            </div>
                        </div>
                        
                        <div class="planting-progress">
                            <div class="progress-header">
                                <span class="progress-label">Plants: ${totalActualPlants} / ${totalAllocatedPlants}</span>
                                <span class="progress-percentage ${plantedPercentage >= 80 ? 'good' : plantedPercentage >= 50 ? 'medium' : 'low'}">${plantedPercentage}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${Math.min(plantedPercentage, 100)}%"></div>
                            </div>
                        </div>
                        
                        <!-- REMOVED: Crop allocation display - no longer needed -->
                        
                        <!-- Quick Action Buttons -->
                        <div class="tank-actions">
                            <div class="quick-actions-dropdown">
                                <button class="quick-actions-btn" onclick="app.toggleBedQuickActions(${bed.id})">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                        <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                                    </svg>
                                    Quick Actions
                                    <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor" style="margin-left: 4px;">
                                        <path d="M7 10l5 5 5-5z"/>
                                    </svg>
                                </button>
                                <div class="quick-actions-menu" id="bed-quick-actions-${bed.id}" style="display: none;">
                                    <button class="quick-action-item quick-plant-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                        </svg>
                                        Plant
                                    </button>
                                    <button class="quick-action-item quick-harvest-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M12 2L13.09 8.26L22 9L14 14.74L16.18 22L12 18.27L7.82 22L10 14.74L2 9L10.91 8.26L12 2z"/>
                                        </svg>
                                        Harvest
                                    </button>
                                    <button class="quick-action-item quick-move-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                                        </svg>
                                        Move Batch
                                    </button>
                                    <button class="quick-action-item quick-details-btn" data-bed-id="${bed.id}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M13 17.5c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm0-9c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm-6 0c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2z"/>
                                        </svg>
                                        Details
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Quick Plant Form (Hidden by default) -->
                        <div class="inline-quick-form plant-form" id="${idPrefix}quick-plant-${bed.id}" style="display: none;">
                            <h5>Quick Plant - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="quick-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}quick-crop-${bed.id}" onchange="window.app.onQuickCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        <optgroup label="Leafy Greens">
                                            <option value="lettuce">Lettuce (General)</option>
                                            <option value="lettuce_batavian">Lettuce - Batavian</option>
                                            <option value="lettuce_butter">Lettuce - Butter</option>
                                            <option value="lettuce_cos">Lettuce - Cos/Romaine</option>
                                            <option value="lettuce_icty">Lettuce - Little Gem</option>
                                            <option value="spinach">Spinach</option>
                                            <option value="kale">Kale</option>
                                            <option value="swiss_chard">Swiss Chard</option>
                                            <option value="arugula">Arugula</option>
                                            <option value="pac_choi">Pac Choi</option>
                                            <option value="watercress">Watercress</option>
                                        </optgroup>
                                        <optgroup label="Herbs">
                                            <option value="basil">Basil</option>
                                            <option value="cilantro">Cilantro</option>
                                            <option value="parsley">Parsley</option>
                                            <option value="mint">Mint</option>
                                            <option value="chives">Chives</option>
                                        </optgroup>
                                        <optgroup label="Fruiting Plants">
                                            <option value="tomatoes">Tomatoes</option>
                                            <option value="cucumber">Cucumber</option>
                                            <option value="pepper">Peppers</option>
                                            <option value="strawberry">Strawberry</option>
                                        </optgroup>
                                        <optgroup label="Other">
                                            <option value="celery">Celery</option>
                                            <option value="spring_onion">Spring Onion</option>
                                            <option value="leeks">Leeks</option>
                                            <option value="other">Other (Custom)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                
                                <div class="form-group variety-group">
                                    <label for="quick-variety-${bed.id}" class="form-label">Seed Variety</label>
                                    <div class="variety-input-group">
                                        <select class="quick-seed-variety" id="${idPrefix}quick-variety-${bed.id}" disabled onchange="window.app.onQuickVarietyChange('${bed.id}', '${idPrefix}')">
                                            <option value="">Select variety (optional)...</option>
                                            <option value="_new">+ Add New Variety</option>
                                        </select>
                                        <input type="text" class="quick-new-variety" id="${idPrefix}quick-new-variety-${bed.id}" placeholder="Enter new variety name" style="display: none;">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-count-${bed.id}" class="form-label">Plant Count</label>
                                        <input type="number" class="quick-plant-count" id="${idPrefix}quick-count-${bed.id}" placeholder="Number of plants" min="1">
                                    </div>
                                    ${!isVertical ? `
                                    <div class="form-group">
                                        <label for="quick-spacing-${bed.id}" class="form-label">Plant Spacing (cm)</label>
                                        <input type="number" class="quick-plant-spacing" id="${idPrefix}quick-spacing-${bed.id}" placeholder="e.g., 20" min="5" max="50" step="0.5">
                                    </div>
                                    ` : ''}
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-days-${bed.id}" class="form-label">Days to Harvest</label>
                                        <input type="number" class="quick-days-harvest" id="${idPrefix}quick-days-${bed.id}" placeholder="e.g., 45" min="1" max="365">
                                    </div>
                                    <div class="form-group">
                                        <label for="quick-date-${bed.id}" class="form-label">Planting Date</label>
                                        <input type="datetime-local" class="quick-plant-date" id="${idPrefix}quick-date-${bed.id}" value="${new Date().toISOString().slice(0, 16)}">
                                    </div>
                                </div>
                                
                                <input type="text" class="quick-custom-crop" id="${idPrefix}quick-custom-${bed.id}" placeholder="Enter custom crop name" style="display: none;">
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickPlantSubmit('${bed.id}')"><img src="/icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" class="btn-icon-svg" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.5em;"> Plant</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}plant-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Inline Quick Harvest Form (Hidden by default) -->
                        <div class="inline-quick-form harvest-form" id="${idPrefix}quick-harvest-${bed.id}" style="display: none;">
                            <h5>Quick Harvest - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="harvest-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}harvest-crop-${bed.id}" onchange="window.app.onHarvestCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        ${[...new Set(bedPlantData.filter(p => p.crop_type && !p.plants_harvested).map(p => p.crop_type))].map(crop => `
                                            <option value="${crop}">${this.cleanCustomCropName(crop)}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="harvest-batch-${bed.id}" class="form-label">Select Batch</label>
                                    <select class="quick-batch-select" id="${idPrefix}harvest-batch-${bed.id}" disabled onchange="window.app.onHarvestBatchChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop first...</option>
                                    </select>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="harvest-count-${bed.id}" class="form-label">Plants to Harvest</label>
                                        <input type="number" class="quick-harvest-count" id="${idPrefix}harvest-count-${bed.id}" placeholder="0" min="0" max="0">
                                        <small class="form-help" id="${idPrefix}harvest-help-${bed.id}">Select batch first</small>
                                    </div>
                                    <div class="form-group">
                                        <label for="harvest-weight-${bed.id}" class="form-label">Total Weight (kg)</label>
                                        <input type="number" class="quick-harvest-weight" id="${idPrefix}harvest-weight-${bed.id}" placeholder="0.0" min="0" step="0.1">
                                    </div>
                                </div>
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickHarvestSubmit('${bed.id}')">üåæ Harvest</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}harvest-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Bed Details Section (Hidden by default) -->
                        <div class="bed-details-section" id="${idPrefix}bed-details-${bed.id}" style="display: none;">
                            <div class="details-loading">Loading bed details...</div>
                        </div>
                    </div>
                `;
            });

            summaryHtml += `
                    </div>
                </div>
            `;

            return summaryHtml;

        } catch (error) {
            console.error('Error generating grow bed summary:', error);
            return '<div class="grow-bed-summary"><div class="error">Error loading grow bed summary.</div></div>';
        }
    }

    // Helper function to generate bed options for move dropdown
    async generateBedOptions(currentBedId) {
        
        // Use the reliable getGrowBedsForSystem method instead of direct API call
        try {
            this.growBeds = await this.getGrowBedsForSystem();
        } catch (error) {
            if (window.errorManager) {
                window.errorManager.warnOnce('grow_beds_fetch_dropdown_failed', 'Error fetching grow beds for dropdown', this.activeSystemId);
            } else {
                console.error('Error fetching grow beds for dropdown:', error);
                console.error('Error details:', error.message);
            }
            return '<option value="" disabled>Error loading beds</option>';
        }
        
        if (!this.growBeds || !Array.isArray(this.growBeds)) {
            return '<option value="" disabled>No beds available</option>';
        }
        
        const filteredBeds = this.growBeds.filter(bed => bed.id != currentBedId);
        
        const options = filteredBeds
            .map(bed => {
                // Create a descriptive display name with bed name and type
                const bedName = bed.bed_name || bed.name || `Bed ${bed.bed_number || bed.id}`;
                const bedType = bed.bed_type ? bed.bed_type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) : '';
                const displayName = bedType ? `${bedName} (${bedType})` : bedName;
                return `<option value="${bed.id}">${displayName}</option>`;
            })
            .join('');
            
        return options || '<option value="" disabled>No other beds available</option>';
    }
    
    // Toggle batch quick action forms
    toggleBatchQuickForm(action, batchId) {
        const harvestForm = document.getElementById(`batch-harvest-form-${batchId}`);
        const moveForm = document.getElementById(`batch-move-form-${batchId}`);
        
        if (action === 'harvest') {
            if (harvestForm) {
                harvestForm.style.display = harvestForm.style.display === 'none' ? 'block' : 'none';
                if (moveForm) moveForm.style.display = 'none';
            }
        } else if (action === 'move') {
            if (moveForm) {
                moveForm.style.display = moveForm.style.display === 'none' ? 'block' : 'none';
                if (harvestForm) harvestForm.style.display = 'none';
            }
        }
    }
    
    // Submit batch harvest
    async submitBatchHarvest(modalId, bedId, batchId, cropName) {
        try {
            const weight = document.getElementById(`batch-harvest-weight-${modalId}`)?.value;
            const count = document.getElementById(`batch-harvest-count-${modalId}`)?.value;
            const notes = document.getElementById(`batch-harvest-notes-${modalId}`)?.value;
            
            if (!weight || !count) {
                this.showNotification('Please fill in harvest weight and plant count', 'error');
                return;
            }
            
            // Submit harvest
            await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify({
                    system_id: this.activeSystemId,
                    grow_bed_id: bedId,
                    crop_type: cropName,
                    harvest_weight: parseFloat(weight) * 1000, // Convert kg to grams
                    plants_harvested: parseInt(count),
                    batch_id: batchId,
                    notes: notes || '',
                    date: new Date().toISOString().split('T')[0]
                })
            });
            
            this.showNotification(`‚úÖ Harvested ${count} plants (${weight}kg) from ${this.cleanCustomCropName(cropName)}`, 'success');
            
            // Close modal and refresh data
            document.getElementById('component-modal-overlay')?.remove();
            await this.updateDashboardFromData();
            
        } catch (error) {
            console.error('Batch harvest error:', error);
            this.showNotification('Failed to record harvest', 'error');
        }
    }
    
    // Submit batch move
    async submitBatchMove(modalId, fromBedId, batchId, cropName) {
        try {
            const toBedId = document.getElementById(`batch-move-bed-${modalId}`)?.value;
            const moveCount = document.getElementById(`batch-move-count-${modalId}`)?.value;
            
            if (!toBedId || !moveCount) {
                this.showNotification('Please select destination bed and plant count', 'error');
                return;
            }
            
            // Use the proper batch move endpoint to update all batch records
            await this.makeApiCall(`/data/batch/${this.activeSystemId}/${batchId}/grow-bed`, {
                method: 'PUT',
                body: JSON.stringify({
                    newGrowBedId: parseInt(toBedId)
                })
            });
            
            this.showNotification(`‚úÖ Moved ${moveCount} plants to new grow bed`, 'success');
            
            // Close modal and refresh data comprehensively
            document.getElementById('component-modal-overlay')?.remove();
            
            // Refresh all plant-related data and visualizations
            await this.loadDataRecords(); // Reload fresh data from database
            await this.updateDashboardFromData(); // Update dashboard
            await this.updatePlantOverview(); // Update plant overview which drives SVG batch data
            this.updateGrowBeds(); // Update grow bed displays
            
        } catch (error) {
            console.error('Batch move error:', error);
            this.showNotification('Failed to move batch', 'error');
        }
    }

    // Toggle inline quick forms
    toggleQuickForm(formType) {
        // Handle prefixed form types (beds-plant-14 should become beds-quick-plant-14)
        let formId;
        if (formType.startsWith('beds-')) {
            formId = formType.replace('beds-', 'beds-quick-');
        } else {
            formId = `quick-${formType}`;
        }
        const form = document.getElementById(formId);
        
        // Check for duplicate IDs
        const allFormsWithId = document.querySelectorAll(`#${formId}`);
        
        if (form) {
            const isVisible = form.style.display !== 'none';
            
            // Hide all other forms in the same card (try both class names for compatibility)
            const card = form.closest('.bed-summary-card') || form.closest('.bed-item-unified');
            
            if (card) {
                card.querySelectorAll('.inline-quick-form').forEach(f => {
                    f.style.setProperty('display', 'none', 'important');
                });
            }
            
            // Toggle this form with important CSS overrides
            if (isVisible) {
                form.style.setProperty('display', 'none', 'important');
                form.classList.remove('form-visible');
            } else {
                form.style.setProperty('display', 'block', 'important');
                form.style.setProperty('visibility', 'visible', 'important');
                form.style.setProperty('opacity', '1', 'important');
                form.style.setProperty('height', 'auto', 'important');
                form.style.setProperty('overflow', 'visible', 'important');
                form.style.setProperty('position', 'relative', 'important');
                form.style.setProperty('z-index', '999', 'important');
                form.classList.add('form-visible');
                
                // Force a scroll to make sure it's visible
                setTimeout(() => {
                    form.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
            
            // Debug positioning and dimensions
            const rect = form.getBoundingClientRect();
            const computedStyles = window.getComputedStyle(form);
            
            // Check if form is actually in the viewport
            const inViewport = rect.top >= 0 && rect.left >= 0 && 
                              rect.bottom <= window.innerHeight && 
                              rect.right <= window.innerWidth;
            
            // Debug form content
            
            // Force minimum dimensions if form has no natural size
            if (rect.width === 0 || rect.height === 0) {
                form.style.setProperty('min-width', '400px', 'important');
                form.style.setProperty('min-height', '200px', 'important');
                form.style.setProperty('width', '400px', 'important');
                form.style.setProperty('height', 'auto', 'important');
                form.style.setProperty('background-color', 'red', 'important');
                form.style.setProperty('border', '5px solid blue', 'important');
                form.style.setProperty('padding', '20px', 'important');
                form.style.setProperty('margin', '20px', 'important');
                
                // Add a large text overlay to make it impossible to miss
                form.innerHTML = '<div style="font-size: 48px; color: white; text-align: center; padding: 50px;">üö® FORM IS HERE! üö®<br>Click to close</div>' + form.innerHTML;
            }
            
            // If opening, focus the first input
            if (!isVisible) {
                const firstInput = form.querySelector('select, input');
                if (firstInput) firstInput.focus();
            }
        } else {
            console.error(`Form not found: ${formId}`);
        }
    }
    
    // Handle crop selection change in quick plant form
    async onQuickCropChange(bedId, prefix = '') {
        const cropSelect = document.getElementById(`${prefix}quick-crop-${bedId}`);
        const varietySelect = document.getElementById(`${prefix}quick-variety-${bedId}`);
        const newVarietyInput = document.getElementById(`${prefix}quick-new-variety-${bedId}`);
        const spacingInput = document.getElementById(`${prefix}quick-spacing-${bedId}`);
        const daysInput = document.getElementById(`${prefix}quick-days-${bedId}`);
        const customInput = document.getElementById(`${prefix}quick-custom-${bedId}`);
        
        const selectedCrop = cropSelect.value;
        
        // Hide new variety input when crop changes
        if (newVarietyInput) {
            newVarietyInput.style.display = 'none';
            newVarietyInput.value = '';
        }
        
        // Show/hide custom crop input
        if (selectedCrop === 'other') {
            customInput.style.display = 'block';
            customInput.required = true;
        } else {
            customInput.style.display = 'none';
            customInput.required = false;
            customInput.value = '';
        }
        
        // Reset and populate variety dropdown
        varietySelect.innerHTML = '<option value="">Loading varieties...</option>';
        varietySelect.disabled = true;
        
        if (selectedCrop && selectedCrop !== 'other') {
            try {
                // Fetch seed varieties for selected crop
                const response = await this.makeApiCall(`/seed-varieties/crop/${selectedCrop}`);
                const varieties = response.varieties || [];
                
                varietySelect.innerHTML = `
                    <option value="">Select variety (optional)...</option>
                    <option value="_new">+ Add New Variety</option>
                `;
                varieties.forEach(variety => {
                    varietySelect.innerHTML += `<option value="${variety.variety_name}">${variety.variety_name}</option>`;
                });
                varietySelect.disabled = false;
                
                // Set default spacing and days based on crop type
                this.setDefaultPlantingValues(selectedCrop, spacingInput, daysInput);
                
            } catch (error) {
                console.error('Error fetching seed varieties:', error);
                varietySelect.innerHTML = `
                    <option value="">Select variety (optional)...</option>
                    <option value="_new">+ Add New Variety</option>
                `;
                varietySelect.disabled = false;
                this.setDefaultPlantingValues(selectedCrop, spacingInput, daysInput);
            }
        } else {
            varietySelect.innerHTML = '<option value="">Select crop first...</option>';
        }
    }
    
    // Handle variety selection change
    onQuickVarietyChange(bedId, prefix = '') {
        const varietySelect = document.getElementById(`${prefix}quick-variety-${bedId}`);
        const newVarietyInput = document.getElementById(`${prefix}quick-new-variety-${bedId}`);
        
        if (!varietySelect || !newVarietyInput) return;
        
        if (varietySelect.value === '_new') {
            // Show input for new variety
            newVarietyInput.style.display = 'block';
            newVarietyInput.focus();
        } else {
            // Hide new variety input
            newVarietyInput.style.display = 'none';
            newVarietyInput.value = '';
        }
    }
    
    // Set default planting values based on crop type
    setDefaultPlantingValues(cropType, spacingInput, daysInput) {
        const defaults = {
            // Leafy Greens
            lettuce: { spacing: 15, days: 45 },
            lettuce_batavian: { spacing: 20, days: 60 },
            lettuce_butter: { spacing: 18, days: 55 },
            lettuce_cos: { spacing: 25, days: 70 },
            lettuce_icty: { spacing: 12, days: 35 },
            spinach: { spacing: 10, days: 40 },
            kale: { spacing: 30, days: 65 },
            swiss_chard: { spacing: 20, days: 55 },
            arugula: { spacing: 8, days: 25 },
            pac_choi: { spacing: 15, days: 45 },
            watercress: { spacing: 5, days: 30 },
            
            // Herbs
            basil: { spacing: 15, days: 60 },
            cilantro: { spacing: 8, days: 30 },
            parsley: { spacing: 10, days: 75 },
            mint: { spacing: 20, days: 60 },
            chives: { spacing: 5, days: 90 },
            
            // Fruiting Plants
            tomatoes: { spacing: 60, days: 120 },
            cucumber: { spacing: 50, days: 70 },
            pepper: { spacing: 40, days: 90 },
            strawberry: { spacing: 25, days: 90 },
            
            // Other
            celery: { spacing: 15, days: 100 },
            spring_onion: { spacing: 5, days: 60 },
            leeks: { spacing: 10, days: 120 }
        };
        
        const defaultValues = defaults[cropType] || { spacing: 15, days: 60 };
        if (spacingInput) {
            spacingInput.value = defaultValues.spacing;
        }
        if (daysInput) {
            daysInput.value = defaultValues.days;
        }
    }

    // Quick plant submission
    async quickPlantSubmit(bedId) {
        // Detect prefix by checking which form exists
        const prefix = document.getElementById(`beds-quick-crop-${bedId}`) ? 'beds-' : '';
        
        const cropSelect = document.getElementById(`${prefix}quick-crop-${bedId}`);
        const varietySelect = document.getElementById(`${prefix}quick-variety-${bedId}`);
        const newVarietyInput = document.getElementById(`${prefix}quick-new-variety-${bedId}`);
        const countInput = document.getElementById(`${prefix}quick-count-${bedId}`);
        const spacingInput = document.getElementById(`${prefix}quick-spacing-${bedId}`);
        const daysInput = document.getElementById(`${prefix}quick-days-${bedId}`);
        const dateInput = document.getElementById(`${prefix}quick-date-${bedId}`);
        const customInput = document.getElementById(`${prefix}quick-custom-${bedId}`);
        
        // Determine the crop type
        let cropType = cropSelect.value;
        if (cropType === 'other') {
            cropType = customInput.value.trim();
            if (!cropType) {
                this.showNotification('Please enter custom crop name', 'error');
                return;
            }
        }
        
        if (!cropType || !countInput.value) {
            this.showNotification('Please fill in crop and plant count', 'error');
            return;
        }
        
        // Determine the seed variety
        let seedVariety = '';
        if (varietySelect.value === '_new' && newVarietyInput.value.trim()) {
            // User entered a new variety
            seedVariety = newVarietyInput.value.trim();
            
            // Save the new variety to database for future use
            try {
                await this.makeApiCall('/seed-varieties', {
                    method: 'POST',
                    body: JSON.stringify({
                        crop_type: cropType,
                        variety_name: seedVariety
                    })
                });
            } catch (error) {
            }
        } else if (varietySelect.value && varietySelect.value !== '_new') {
            seedVariety = varietySelect.value;
        }
        
        try {
            // Use selected date or current date/time
            const dateStr = dateInput.value || new Date().toISOString().slice(0, 16);
            
            // Generate batch ID
            const batchId = `BATCH-${Date.now()}`;
            
            const plantData = {
                date: dateStr,
                grow_bed_id: bedId,
                crop_type: cropType,
                new_seedlings: parseInt(countInput.value),
                growth_stage: 'seedling',
                batch_id: batchId,
                seed_variety: seedVariety,
                days_to_harvest: parseInt(daysInput.value) || null
            };
            
            await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(plantData)
            });
            
            const varietyText = seedVariety ? ` (${seedVariety})` : '';
            this.showNotification(`Planted ${countInput.value} ${this.cleanCustomCropName(cropType)}${varietyText}`, 'success');
            
            // Clear form and hide
            cropSelect.value = '';
            varietySelect.innerHTML = '<option value="">Select variety first...</option>';
            varietySelect.disabled = true;
            newVarietyInput.value = '';
            newVarietyInput.style.display = 'none';
            countInput.value = '';
            if (spacingInput) {
                spacingInput.value = '';
            }
            daysInput.value = '';
            dateInput.value = new Date().toISOString().slice(0, 16);
            customInput.value = '';
            customInput.style.display = 'none';
            this.toggleQuickForm(prefix ? `beds-plant-${bedId}` : `plant-${bedId}`);
            
            // Refresh the overview and all related displays
            await this.updatePlantOverview();
            
            // Force refresh the data to ensure new batch is shown
            this.plantData = null; // Clear cache
            this.growBeds = null; // Clear cache
            
            // If we're on the grow beds tab, refresh it too
            if (this.activePlantTab === 'grow-beds') {
                await this.loadGrowBedsTab();
            }
            
        } catch (error) {
            console.error('Quick plant error:', error);
            this.showNotification('Failed to record planting', 'error');
        }
    }

    // Handle harvest crop selection change
    async onHarvestCropChange(bedId, prefix = '') {
        const cropSelect = document.getElementById(`${prefix}harvest-crop-${bedId}`);
        const batchSelect = document.getElementById(`${prefix}harvest-batch-${bedId}`);
        const countInput = document.getElementById(`${prefix}harvest-count-${bedId}`);
        const helpText = document.getElementById(`${prefix}harvest-help-${bedId}`);
        
        if (!cropSelect || !batchSelect || !countInput || !helpText) return;
        
        const selectedCrop = cropSelect.value;
        
        if (!selectedCrop) {
            batchSelect.innerHTML = '<option value="">Select crop first...</option>';
            batchSelect.disabled = true;
            countInput.max = 0;
            helpText.textContent = 'Select crop first';
            return;
        }
        
        try {
            // Get plant data for this bed and filter by crop type
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            const bedPlantData = plantData.filter(p => p.grow_bed_id == bedId && p.crop_type === selectedCrop && !p.plants_harvested);
            
            // Group by batch_id to get available batches
            const batches = {};
            bedPlantData.forEach(entry => {
                if (entry.batch_id) {
                    if (!batches[entry.batch_id]) {
                        batches[entry.batch_id] = {
                            batchId: entry.batch_id,
                            cropType: entry.crop_type,
                            plantCount: 0,
                            harvestedCount: 0,
                            dateFirst: entry.date,
                            daysToHarvest: entry.days_to_harvest
                        };
                    }
                    
                    if (entry.plants_harvested > 0) {
                        batches[entry.batch_id].harvestedCount += entry.plants_harvested;
                    } else {
                        batches[entry.batch_id].plantCount += entry.new_seedlings || entry.count || 0;
                    }
                    
                    // Keep earliest date
                    if (new Date(entry.date) < new Date(batches[entry.batch_id].dateFirst)) {
                        batches[entry.batch_id].dateFirst = entry.date;
                    }
                }
            });
            
            // Filter batches with remaining plants
            const availableBatches = Object.values(batches).filter(batch => {
                const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                return remainingPlants > 0;
            });
            
            if (availableBatches.length === 0) {
                batchSelect.innerHTML = '<option value="">No available batches</option>';
                batchSelect.disabled = true;
                countInput.max = 0;
                helpText.textContent = 'No batches available for harvest';
                return;
            }
            
            // Populate batch dropdown
            batchSelect.innerHTML = '<option value="">Select batch...</option>' + 
                availableBatches.map(batch => {
                    const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                    const daysSincePlanted = Math.floor((new Date() - new Date(batch.dateFirst)) / (1000 * 60 * 60 * 24));
                    const isReady = batch.daysToHarvest && daysSincePlanted >= batch.daysToHarvest;
                    const readyText = isReady ? ' ‚≠ê Ready' : '';
                    
                    return `<option value="${batch.batchId}" data-max-plants="${remainingPlants}">
                        ${batch.batchId} - ${remainingPlants} plants (${daysSincePlanted}d old)${readyText}
                    </option>`;
                }).join('');
                
            batchSelect.disabled = false;
            helpText.textContent = 'Select a batch to harvest from';
            
        } catch (error) {
            console.error('Error loading harvest batches:', error);
            batchSelect.innerHTML = '<option value="">Error loading batches</option>';
            batchSelect.disabled = true;
        }
    }
    
    // Handle harvest batch selection change
    onHarvestBatchChange(bedId, prefix = '') {
        const batchSelect = document.getElementById(`${prefix}harvest-batch-${bedId}`);
        const countInput = document.getElementById(`${prefix}harvest-count-${bedId}`);
        const helpText = document.getElementById(`${prefix}harvest-help-${bedId}`);
        
        if (!batchSelect || !countInput || !helpText) return;
        
        const selectedOption = batchSelect.options[batchSelect.selectedIndex];
        
        if (!selectedOption || !selectedOption.value) {
            countInput.max = 0;
            countInput.value = '';
            helpText.textContent = 'Select a batch first';
            return;
        }
        
        const maxPlants = selectedOption.getAttribute('data-max-plants') || 0;
        countInput.max = maxPlants;
        countInput.placeholder = `Max: ${maxPlants}`;
        helpText.textContent = `Up to ${maxPlants} plants can be harvested from this batch`;
    }
    
    // Quick harvest submission
    async quickHarvestSubmit(bedId) {
        // Detect prefix by checking which form exists
        const prefix = document.getElementById(`beds-harvest-crop-${bedId}`) ? 'beds-' : '';
        
        const cropSelect = document.getElementById(`${prefix}harvest-crop-${bedId}`);
        const batchSelect = document.getElementById(`${prefix}harvest-batch-${bedId}`);
        const countInput = document.getElementById(`${prefix}harvest-count-${bedId}`);
        const weightInput = document.getElementById(`${prefix}harvest-weight-${bedId}`);
        
        if (!cropSelect.value || !batchSelect.value || !countInput.value || !weightInput.value) {
            this.showNotification('Please fill in all fields including batch selection', 'error');
            return;
        }
        
        // Validate harvest amount doesn't exceed available plants
        const maxPlants = parseInt(countInput.max) || 0;
        const harvestAmount = parseInt(countInput.value);
        if (harvestAmount > maxPlants) {
            this.showNotification(`Cannot harvest ${harvestAmount} plants. Only ${maxPlants} available in this batch.`, 'error');
            return;
        }
        
        try {
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 16);
            
            const harvestData = {
                date: dateStr,
                grow_bed_id: bedId,
                crop_type: cropSelect.value,
                batch_id: batchSelect.value,
                plants_harvested: parseInt(countInput.value),
                harvest_weight: parseFloat(weightInput.value) * 1000, // Convert kg to grams
                health: 'good'
            };
            
            await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(harvestData)
            });
            
            this.showNotification(`Harvested ${countInput.value} ${this.cleanCustomCropName(cropSelect.value)} (${weightInput.value}kg)`, 'success');
            
            // Clear form and hide
            cropSelect.value = '';
            batchSelect.innerHTML = '<option value="">Select crop first...</option>';
            batchSelect.disabled = true;
            countInput.value = '';
            countInput.max = 0;
            countInput.placeholder = '0';
            weightInput.value = '';
            const helpText = document.getElementById(`${prefix}harvest-help-${bedId}`);
            if (helpText) {
                helpText.textContent = 'Select crop first';
            }
            this.toggleQuickForm(prefix ? `beds-harvest-${bedId}` : `harvest-${bedId}`);
            
            // Refresh the overview and all related displays
            await this.updatePlantOverview();
            
            // Force refresh the data to ensure batch counts are updated
            this.plantData = null; // Clear cache
            this.growBeds = null; // Clear cache
            
            // If we're on the grow beds tab, refresh it too
            if (this.activePlantTab === 'grow-beds') {
                await this.loadGrowBedsTab();
            }
            
        } catch (error) {
            console.error('Quick harvest error:', error);
            this.showNotification('Failed to record harvest', 'error');
        }
    }
    
    // Load Grow Beds tab content
    async loadGrowBedsTab() {
        // Initialize subtabs when loading grow beds tab
        this.initializeGrowBedsSubtabs();
        
        // Load the default subtab (Beds Overview)
        await this.loadBedsOverview();
    }
    
    // Initialize grow beds subtabs
    initializeGrowBedsSubtabs() {
        const bedsOverviewTab = document.getElementById('beds-overview-subtab');
        const plantsManagementTab = document.getElementById('plants-management-subtab');
        
        if (bedsOverviewTab) {
            bedsOverviewTab.addEventListener('click', async () => {
                this.switchGrowBedsSubtab('beds-overview');
                await this.loadBedsOverview();
            });
        }
        
        if (plantsManagementTab) {
            plantsManagementTab.addEventListener('click', async () => {
                this.switchGrowBedsSubtab('plants-management');
                await this.loadPlantsManagement();
            });
        }
    }
    
    // Switch between grow beds subtabs
    switchGrowBedsSubtab(tabId) {
        // Update active states for subtabs
        document.querySelectorAll('.grow-beds-subtab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.getElementById(`${tabId}-subtab`)?.classList.add('active');
        
        // Update active states for content
        document.querySelectorAll('.grow-beds-subcontent').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(`${tabId}-content`)?.classList.add('active');
    }
    
    // Load beds overview subtab
    async loadBedsOverview() {
        const container = document.getElementById('grow-beds-container');
        if (!container) return;
        
        try {
            // Fetch fresh plant data like Plant Overview tab does
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            // Generate the same unified bed overview with unique IDs for beds tab
            const unifiedBedOverviewHtml = await this.generateUnifiedBedOverview(plantData, 'beds-');
            
            // Display with same wrapper and styling as Plant Overview
            container.innerHTML = `
                <div class="grow-bed-management-section">
                    ${unifiedBedOverviewHtml}
                </div>
            `;
            
            // Initialize quick actions for the bed management
            this.initializeQuickActions();
            
            // Initialize grow bed specific features that might be needed
            this.initializeGrowBedFeatures();
            
        } catch (error) {
            console.error('Error loading beds overview:', error);
            container.innerHTML = '<div class="error-message">Failed to load grow beds. Please try again.</div>';
        }
    }
    
    // Initialize plant management tabs
    initializePlantTabs() {
        // Remove existing event listeners
        document.querySelectorAll('.plant-mgmt-tab').forEach(tab => {
            tab.replaceWith(tab.cloneNode(true));
        });
        
        // Add event listeners to all plant management tabs
        document.querySelectorAll('.plant-mgmt-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabId = e.target.id;
                this.switchPlantTab(tabId);
            });
        });
        
        // Set initial active plant tab
        this.activePlantTab = 'plant-overview';
    }
    
    // Switch plant management tabs
    async switchPlantTab(tabId) {
        // Remove active from all tabs and content
        document.querySelectorAll('.plant-mgmt-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.plant-mgmt-content').forEach(content => content.classList.remove('active'));
        
        // Add active to selected tab and its content
        const activeTab = document.getElementById(tabId);
        const contentId = tabId.replace('-tab', '-content');
        const activeContent = document.getElementById(contentId);
        
        if (activeTab) activeTab.classList.add('active');
        if (activeContent) activeContent.classList.add('active');
        
        // Set active tab state
        this.activePlantTab = tabId.replace('-tab', '');
        
        // Load content based on tab
        switch (this.activePlantTab) {
            case 'grow-beds':
                await this.loadGrowBedsTab();
                break;
            case 'plant-overview':
                await this.updatePlantOverview();
                break;
            case 'custom-crops':
                await this.loadCustomCrops();
                break;
            case 'spray-programmes':
                await this.setupSprayProgrammes();
                break;
            // Other tabs handled by their existing logic
        }
    }
    
    // Generate grow bed overview (moved from updatePlantOverview)
    async generateGrowBedOverview() {
        try {
            const [plantData, growBeds] = await Promise.all([
                this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`),
                this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`)
            ]);

            // Store data for other functions to use
            this.plantData = plantData;
            this.growBeds = growBeds;

            // Group plant data by batch_id
            const batchMap = new Map();
            plantData.forEach(entry => {
                if (!entry.batch_id) return;
                
                if (!batchMap.has(entry.batch_id)) {
                    batchMap.set(entry.batch_id, {
                        batchId: entry.batch_id,
                        growBedId: entry.grow_bed_id,
                        cropType: entry.crop_type,
                        plantCount: 0,
                        harvestedCount: 0,
                        dateFirst: entry.date,
                        daysToHarvest: entry.days_to_harvest,
                        entries: []
                    });
                }

                const batch = batchMap.get(entry.batch_id);
                batch.entries.push(entry);
                
                if (entry.plants_harvested > 0) {
                    batch.harvestedCount += entry.plants_harvested;
                } else {
                    // Use correct field names from database schema
                    batch.plantCount += entry.new_seedlings || entry.count || 0;
                }
                
                // Keep earliest date
                if (new Date(entry.date) < new Date(batch.dateFirst)) {
                    batch.dateFirst = entry.date;
                }
            });

            let summaryHtml = `
                <div class="unified-bed-overview">
                    <h3><img src="/icons/new-icons/Afraponix Go Icons_growbed.svg" alt="Grow Bed" class="heading-icon" style="width: 1.5em; height: 1.5em; vertical-align: middle; margin-right: 0.5em;"> Grow Bed Management</h3>
                    <p style="color: #666; margin-bottom: 1.5rem; text-align: center;">
                        Manage your grow beds with detailed batch tracking, quick plant/harvest actions, and real-time space utilization.
                    </p>
                    <div class="unified-bed-grid">
            `;

            // Generate card for each grow bed (same logic as before)
            growBeds.forEach(bed => {
                // Get plant data for this bed
                const bedPlantData = plantData.filter(p => p.grow_bed_id == bed.id);
                
                // Get batches for this bed
                const bedBatches = Array.from(batchMap.values()).filter(batch => batch.growBedId == bed.id);
                
                // Calculate bed statistics based on actual plantings from batches
                const totalActualPlants = bedBatches.reduce((sum, batch) => {
                    const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                    return sum + remainingPlants;
                }, 0);
                const bedArea = parseFloat(bed.area_m2) || parseFloat(bed.equivalent_m2) || 0;
                const estimatedCapacity = bed.plant_capacity || Math.floor(bedArea * 25); // Rough estimate: 25 plants per m¬≤
                const spaceUtilization = estimatedCapacity > 0 ? Math.round((totalActualPlants / estimatedCapacity) * 100) : 0;
                
                const bedTypeName = bed.bed_type?.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                
                // Calculate space usage based on bed type
                let spaceUsageDisplay = '';
                const isVertical = bed.bed_type && (bed.bed_type.toLowerCase().includes('vertical') || 
                                                    bed.bed_type.toLowerCase().includes('tower') ||
                                                    bed.bed_type.toLowerCase().includes('nft'));
                
                if (isVertical) {
                    // For vertical systems, use database settings
                    let totalUnits = bed.vertical_count || 0;
                    let plantsPerUnit = bed.plants_per_vertical || 6; // Default to 6 if not set
                    
                    // If no vertical_count set, try to calculate from capacity
                    if (!totalUnits && estimatedCapacity > 0) {
                        totalUnits = Math.ceil(estimatedCapacity / plantsPerUnit);
                    }
                    
                    const unitsUsed = plantsPerUnit > 0 ? Math.ceil(totalActualPlants / plantsPerUnit) : 0;
                    spaceUsageDisplay = `${unitsUsed}/${totalUnits} verticals`;
                } else {
                    // For horizontal beds, calculate m¬≤ used
                    // Using average plant spacing to estimate area usage
                    const avgSpacingM2 = 0.04; // Average 20cm spacing = 0.04m¬≤ per plant
                    const m2Used = (totalActualPlants * avgSpacingM2).toFixed(1);
                    spaceUsageDisplay = `${m2Used}/${bedArea.toFixed(1)}m¬≤ used`;
                }

                // Filter out empty batches
                const activeBatches = bedBatches.filter(batch => {
                    const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                    return remainingPlants > 0;
                });

                summaryHtml += `
                    <div class="bed-item-unified">
                        <div class="bed-header-unified">
                            <div class="bed-title-compact">
                                <h4>${bed.bed_name || `Bed ${bed.bed_number}`}</h4>
                                <span class="bed-type-badge ${bed.bed_type}">${bedTypeName}</span>
                                <span class="bed-area">${bedArea.toFixed(1)}m¬≤</span>
                            </div>
                        </div>

                        <div class="bed-summary-stats">
                            <div class="stat-item">
                                <span class="stat-value">${totalActualPlants}</span>
                                <span class="stat-label">Plants</span>
                            </div>
                            <div class="stat-item space-usage">
                                <span class="stat-value">${spaceUsageDisplay}</span>
                                <span class="stat-label">Space Used</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value ${spaceUtilization >= 80 ? 'high-util' : spaceUtilization >= 50 ? 'medium-util' : 'low-util'}">${spaceUtilization}%</span>
                                <span class="stat-label">Utilization</span>
                            </div>
                        </div>

                        ${(() => {
                            return activeBatches.length > 0 ? `
                                <div class="bed-batches-section">
                                    <h6>üì¶ Active Batches (${activeBatches.length})</h6>
                                    <div class="batches-list">
                                        ${activeBatches.map(batch => {
                                            const daysSincePlanted = Math.floor((new Date() - new Date(batch.dateFirst)) / (1000 * 60 * 60 * 24));
                                            const daysToHarvest = batch.daysToHarvest || 'Unknown';
                                            const isReady = batch.daysToHarvest && daysSincePlanted >= batch.daysToHarvest;
                                            const remainingPlants = Math.max(0, batch.plantCount - batch.harvestedCount);
                                            
                                            return `
                                                <div class="batch-line ${isReady ? 'ready-harvest' : ''}" data-batch-id="${batch.batchId}">
                                                    <div class="batch-header">
                                                        <span class="batch-crop-name">${this.cleanCustomCropName(batch.cropType)}</span>
                                                        <span class="batch-id">ID: ${batch.batchId}</span>
                                                        ${isReady ? '<span class="ready-badge-small">Ready!</span>' : ''}
                                                    </div>
                                                    <div class="batch-details">
                                                        <span class="batch-plants">${remainingPlants} plants remaining</span>
                                                        <span class="batch-age">${daysSincePlanted}d old</span>
                                                        <span class="batch-harvest-info">${daysToHarvest !== 'Unknown' ? `Harvest in ${Math.max(0, daysToHarvest - daysSincePlanted)}d` : 'Harvest time unknown'}</span>
                                                        <span class="batch-planted">Planted: ${new Date(batch.dateFirst).toLocaleDateString()}</span>
                                                    </div>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : '';
                        })()}
                        
                        <!-- Quick Action Buttons -->
                        <div class="tank-actions">
                            <div class="quick-actions-dropdown">
                                <button class="quick-actions-btn" onclick="app.toggleBedQuickActions(${bed.id})">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                        <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                                    </svg>
                                    Quick Actions
                                    <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor" style="margin-left: 4px;">
                                        <path d="M7 10l5 5 5-5z"/>
                                    </svg>
                                </button>
                                <div class="quick-actions-menu" id="bed-quick-actions-${bed.id}" style="display: none;">
                                    <button class="quick-action-item quick-plant-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                        </svg>
                                        Plant
                                    </button>
                                    <button class="quick-action-item quick-harvest-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M12 2L13.09 8.26L22 9L14 14.74L16.18 22L12 18.27L7.82 22L10 14.74L2 9L10.91 8.26L12 2z"/>
                                        </svg>
                                        Harvest
                                    </button>
                                    <button class="quick-action-item quick-move-btn" data-bed-id="${bed.id}" data-bed-name="${(bed.bed_name || 'Bed ' + bed.bed_number).replace(/"/g, '&quot;')}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                                        </svg>
                                        Move Batch
                                    </button>
                                    <button class="quick-action-item quick-details-btn" data-bed-id="${bed.id}">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M13 17.5c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm0-9c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm-6 0c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2z"/>
                                        </svg>
                                        Details
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Quick Plant Form (Hidden by default) -->
                        <div class="inline-quick-form plant-form" id="${idPrefix}quick-plant-${bed.id}" style="display: none;">
                            <h5>Quick Plant - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="quick-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}quick-crop-${bed.id}" onchange="window.app.onQuickCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        <optgroup label="Leafy Greens">
                                            <option value="lettuce">Lettuce (General)</option>
                                            <option value="lettuce_batavian">Lettuce - Batavian</option>
                                            <option value="lettuce_butter">Lettuce - Butter</option>
                                            <option value="lettuce_cos">Lettuce - Cos/Romaine</option>
                                            <option value="lettuce_icty">Lettuce - Little Gem</option>
                                            <option value="spinach">Spinach</option>
                                            <option value="kale">Kale</option>
                                            <option value="swiss_chard">Swiss Chard</option>
                                            <option value="arugula">Arugula</option>
                                            <option value="pac_choi">Pac Choi</option>
                                            <option value="watercress">Watercress</option>
                                        </optgroup>
                                        <optgroup label="Herbs">
                                            <option value="basil">Basil</option>
                                            <option value="cilantro">Cilantro</option>
                                            <option value="parsley">Parsley</option>
                                            <option value="mint">Mint</option>
                                            <option value="chives">Chives</option>
                                        </optgroup>
                                        <optgroup label="Fruiting Plants">
                                            <option value="tomatoes">Tomatoes</option>
                                            <option value="cucumber">Cucumber</option>
                                            <option value="pepper">Peppers</option>
                                            <option value="strawberry">Strawberry</option>
                                        </optgroup>
                                        <optgroup label="Other">
                                            <option value="celery">Celery</option>
                                            <option value="spring_onion">Spring Onion</option>
                                            <option value="leeks">Leeks</option>
                                            <option value="other">Other (Custom)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                
                                <div class="form-group variety-group">
                                    <label for="quick-variety-${bed.id}" class="form-label">Seed Variety</label>
                                    <div class="variety-input-group">
                                        <select class="quick-seed-variety" id="${idPrefix}quick-variety-${bed.id}" disabled onchange="window.app.onQuickVarietyChange('${bed.id}', '${idPrefix}')">
                                            <option value="">Select variety (optional)...</option>
                                            <option value="_new">+ Add New Variety</option>
                                        </select>
                                        <input type="text" class="quick-new-variety" id="${idPrefix}quick-new-variety-${bed.id}" placeholder="Enter new variety name" style="display: none;">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-count-${bed.id}" class="form-label">Plant Count</label>
                                        <input type="number" class="quick-plant-count" id="${idPrefix}quick-count-${bed.id}" placeholder="Number of plants" min="1">
                                    </div>
                                    ${!isVertical ? `
                                    <div class="form-group">
                                        <label for="quick-spacing-${bed.id}" class="form-label">Plant Spacing (cm)</label>
                                        <input type="number" class="quick-plant-spacing" id="${idPrefix}quick-spacing-${bed.id}" placeholder="e.g., 20" min="5" max="50" step="0.5">
                                    </div>
                                    ` : ''}
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="quick-days-${bed.id}" class="form-label">Days to Harvest</label>
                                        <input type="number" class="quick-days-harvest" id="${idPrefix}quick-days-${bed.id}" placeholder="e.g., 45" min="1" max="365">
                                    </div>
                                    <div class="form-group">
                                        <label for="quick-date-${bed.id}" class="form-label">Planting Date</label>
                                        <input type="datetime-local" class="quick-plant-date" id="${idPrefix}quick-date-${bed.id}" value="${new Date().toISOString().slice(0, 16)}">
                                    </div>
                                </div>
                                
                                <input type="text" class="quick-custom-crop" id="${idPrefix}quick-custom-${bed.id}" placeholder="Enter custom crop name" style="display: none;">
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickPlantSubmit('${bed.id}')"><img src="/icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" class="btn-icon-svg" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.5em;"> Plant</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}plant-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Inline Quick Harvest Form (Hidden by default) -->
                        <div class="inline-quick-form harvest-form" id="${idPrefix}quick-harvest-${bed.id}" style="display: none;">
                            <h5>Quick Harvest - ${bed.bed_name || `Bed ${bed.bed_number}`}</h5>
                            <div class="enhanced-quick-form-grid">
                                <div class="form-group">
                                    <label for="harvest-crop-${bed.id}" class="form-label">Crop Type</label>
                                    <select class="quick-crop-select" id="${idPrefix}harvest-crop-${bed.id}" onchange="window.app.onHarvestCropChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop...</option>
                                        ${[...new Set(bedPlantData.filter(p => p.crop_type && !p.plants_harvested).map(p => p.crop_type))].map(crop => `
                                            <option value="${crop}">${this.cleanCustomCropName(crop)}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="harvest-batch-${bed.id}" class="form-label">Select Batch</label>
                                    <select class="quick-batch-select" id="${idPrefix}harvest-batch-${bed.id}" disabled onchange="window.app.onHarvestBatchChange('${bed.id}', '${idPrefix}')">
                                        <option value="">Select crop first...</option>
                                    </select>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="harvest-count-${bed.id}" class="form-label">Plants to Harvest</label>
                                        <input type="number" class="quick-harvest-count" id="${idPrefix}harvest-count-${bed.id}" placeholder="0" min="0" max="0">
                                        <small class="form-help" id="${idPrefix}harvest-help-${bed.id}">Select batch first</small>
                                    </div>
                                    <div class="form-group">
                                        <label for="harvest-weight-${bed.id}" class="form-label">Total Weight (kg)</label>
                                        <input type="number" class="quick-harvest-weight" id="${idPrefix}harvest-weight-${bed.id}" placeholder="0.0" min="0" step="0.1">
                                    </div>
                                </div>
                                
                                <div class="quick-form-actions">
                                    <button class="quick-submit-btn" onclick="window.app.quickHarvestSubmit('${bed.id}')">üåæ Harvest</button>
                                    <button class="quick-cancel-btn" onclick="window.app.toggleQuickForm('${idPrefix}harvest-${bed.id}')">Cancel</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Bed Details Section (Hidden by default) -->
                        <div class="bed-details-section" id="${idPrefix}bed-details-${bed.id}" style="display: none;">
                            <div class="details-loading">Loading bed details...</div>
                        </div>
                    </div>
                `;
            });

            summaryHtml += `
                    </div>
                </div>
            `;

            return summaryHtml;
            
        } catch (error) {
            console.error('Error generating grow bed overview:', error);
            return '<div class="error-message">Failed to load grow bed data. Please try again.</div>';
        }
    }
    
    // Initialize quick action buttons
    initializeQuickActions() {
        // Remove existing listener to prevent duplicates
        if (this.quickActionHandler) {
            document.removeEventListener('click', this.quickActionHandler);
        }
        
        // Create and store the handler function
        this.quickActionHandler = (e) => {
            if (e.target.classList.contains('quick-action-btn')) {
                e.preventDefault();
                
                const bedId = e.target.dataset.bedId;
                
                if (e.target.classList.contains('plant-btn')) {
                    // Check if we're in beds overview tab by looking for beds- prefixed forms
                    const prefix = document.getElementById(`beds-quick-plant-${bedId}`) ? 'beds-' : '';
                    const formType = prefix ? `beds-plant-${bedId}` : `plant-${bedId}`;
                    this.toggleQuickForm(formType);
                } else if (e.target.classList.contains('harvest-btn')) {
                    // Check if we're in beds overview tab by looking for beds- prefixed forms  
                    const prefix = document.getElementById(`beds-quick-harvest-${bedId}`) ? 'beds-' : '';
                    const formType = prefix ? `beds-harvest-${bedId}` : `harvest-${bedId}`;
                    this.toggleQuickForm(formType);
                } else if (e.target.classList.contains('details-btn')) {
                    // Show bed details inline
                    const prefix = document.getElementById(`beds-bed-details-${bedId}`) ? 'beds-' : '';
                    this.toggleBedDetails(bedId, prefix);
                }
            }
        };
        
        // Add the event listener
        document.addEventListener('click', this.quickActionHandler);
        
        // Initialize keyboard shortcuts
        this.initializeKeyboardShortcuts();
    }
    
    // Initialize grow bed specific features for proper form functionality
    initializeGrowBedFeatures() {
        // Debug: Log that initialization is starting
        
        // Force re-initialization of quick actions with a small delay
        // to ensure DOM is fully rendered
        setTimeout(() => {
            this.initializeQuickActions();
        }, 100);
        
        // Ensure window.app is properly bound
        if (!window.app) {
            window.app = this;
        }
        
    }
    
    // Initialize keyboard shortcuts
    initializeKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Only activate shortcuts when not typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            
            // Check for command/ctrl key combinations
            const isModKey = e.metaKey || e.ctrlKey;
            
            if (isModKey) {
                switch(e.key.toLowerCase()) {
                    case 'p':
                        e.preventDefault();
                        this.openQuickPlantDialog();
                        break;
                    case 'h':
                        e.preventDefault();
                        this.openQuickHarvestDialog();
                        break;
                    case 'k':
                        e.preventDefault();
                        this.openCommandPalette();
                        break;
                    case '/':
                        e.preventDefault();
                        this.focusSearch();
                        break;
                }
            }
            
            // Single key shortcuts (when not in input)
            switch(e.key.toLowerCase()) {
                case '?':
                    e.preventDefault();
                    this.showKeyboardShortcuts();
                    break;
                case 'g':
                    if (!this.gKeyPressed) {
                        this.gKeyPressed = true;
                        setTimeout(() => { this.gKeyPressed = false; }, 1000);
                    } else {
                        // Double 'g' pressed
                        e.preventDefault();
                        switch(e.key.toLowerCase()) {
                            case 'p':
                                this.navigateToPlants();
                                break;
                            case 'd':
                                this.navigateToDashboard();
                                break;
                            case 'f':
                                this.navigateToFish();
                                break;
                        }
                    }
                    break;
            }
        });
    }
    
    // Quick plant dialog
    // Removed duplicate openQuickPlantDialog function - now using the one with bedId/bedName parameters
    
    
    // Show keyboard shortcuts help
    showKeyboardShortcuts() {
        const shortcuts = `
            <div style="padding: 1rem;">
                <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                <div style="display: grid; gap: 0.5rem; margin-top: 1rem;">
                    <div><kbd>Cmd/Ctrl + P</kbd> - Quick Plant</div>
                    <div><kbd>Cmd/Ctrl + H</kbd> - Quick Harvest</div>
                    <div><kbd>Cmd/Ctrl + K</kbd> - Command Palette</div>
                    <div><kbd>Cmd/Ctrl + /</kbd> - Focus Search</div>
                    <div><kbd>?</kbd> - Show this help</div>
                    <div><kbd>g g</kbd> - Go to Dashboard</div>
                    <div><kbd>g p</kbd> - Go to Plants</div>
                    <div><kbd>g f</kbd> - Go to Fish</div>
                </div>
            </div>
        `;
        
        this.showNotification(shortcuts, 'info', 5000);
    }
    
    // Navigation helpers
    navigateToPlants() {
        const plantsBtn = document.querySelector('[data-view="plants"]');
        if (plantsBtn) plantsBtn.click();
    }
    
    navigateToDashboard() {
        // Delegate to DashboardUI component if available
        if (this.dashboardUI && typeof this.dashboardUI.navigateTo === 'function') {
            return this.dashboardUI.navigateTo();
        } else {
            // Fallback to direct DOM manipulation
            const dashBtn = document.querySelector('[data-view="dashboard"]');
            if (dashBtn) dashBtn.click();
        }
    }
    
    navigateToFish() {
        const fishBtn = document.querySelector('[data-view="fish"]');
        if (fishBtn) fishBtn.click();
    }
    
    focusSearch() {
        // Implement search focus if there's a search bar
        const searchInput = document.querySelector('.search-input');
        if (searchInput) {
            searchInput.focus();
            searchInput.select();
        }
    }
    
    // Toggle bed details section
    async toggleBedDetails(bedId, prefix = '') {
        const detailsSection = document.getElementById(`${prefix}bed-details-${bedId}`);
        if (!detailsSection) return;
        
        const isVisible = detailsSection.style.display !== 'none';
        
        // Hide all other details sections
        document.querySelectorAll('.bed-details-section').forEach(section => {
            section.style.display = 'none';
        });
        
        // Hide all quick forms too
        document.querySelectorAll('.inline-quick-form').forEach(form => {
            form.style.display = 'none';
        });
        
        if (isVisible) {
            // Already visible, just hide it
            detailsSection.style.display = 'none';
            return;
        }
        
        // Show and populate details
        detailsSection.style.display = 'block';
        
        try {
            // Get bed details, allocations, and plant history
            const [beds, allocations, plantHistory] = await Promise.all([
                this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`),
                this.makeApiCall(`/plants/allocations/${this.activeSystemId}`),
                this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`)
            ]);
            
            const bed = beds.find(b => b.id == bedId);
            const bedAllocations = allocations.filter(a => a.grow_bed_id == bedId);
            const bedPlantHistory = plantHistory.filter(p => p.grow_bed_id == bedId);
            
            if (!bed) {
                detailsSection.innerHTML = '<div class="error">Bed not found</div>';
                return;
            }
            
            // Generate detailed view
            const detailsHtml = this.generateBedDetailsHtml(bed, bedAllocations, bedPlantHistory);
            detailsSection.innerHTML = detailsHtml;
            
        } catch (error) {
            console.error('Error loading bed details:', error);
            detailsSection.innerHTML = '<div class="error">Failed to load bed details</div>';
        }
    }
    
    // Generate detailed bed information HTML
    generateBedDetailsHtml(bed, allocations, plantHistory) {
        const bedTypeName = bed.bed_type?.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
        
        // Recent activity (last 10 entries)
        const recentActivity = plantHistory
            .sort((a, b) => new Date(b.date || b.created_at) - new Date(a.date || a.created_at))
            .slice(0, 10);
        
        // Current crops with counts
        const currentCrops = {};
        plantHistory.forEach(entry => {
            if (!entry.crop_type) return;
            
            const cleanName = this.cleanCustomCropName(entry.crop_type);
            if (!currentCrops[cleanName]) {
                currentCrops[cleanName] = { planted: 0, harvested: 0 };
            }
            
            if (entry.plants_harvested) {
                currentCrops[cleanName].harvested += entry.plants_harvested || 0;
            } else {
                currentCrops[cleanName].planted += entry.plant_count || 0;
            }
        });
        
        return `
            <div class="bed-details-content">
                <h5>üìä ${bed.bed_name || `Bed ${bed.bed_number}`} Details</h5>
                
                <!-- Bed Specifications -->
                <div class="details-section">
                    <h6>üèóÔ∏è Specifications</h6>
                    <div class="details-grid">
                        <div class="detail-item">
                            <span class="detail-label">Type:</span>
                            <span class="detail-value">${bedTypeName}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Area:</span>
                            <span class="detail-value">${(parseFloat(bed.area_m2) || parseFloat(bed.equivalent_m2) || 0).toFixed(1)}m¬≤</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Volume:</span>
                            <span class="detail-value">${bed.volume_liters || 0}L</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Capacity:</span>
                            <span class="detail-value">${bed.plant_capacity || 'N/A'} plants</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Dimensions:</span>
                            <span class="detail-value">${bed.length_meters || 0}m √ó ${bed.width_meters || 0}m √ó ${bed.height_meters || 0}m</span>
                        </div>
                    </div>
                </div>
                
                <!-- Current Crops -->
                <div class="details-section">
                    <h6>üåø Current Crops</h6>
                    <div class="current-crops-list">
                        ${Object.keys(currentCrops).length > 0 ? Object.entries(currentCrops).map(([crop, counts]) => {
                            const remaining = counts.planted - counts.harvested;
                            return `
                                <div class="crop-detail-item">
                                    <span class="crop-name">${crop}</span>
                                    <span class="crop-counts">
                                        ${remaining > 0 ? `${remaining} active` : 'None active'}
                                        <small>(${counts.planted} planted, ${counts.harvested} harvested)</small>
                                    </span>
                                </div>
                            `;
                        }).join('') : '<div class="no-data">No crops currently planted</div>'}
                    </div>
                </div>
                
                <!-- Allocations -->
                <div class="details-section">
                    <h6>üìã Crop Allocations</h6>
                    <div class="allocations-list">
                        ${allocations.length > 0 ? allocations.map(alloc => `
                            <div class="allocation-item">
                                <span class="crop-name">${this.cleanCustomCropName(alloc.crop_type)}</span>
                                <span class="allocation-percentage">${alloc.percentage_allocated || 0}%</span>
                                <span class="allocation-plants">${alloc.plants_planted || 0} plants</span>
                            </div>
                        `).join('') : '<div class="no-data">No crop allocations set</div>'}
                    </div>
                </div>
                
                <!-- Recent Activity -->
                <div class="details-section">
                    <h6>üìÖ Recent Activity</h6>
                    <div class="activity-list">
                        ${recentActivity.length > 0 ? recentActivity.map(activity => {
                            const date = new Date(activity.date || activity.created_at);
                            const isHarvest = activity.plants_harvested > 0;
                            return `
                                <div class="activity-item">
                                    <span class="activity-icon">${isHarvest ? 'üåæ' : 'üå±'}</span>
                                    <div class="activity-content">
                                        <div class="activity-description">
                                            ${isHarvest ? 'Harvested' : 'Planted'} 
                                            ${isHarvest ? activity.plants_harvested : activity.plant_count} 
                                            ${this.cleanCustomCropName(activity.crop_type)}
                                            ${isHarvest && activity.harvest_weight ? ` (${(activity.harvest_weight / 1000).toFixed(1)}kg)` : ''}
                                        </div>
                                        <div class="activity-date">${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<div class="no-data">No recent activity</div>'}
                    </div>
                </div>
                
                <div class="details-actions">
                    <button class="details-close-btn" onclick="window.app.toggleBedDetails('${bed.id}')">
                        Close Details
                    </button>
                </div>
            </div>
        `;
    }
    
    // Command Palette functionality
    openCommandPalette() {
        // Remove existing palette if any
        const existing = document.getElementById('command-palette');
        if (existing) {
            existing.remove();
            return;
        }
        
        // Create command palette
        const palette = document.createElement('div');
        palette.id = 'command-palette';
        palette.className = 'command-palette-overlay';
        palette.innerHTML = `
            <div class="command-palette">
                <div class="command-palette-header">
                    <input type="text" 
                           id="command-input" 
                           class="command-input" 
                           placeholder="Type a command or search..."
                           autocomplete="off">
                    <button class="command-close" onclick="window.app.closeCommandPalette()">‚úï</button>
                </div>
                <div class="command-results" id="command-results">
                    <div class="command-section">
                        <div class="command-section-title">Quick Actions</div>
                        <div class="command-item" data-command="plant">
                            <span class="command-icon"><img src="/icons/new-icons/Afraponix Go Icons_plant.svg" alt="Plant" style="width: 1em; height: 1em;"></span>
                            <span class="command-text">Plant Crops</span>
                            <span class="command-shortcut">Cmd+P</span>
                        </div>
                        <div class="command-item" data-command="harvest">
                            <span class="command-icon">üåæ</span>
                            <span class="command-text">Harvest Crops</span>
                            <span class="command-shortcut">Cmd+H</span>
                        </div>
                        <div class="command-item" data-command="water-quality">
                            <span class="command-icon"><img src="/icons/new-icons/Afraponix Go Icons_hydro.svg" alt="Water" style="width: 1em; height: 1em;"></span>
                            <span class="command-text">Add Water Quality Data</span>
                        </div>
                        <div class="command-item" data-command="fish-feed">
                            <span class="command-icon">üêü</span>
                            <span class="command-text">Record Fish Feeding</span>
                        </div>
                    </div>
                    <div class="command-section">
                        <div class="command-section-title">Navigation</div>
                        <div class="command-item" data-command="go-dashboard">
                            <span class="command-icon"><img src="/icons/new-icons/Afraponix Go Icons_data.svg" alt="Dashboard" style="width: 1em; height: 1em;"></span>
                            <span class="command-text">Go to Dashboard</span>
                            <span class="command-shortcut">g g</span>
                        </div>
                        <div class="command-item" data-command="go-plants">
                            <span class="command-icon">üåø</span>
                            <span class="command-text">Go to Plants</span>
                            <span class="command-shortcut">g p</span>
                        </div>
                        <div class="command-item" data-command="go-fish">
                            <span class="command-icon">üê†</span>
                            <span class="command-text">Go to Fish</span>
                            <span class="command-shortcut">g f</span>
                        </div>
                        <div class="command-item" data-command="go-settings">
                            <span class="command-icon">‚öôÔ∏è</span>
                            <span class="command-text">Go to Settings</span>
                        </div>
                    </div>
                    <div class="command-section">
                        <div class="command-section-title">System</div>
                        <div class="command-item" data-command="refresh">
                            <span class="command-icon">üîÑ</span>
                            <span class="command-text">Refresh Data</span>
                        </div>
                        <div class="command-item" data-command="help">
                            <span class="command-icon">‚ùì</span>
                            <span class="command-text">Show Keyboard Shortcuts</span>
                            <span class="command-shortcut">?</span>
                        </div>
                        <div class="command-item" data-command="logout">
                            <span class="command-icon">üö™</span>
                            <span class="command-text">Logout</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(palette);
        
        // Focus input
        const input = document.getElementById('command-input');
        input.focus();
        
        // Set up event listeners
        input.addEventListener('input', (e) => this.filterCommands(e.target.value));
        input.addEventListener('keydown', (e) => this.handleCommandNavigation(e));
        
        // Click handler for commands
        document.querySelectorAll('.command-item').forEach(item => {
            item.addEventListener('click', () => this.executeCommand(item.dataset.command));
        });
        
        // Close on ESC or outside click
        palette.addEventListener('click', (e) => {
            if (e.target === palette) {
                this.closeCommandPalette();
            }
        });
        
        document.addEventListener('keydown', this.commandPaletteEscHandler = (e) => {
            if (e.key === 'Escape') {
                this.closeCommandPalette();
            }
        });
    }
    
    closeCommandPalette() {
        const palette = document.getElementById('command-palette');
        if (palette) {
            palette.remove();
            if (this.commandPaletteEscHandler) {
                document.removeEventListener('keydown', this.commandPaletteEscHandler);
            }
        }
    }
    
    filterCommands(query) {
        const items = document.querySelectorAll('.command-item');
        const sections = document.querySelectorAll('.command-section');
        
        if (!query) {
            items.forEach(item => item.style.display = 'flex');
            sections.forEach(section => section.style.display = 'block');
            return;
        }
        
        const lowerQuery = query.toLowerCase();
        sections.forEach(section => {
            let hasVisibleItems = false;
            
            section.querySelectorAll('.command-item').forEach(item => {
                const text = item.querySelector('.command-text').textContent.toLowerCase();
                const matches = text.includes(lowerQuery);
                item.style.display = matches ? 'flex' : 'none';
                if (matches) hasVisibleItems = true;
            });
            
            section.style.display = hasVisibleItems ? 'block' : 'none';
        });
    }
    
    handleCommandNavigation(e) {
        const items = Array.from(document.querySelectorAll('.command-item')).filter(
            item => item.style.display !== 'none'
        );
        
        const currentIndex = items.findIndex(item => item.classList.contains('selected'));
        
        switch(e.key) {
            case 'ArrowDown':
                e.preventDefault();
                const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                items.forEach(item => item.classList.remove('selected'));
                if (items[nextIndex]) items[nextIndex].classList.add('selected');
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                items.forEach(item => item.classList.remove('selected'));
                if (items[prevIndex]) items[prevIndex].classList.add('selected');
                break;
                
            case 'Enter':
                e.preventDefault();
                const selected = document.querySelector('.command-item.selected');
                if (selected) {
                    this.executeCommand(selected.dataset.command);
                } else if (items.length > 0) {
                    this.executeCommand(items[0].dataset.command);
                }
                break;
        }
    }
    
    executeCommand(command) {
        this.closeCommandPalette();
        
        switch(command) {
            case 'plant':
                this.openQuickPlantDialog();
                break;
            case 'harvest':
                this.openQuickHarvestDialog();
                break;
            case 'water-quality':
                this.navigateToDashboard();
                setTimeout(() => {
                    const waterBtn = document.querySelector('.action-btn[onclick*="Water Quality"]');
                    if (waterBtn) waterBtn.click();
                }, 100);
                break;
            case 'fish-feed':
                this.navigateToFish();
                setTimeout(() => {
                    const feedBtn = document.querySelector('.action-btn[onclick*="Feeding"]');
                    if (feedBtn) feedBtn.click();
                }, 100);
                break;
            case 'go-dashboard':
                this.navigateToDashboard();
                break;
            case 'go-plants':
                this.navigateToPlants();
                break;
            case 'go-fish':
                this.navigateToFish();
                break;
            case 'go-settings':
                const settingsBtn = document.querySelector('[data-view="settings"]');
                if (settingsBtn) settingsBtn.click();
                break;
            case 'refresh':
                location.reload();
                break;
            case 'help':
                this.showKeyboardShortcuts();
                break;
            case 'logout':
                this.logout();
                break;
        }
    }

    // REMOVED: generateBedCropDisplay - replaced with simpler batch-based display

    calculateCurrentPlantCount(plantData) {
        // Use batch-based counting for accurate plant counts
        const batchMap = new Map();
        const cropHasBatchData = new Set();
        
        // First pass: identify which crops have batch data
        plantData.forEach(record => {
            if (record.batch_id && record.crop_type) {
                cropHasBatchData.add(record.crop_type);
            }
        });
        
        // Process all plant records to build batch data
        plantData.forEach(record => {
            if (record.batch_id && record.new_seedlings > 0) {
                // This is a planting record with a batch
                if (!batchMap.has(record.batch_id)) {
                    batchMap.set(record.batch_id, {
                        batch_id: record.batch_id,
                        crop_type: record.crop_type,
                        planted_count: 0,
                        harvested_count: 0
                    });
                }
                const batch = batchMap.get(record.batch_id);
                batch.planted_count += record.new_seedlings || 0;
            }
        });
        
        // Process harvest records
        plantData.forEach(record => {
            if (record.batch_id && record.plants_harvested > 0) {
                if (batchMap.has(record.batch_id)) {
                    const batch = batchMap.get(record.batch_id);
                    batch.harvested_count += record.plants_harvested || 0;
                }
            }
        });
        
        // Calculate total from batches
        let totalCurrent = 0;
        batchMap.forEach(batch => {
            const remaining = Math.max(0, batch.planted_count - batch.harvested_count);
            totalCurrent += remaining;
        });
        
        // Only include non-batch plants for crops that have NO batch data
        const nonBatchPlants = {};
        plantData.forEach(entry => {
            if (!entry.batch_id && entry.crop_type && entry.count > 0 && !entry.plants_harvested) {
                // Only consider this non-batch plant if the crop has no batch data at all
                if (!cropHasBatchData.has(entry.crop_type)) {
                    const key = entry.crop_type;
                    if (!nonBatchPlants[key] || new Date(entry.date) > new Date(nonBatchPlants[key].date)) {
                        nonBatchPlants[key] = entry;
                    }
                }
            }
        });
        
        // Add non-batch plants only for crops without batch data
        Object.values(nonBatchPlants).forEach(entry => {
            const planted = entry.count || 0;
            const harvested = this.getHarvestedCount(plantData.filter(p => !p.batch_id && p.crop_type === entry.crop_type), entry.crop_type);
            totalCurrent += Math.max(0, planted - harvested);
        });

        return totalCurrent;
    }

    getCropPlantCount(plantData, cropType) {
        // Use batch-based counting for accurate crop counts
        const batchMap = new Map();
        let hasBatchData = false;
        
        // First pass: check if we have any batch data for this crop
        plantData.filter(entry => entry.crop_type === cropType).forEach(record => {
            if (record.batch_id) {
                hasBatchData = true;
            }
        });
        
        // Process all records for this crop type
        plantData.filter(entry => entry.crop_type === cropType).forEach(record => {
            if (record.batch_id) {
                // Batch-based plant
                if (record.new_seedlings > 0 && !record.plants_harvested) {
                    // This is a planting record
                    if (!batchMap.has(record.batch_id)) {
                        batchMap.set(record.batch_id, {
                            planted: 0,
                            harvested: 0
                        });
                    }
                    const batch = batchMap.get(record.batch_id);
                    batch.planted += record.new_seedlings || 0;
                    
                } else if (record.plants_harvested > 0) {
                    // This is a harvest record
                    const batchExisted = batchMap.has(record.batch_id);
                    if (!batchExisted) {
                        // Create batch entry if it doesn't exist yet (harvest before planting record processed)
                        batchMap.set(record.batch_id, {
                            planted: 0,
                            harvested: 0
                        });
                    }
                    batchMap.get(record.batch_id).harvested += record.plants_harvested;
                    
                }
            }
        });
        
        // Calculate total from batches
        let totalRemaining = 0;
        batchMap.forEach((batch, batchId) => {
            const remaining = Math.max(0, batch.planted - batch.harvested);
            totalRemaining += remaining;
            
        });
        
        // Only include non-batch plants if there's NO batch data for this crop
        if (!hasBatchData) {
            // Legacy handling for crops with no batch data
            let nonBatchPlanted = 0;
            let nonBatchHarvested = 0;
            
            plantData.filter(entry => entry.crop_type === cropType && !entry.batch_id).forEach(record => {
                if (record.count > 0 && !record.plants_harvested) {
                    // Keep only the latest planting for non-batch
                    nonBatchPlanted = record.count;
                } else if (record.plants_harvested > 0) {
                    nonBatchHarvested += record.plants_harvested;
                }
            });
            
            totalRemaining = Math.max(0, nonBatchPlanted - nonBatchHarvested);
        }

        return totalRemaining;
    }

    getHarvestedCount(plantData, cropType) {
        const harvestEntries = plantData.filter(entry => entry.crop_type === cropType && entry.plants_harvested > 0);
        const totalHarvested = harvestEntries.reduce((sum, entry) => sum + (entry.plants_harvested || 0), 0);

        return totalHarvested;
    }

    // Quick debug function to see all lettuce records
    async debugLettuceRecords() {
        if (!this.activeSystemId) {

            return;
        }
        
        try {
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            const lettuceRecords = plantData.filter(r => r.crop_type === 'lettuce');

            const batchRecords = lettuceRecords.filter(r => r.batch_id);
            const nonBatchRecords = lettuceRecords.filter(r => !r.batch_id);

            return { all: lettuceRecords, batched: batchRecords, nonBatch: nonBatchRecords };
        } catch (error) {
            console.error('Error debugging lettuce records:', error);
        }
    }

    getBatchHarvestedCount(plantData, batchId) {
        const harvestEntries = plantData.filter(entry => 
            entry.batch_id === batchId && 
            entry.plants_harvested > 0
        );
        const totalHarvested = harvestEntries.reduce((sum, entry) => sum + (entry.plants_harvested || 0), 0);

        return totalHarvested;
    }

    updateGrowBeds() {
        const container = document.getElementById('grow-beds-container');
        if (!container) return;

        const systemConfig = this.loadSystemConfig();
        if (!systemConfig || systemConfig.system_name === 'No System Selected') {
            container.innerHTML = '<div class="no-plant-data">No system selected</div>';
            return;
        }

        const plantData = this.dataRecords.plantGrowth || [];
        const growBeds = this.generateGrowBedInfo(systemConfig, plantData);

        if (growBeds.length === 0) {
            container.innerHTML = '<div class="no-plant-data">No grow bed data available</div>';
            return;
        }

        const bedsHtml = growBeds.map(bed => `
            <div class="grow-bed-card">
                <div class="grow-bed-header">
                    <div class="grow-bed-name">Grow Bed ${bed.number}</div>
                    <div class="grow-bed-status ${bed.status.toLowerCase()}">${bed.status}</div>
                </div>
                <div class="grow-bed-details">
                    ${bed.details}
                </div>
            </div>
        `).join('');

        container.innerHTML = `<div class="grow-beds-grid">${bedsHtml}</div>`;
    }

    updatePlantGrowthHistoryDisplay() {
        const container = document.getElementById('plant-growth-history');
        if (!container) return;

        const plantData = this.dataRecords.plantGrowth || [];
        
        if (plantData.length === 0) {
            container.innerHTML = '<div class="no-plant-data">No plant growth data recorded yet.</div>';
            return;
        }

        const recentData = plantData.slice(0, 10); // Show last 10 entries
        const historyHtml = recentData.map(item => {
            const cleanCropName = item.crop_type ? this.cleanCustomCropName(item.crop_type) : 'Unknown';
            const displayName = cleanCropName !== 'Unknown' ? cleanCropName.charAt(0).toUpperCase() + cleanCropName.slice(1) : 'Unknown';
            return `
            <div class="plant-history-item">
                <div class="plant-history-header">
                    <div class="plant-history-crop">${displayName}</div>
                    <div class="plant-history-date">${this.formatEntryDate(item.date)}</div>
                </div>
                <div class="plant-history-details">
                    ${this.formatPlantGrowthEntry(item)}
                </div>
            </div>
            `;
        }).join('');

        container.innerHTML = `<div class="plant-history-list">${historyHtml}</div>`;
    }

    async updatePlantRecommendations() {
        const container = document.getElementById('plant-recommendations');
        if (!container) return;

        const systemConfig = this.loadSystemConfig();
        const waterQuality = this.getLatestWaterQualityData();
        const plantData = this.dataRecords.plantGrowth || [];
        
        const recommendations = this.generatePlantRecommendations(systemConfig, waterQuality, plantData);

        const recommendationsHtml = recommendations.map(rec => `
            <div class="recommendation-card">
                <div class="recommendation-title">
                    ${rec.icon} ${rec.title}
                </div>
                <div class="recommendation-content">
                    ${rec.content}
                </div>
            </div>
        `).join('');

        container.innerHTML = `<div class="plant-recommendations-grid">${recommendationsHtml}</div>`;
    }

    calculateTotalPlants(plantData) {

        if (plantData.length === 0) return 0;
        
        // Use the same batch-based counting logic as calculateCurrentPlantCount
        const batchMap = new Map();
        const cropHasBatchData = new Set();
        
        // First pass: identify which crops have batch data
        plantData.forEach(record => {
            if (record.batch_id && record.crop_type) {
                cropHasBatchData.add(record.crop_type);
            }
        });
        
        // Process all plant records to build batch data
        plantData.forEach(record => {
            if (record.batch_id && record.new_seedlings > 0) {
                // This is a planting record with a batch
                if (!batchMap.has(record.batch_id)) {
                    batchMap.set(record.batch_id, {
                        batch_id: record.batch_id,
                        crop_type: record.crop_type,
                        planted_count: 0,
                        harvested_count: 0
                    });
                }
                const batch = batchMap.get(record.batch_id);
                batch.planted_count += record.new_seedlings || 0;
            }
        });
        
        // Process harvest records
        plantData.forEach(record => {
            if (record.batch_id && record.plants_harvested > 0) {
                if (batchMap.has(record.batch_id)) {
                    const batch = batchMap.get(record.batch_id);
                    batch.harvested_count += record.plants_harvested || 0;
                }
            }
        });
        
        // Calculate total from batches
        let totalCurrent = 0;
        batchMap.forEach(batch => {
            const remaining = Math.max(0, batch.planted_count - batch.harvested_count);
            totalCurrent += remaining;
        });
        
        // Only include non-batch plants for crops that have NO batch data
        const nonBatchPlants = {};
        plantData.forEach(entry => {
            if (!entry.batch_id && entry.crop_type && entry.count > 0 && !entry.plants_harvested) {
                // Only consider this non-batch plant if the crop has no batch data at all
                if (!cropHasBatchData.has(entry.crop_type)) {
                    const key = entry.crop_type;
                    if (!nonBatchPlants[key] || new Date(entry.date) > new Date(nonBatchPlants[key].date)) {
                        nonBatchPlants[key] = entry;
                    }
                }
            }
        });
        
        // Add non-batch plants only for crops without batch data
        Object.values(nonBatchPlants).forEach(entry => {
            const planted = entry.count || 0;
            const harvested = this.getHarvestedCount(plantData.filter(p => !p.batch_id && p.crop_type === entry.crop_type), entry.crop_type);
            totalCurrent += Math.max(0, planted - harvested);
        });

        return totalCurrent;
    }

    getActiveGrowBeds(plantData) {
        if (plantData.length === 0) return 0;
        
        // Count unique crop types as active beds
        const activeCrops = new Set();
        plantData.forEach(item => {
            if (item.crop_type && item.count > 0) {
                activeCrops.add(item.crop_type);
            }
        });
        
        return activeCrops.size;
    }

    calculateTotalHarvested(plantData) {
        return plantData.reduce((total, item) => {
            const weight = parseFloat(item.harvest_weight) || 0;
            return total + weight;
        }, 0);
    }
    
    formatWeight(grams) {
        if (grams >= 1000) {
            return `${(grams / 1000).toFixed(1)}kg`;
        }
        return `${grams}g`;
    }
    
    getActiveBatchCount(plantData) {
        // Simple and correct: count batches with plants remaining
        const batches = new Map();
        
        
        // Process all entries
        plantData.forEach(entry => {
            if (!entry.batch_id) return;
            
            const key = `${entry.grow_bed_id}-${entry.batch_id}`;
            if (!batches.has(key)) {
                batches.set(key, { planted: 0, harvested: 0 });
            }
            
            const batch = batches.get(key);
            if (entry.new_seedlings > 0) {
                batch.planted += entry.new_seedlings;
            }
            if (entry.plants_harvested > 0) {
                batch.harvested += entry.plants_harvested;
            }
        });
        
        
        // Count batches with remaining plants
        let activeBatchCount = 0;
        batches.forEach((batch, key) => {
            const remaining = batch.planted - batch.harvested;
            if (remaining > 0) {
                activeBatchCount++;
            } else {
            }
        });
        
        
        // Show all batches for user verification
        batches.forEach((batch, key) => {
            const remaining = batch.planted - batch.harvested;
            const status = remaining > 0 ? '‚úÖ ACTIVE' : '‚ùå FULLY HARVESTED';
        });
        
        return activeBatchCount;
    }

    getLastHarvestDate(plantData) {
        const harvestData = plantData.filter(item => item.harvest_weight > 0);
        if (harvestData.length === 0) return null;
        
        const latest = harvestData.reduce((latest, item) => {
            return new Date(item.date) > new Date(latest.date) ? item : latest;
        });
        
        return this.formatEntryDate(latest.date);
    }

    generateGrowBedInfo(systemConfig, plantData) {
        const beds = [];
        const growBedCount = systemConfig.grow_bed_count || 4;
        
        // Get latest data for each crop type
        const cropData = {};
        plantData.forEach(item => {
            if (item.crop_type) {
                if (!cropData[item.crop_type] || new Date(item.date) > new Date(cropData[item.crop_type].date)) {
                    cropData[item.crop_type] = item;
                }
            }
        });
        
        const crops = Object.values(cropData);
        
        for (let i = 1; i <= growBedCount; i++) {
            let bed = {
                number: i,
                status: 'Empty',
                details: 'No plants currently growing'
            };
            
            if (crops[i - 1]) {
                const crop = crops[i - 1];
                bed = {
                    number: i,
                    status: this.getPlantStatus(crop),
                    details: this.getPlantDetails(crop)
                };
            }
            
            beds.push(bed);
        }
        
        return beds;
    }

    getPlantStatus(crop) {
        if (!crop.growth_stage) return 'Growing';
        
        const stage = crop.growth_stage.toLowerCase();
        if (stage.includes('seed') || stage.includes('germination')) return 'Growing';
        if (stage.includes('mature') || stage.includes('ready')) return 'Ready';
        if (crop.health === 'excellent' || crop.health === 'good') return 'Healthy';
        return 'Growing';
    }

    getPlantDetails(crop) {
        const details = [];
        const cleanCropName = crop.crop_type ? this.cleanCustomCropName(crop.crop_type) : null;
        const cropName = cleanCropName ? cleanCropName.charAt(0).toUpperCase() + cleanCropName.slice(1) : null;
        
        if (cropName) details.push(`Crop: ${cropName}`);
        if (crop.count) details.push(`Plants: ${crop.count}`);
        if (crop.growth_stage) details.push(`Stage: ${crop.growth_stage}`);
        if (crop.health) details.push(`Health: ${crop.health}`);
        
        return details.join(' ‚Ä¢ ') || 'No details available';
    }

    generatePlantRecommendations(systemConfig, waterQuality, plantData) {
        const recommendations = [];
        
        // pH recommendations
        if (waterQuality?.ph) {
            if (waterQuality.ph < 6.0) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'pH Too Low',
                    content: 'Current pH is too acidic for most plants. Consider adding potassium hydroxide to raise pH to 6.0-7.0 range for optimal nutrient uptake.'
                });
            } else if (waterQuality.ph > 7.5) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'pH Too High',
                    content: 'Current pH is too alkaline. Consider adding phosphoric acid to lower pH to 6.0-7.0 range for better nutrient availability.'
                });
            } else {
                recommendations.push({
                    icon: '‚úÖ',
                    title: 'Optimal pH Range',
                    content: 'Your pH level is perfect for plant growth. Most nutrients are readily available at this range.'
                });
            }
        }
        
        // EC/TDS recommendations
        if (waterQuality?.ec) {
            if (waterQuality.ec < 400) {
                recommendations.push({
                    icon: 'üí°',
                    title: 'Low Nutrient Levels',
                    content: 'EC levels are low. Consider adding balanced hydroponic nutrients to support plant growth and development.'
                });
            } else if (waterQuality.ec > 1500) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'High Nutrient Concentration',
                    content: 'EC levels are high. Consider diluting with fresh water to prevent nutrient burn and salt buildup.'
                });
            }
        }
        
        // Temperature recommendations
        if (waterQuality?.temperature) {
            if (waterQuality.temperature < 15) {
                recommendations.push({
                    icon: 'üå°Ô∏è',
                    title: 'Cold Water Temperature',
                    content: 'Water temperature is low. Consider adding heating to improve nutrient uptake and growth rates.'
                });
            } else if (waterQuality.temperature > 30) {
                recommendations.push({
                    icon: 'üå°Ô∏è',
                    title: 'High Water Temperature',
                    content: 'Water temperature is high. Ensure adequate ventilation and consider cooling to prevent plant stress.'
                });
            }
        }
        
        // Plant-specific recommendations for aquaponics
        const activeCrops = [...new Set(plantData.map(item => item.crop_type).filter(Boolean))];
        if (activeCrops.length > 0) {
            recommendations.push({
                icon: 'üå±',
                title: 'Crop Diversity',
                content: `You're growing ${activeCrops.join(', ')}. Consider mixing leafy greens with fruiting plants to balance nutrient uptake and maximize space efficiency.`
            });
        }
        
        // Growth bed utilization
        const activeGrowBeds = this.getActiveGrowBeds(plantData);
        const totalGrowBeds = systemConfig?.grow_bed_count || 4;
        if (activeGrowBeds < totalGrowBeds) {
            recommendations.push({
                icon: 'üìà',
                title: 'Expand Production',
                content: `You have ${totalGrowBeds - activeGrowBeds} unused grow beds. Consider planting fast-growing crops like lettuce or herbs to maximize yield.`
            });
        }
        
        // Harvest timing
        const readyPlants = plantData.filter(item => 
            item.growth_stage?.toLowerCase().includes('ready') || 
            item.growth_stage?.toLowerCase().includes('mature')
        );
        if (readyPlants.length > 0) {
            recommendations.push({
                icon: 'ü•¨',
                title: 'Harvest Ready',
                content: `${readyPlants.length} plant entries show mature growth. Harvest soon for optimal quality and to make room for new plantings.`
            });
        }

        // Aquaponics-specific recommendations
        if (waterQuality?.dissolved_oxygen && waterQuality.dissolved_oxygen < 5.0) {
            recommendations.push({
                icon: 'üí®',
                title: 'Low Dissolved Oxygen',
                content: 'Low oxygen levels can stress both fish and plants. Increase aeration to improve root health and nutrient uptake.'
            });
        }

        // Iron deficiency recommendations
        if (waterQuality?.iron !== null && waterQuality?.iron !== undefined) {
            if (waterQuality.iron < 1.0) {
                recommendations.push({
                    icon: 'üî¥',
                    title: 'Iron Deficiency Risk',
                    content: 'Iron levels are low (< 1 ppm). Plants may develop yellowing between leaf veins (chlorosis). Consider adding chelated iron supplement to prevent deficiency.'
                });
            } else if (waterQuality.iron > 3.0) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'High Iron Levels',
                    content: 'Iron levels are high (> 3 ppm). Excessive iron can interfere with other nutrient uptake. Reduce iron supplementation and monitor plant health.'
                });
            } else {
                recommendations.push({
                    icon: '‚úÖ',
                    title: 'Optimal Iron Levels',
                    content: 'Iron levels are excellent (1-3 ppm). This supports healthy chlorophyll production and vibrant green growth.'
                });
            }
        }

        // Potassium recommendations
        if (waterQuality?.potassium !== null && waterQuality?.potassium !== undefined) {
            if (waterQuality.potassium < 40) {
                recommendations.push({
                    icon: 'üçå',
                    title: 'Low Potassium',
                    content: 'Potassium is low (< 40 ppm). This affects fruit development and plant immunity. Add potassium sulfate or increase fish feeding to boost levels.'
                });
            } else if (waterQuality.potassium > 70) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'High Potassium',
                    content: 'Potassium levels are high (> 70 ppm). While generally not toxic, monitor for potential salt buildup and ensure proper drainage.'
                });
            }
        }

        // Calcium recommendations
        if (waterQuality?.calcium !== null && waterQuality?.calcium !== undefined) {
            if (waterQuality.calcium < 50) {
                recommendations.push({
                    icon: 'ü¶¥',
                    title: 'Calcium Deficiency Risk',
                    content: 'Calcium is low (< 50 ppm). Plants may develop tip burn, blossom end rot, or weak stems. Add calcium chloride or crushed eggshells to boost levels.'
                });
            } else if (waterQuality.calcium > 100) {
                recommendations.push({
                    icon: '‚ö†Ô∏è',
                    title: 'High Calcium',
                    content: 'Calcium levels are high (> 100 ppm). This may interfere with magnesium and potassium uptake. Consider diluting with RO water.'
                });
            }
        }

        // Ca:K:Mg Ratio Analysis (Recommended 4:4:1)
        if (waterQuality?.calcium && waterQuality?.potassium && waterQuality?.magnesium) {
            const ca = waterQuality.calcium;
            const k = waterQuality.potassium;
            const mg = waterQuality.magnesium;
            
            // Calculate ratios relative to magnesium (normalize to Mg = 1)
            const caRatio = ca / mg;
            const kRatio = k / mg;
            const mgRatio = 1; // Always 1 as base
            
            // Check if ratios are close to ideal 4:4:1 (allow ¬±25% tolerance)
            const caIdeal = Math.abs(caRatio - 4) <= 1; // 3-5 range
            const kIdeal = Math.abs(kRatio - 4) <= 1; // 3-5 range
            
            if (caIdeal && kIdeal) {
                recommendations.push({
                    icon: '‚öñÔ∏è',
                    title: 'Excellent Ca:K:Mg Ratio',
                    content: `Perfect nutrient balance! Your Ca:K:Mg ratio is ${caRatio.toFixed(1)}:${kRatio.toFixed(1)}:1, very close to the ideal 4:4:1 ratio for optimal plant nutrition.`
                });
            } else {
                const issues = [];
                if (!caIdeal) {
                    if (caRatio < 3) issues.push(`Calcium too low (${caRatio.toFixed(1)} vs ideal 4)`);
                    else issues.push(`Calcium too high (${caRatio.toFixed(1)} vs ideal 4)`);
                }
                if (!kIdeal) {
                    if (kRatio < 3) issues.push(`Potassium too low (${kRatio.toFixed(1)} vs ideal 4)`);
                    else issues.push(`Potassium too high (${kRatio.toFixed(1)} vs ideal 4)`);
                }
                
                recommendations.push({
                    icon: 'üìä',
                    title: 'Ca:K:Mg Ratio Imbalance',
                    content: `Current ratio is ${caRatio.toFixed(1)}:${kRatio.toFixed(1)}:1 (ideal: 4:4:1). ${issues.join('. ')}. Balance these nutrients for optimal plant health.`
                });
            }
        }

        // N:K Ratio Analysis for Plant Types
        if (waterQuality?.nitrate && waterQuality?.potassium) {
            // Convert nitrate to nitrogen equivalent (NO3 to N conversion factor ~0.225)
            const nitrogen = waterQuality.nitrate * 0.225;
            const potassium = waterQuality.potassium;
            const nkRatio = nitrogen / potassium;
            
            // Determine plant types currently growing
            const activeCrops = [...new Set(plantData.map(item => item.crop_type).filter(Boolean))];
            const leafyGreens = ['lettuce', 'lettuce_batavian', 'lettuce_butter', 'lettuce_cos', 'lettuce_icty', 'lettuce_datem', 'lettuce_oak', 'spinach', 'kale', 'swiss_chard', 'arugula', 'watercress', 'basil', 'cilantro', 'parsley', 'celery'];
            const fruitingPlants = ['tomato', 'cucumber', 'pepper', 'strawberry', 'eggplant', 'okra', 'beans', 'peas'];
            
            const hasLeafyGreens = activeCrops.some(crop => leafyGreens.includes(crop.toLowerCase()));
            const hasFruitingPlants = activeCrops.some(crop => fruitingPlants.includes(crop.toLowerCase()));
            
            let idealRatioMin, idealRatioMax, plantTypeText;
            
            if (hasLeafyGreens && !hasFruitingPlants) {
                // Leafy greens: N:K ratio of 1:1 to 1:1.5
                idealRatioMin = 1.0;
                idealRatioMax = 1.5;
                plantTypeText = "leafy greens";
            } else if (hasFruitingPlants && !hasLeafyGreens) {
                // Fruiting plants: N:K ratio of 1:2 to 1:3
                idealRatioMin = 2.0;
                idealRatioMax = 3.0;
                plantTypeText = "fruiting plants";
            } else if (hasLeafyGreens && hasFruitingPlants) {
                // Mixed system: Use general aquaponics ratio
                idealRatioMin = 1.25;
                idealRatioMax = 2.0;
                plantTypeText = "mixed crops";
            } else {
                // No specific crops identified, use general aquaponics
                idealRatioMin = 1.25;
                idealRatioMax = 1.5;
                plantTypeText = "general aquaponics";
            }
            
            // Analyze the ratio (invert for N:K comparison since we calculate K/N)
            const kToNRatio = 1 / nkRatio;
            
            if (kToNRatio >= idealRatioMin && kToNRatio <= idealRatioMax) {
                recommendations.push({
                    icon: 'üéØ',
                    title: 'Excellent N:K Ratio',
                    content: `Perfect nutrient ratio for ${plantTypeText}! Your N:K ratio is 1:${kToNRatio.toFixed(1)} (ideal: 1:${idealRatioMin}-${idealRatioMax}). This balance supports optimal growth and development.`
                });
            } else if (kToNRatio < idealRatioMin) {
                recommendations.push({
                    icon: 'üìà',
                    title: 'N:K Ratio Imbalance - Low Potassium',
                    content: `Your N:K ratio is 1:${kToNRatio.toFixed(1)}, but ${plantTypeText} need 1:${idealRatioMin}-${idealRatioMax}. Increase potassium levels through fish feed adjustment or potassium supplements.`
                });
            } else {
                recommendations.push({
                    icon: 'üìâ',
                    title: 'N:K Ratio Imbalance - High Potassium',
                    content: `Your N:K ratio is 1:${kToNRatio.toFixed(1)}, but ${plantTypeText} need 1:${idealRatioMin}-${idealRatioMax}. Consider reducing potassium inputs or increasing nitrogen availability.`
                });
            }
        }

        // Nutrient balance recommendations
        if (waterQuality?.iron && waterQuality?.potassium && waterQuality?.calcium) {
            const ironOptimal = waterQuality.iron >= 1.0 && waterQuality.iron <= 3.0;
            const potassiumOptimal = waterQuality.potassium >= 40 && waterQuality.potassium <= 70;
            const calciumOptimal = waterQuality.calcium >= 50 && waterQuality.calcium <= 100;
            
            if (ironOptimal && potassiumOptimal && calciumOptimal) {
                recommendations.push({
                    icon: 'üéØ',
                    title: 'Perfect Nutrient Balance',
                    content: 'All measured nutrients (Iron, Potassium, Calcium) are in optimal ranges. Your plants should thrive with these levels!'
                });
            }
        }

        // Plant density recommendations
        const totalPlants = this.calculateTotalPlants(plantData);
        const totalGrowVolume = systemConfig?.total_grow_volume || 800;
        const plantDensity = totalPlants / (totalGrowVolume / 100); // plants per 100L
        
        if (plantDensity > 20) {
            recommendations.push({
                icon: 'üåø',
                title: 'High Plant Density',
                content: 'Plant density is high. Consider spacing plants further apart to prevent competition for nutrients and ensure proper air circulation.'
            });
        } else if (plantDensity > 0 && plantDensity < 5) {
            recommendations.push({
                icon: 'üìà',
                title: 'Low Plant Density',
                content: 'You have room for more plants. Consider adding more leafy greens to maximize nutrient uptake from your fish waste.'
            });
        }

        // System balance recommendation
        const fishData = this.getLatestFishHealthData();
        if (fishData?.count && totalPlants > 0) {
            const fishToPlantRatio = fishData.count / totalPlants;
            if (fishToPlantRatio > 0.5) {
                recommendations.push({
                    icon: '‚öñÔ∏è',
                    title: 'System Balance',
                    content: 'High fish-to-plant ratio detected. Consider adding more plants to better utilize the nutrients produced by your fish.'
                });
            }
        }
        
        return recommendations.length > 0 ? recommendations : [{
            icon: 'üåø',
            title: 'Welcome to Plant Management',
            content: 'Start recording plant growth data to receive personalized recommendations for your aquaponics system.'
        }];
    }

    /* Status indicators replaced with charts
    updateStatusIndicators(data) {
        const tempStatus = this.getStatusElement('water-temp');
        const phStatus = this.getStatusElement('ph-level');
        const oxygenStatus = this.getStatusElement('dissolved-oxygen');
        const ammoniaStatus = this.getStatusElement('ammonia');

        if (data.temperature) {
            tempStatus.textContent = this.getTemperatureStatus(data.temperature);
            tempStatus.className = `stat-status ${this.getTemperatureStatusClass(data.temperature)}`;
        } else {
            tempStatus.textContent = 'No data';
            tempStatus.className = 'stat-status';
        }

        if (data.ph) {
            phStatus.textContent = this.getPHStatus(data.ph);
            phStatus.className = `stat-status ${this.getPHStatusClass(data.ph)}`;
        } else {
            phStatus.textContent = 'No data';
            phStatus.className = 'stat-status';
        }

        if (data.dissolved_oxygen) {
            oxygenStatus.textContent = this.getOxygenStatus(data.dissolved_oxygen);
            oxygenStatus.className = `stat-status ${this.getOxygenStatusClass(data.dissolved_oxygen)}`;
        } else {
            oxygenStatus.textContent = 'No data';
            oxygenStatus.className = 'stat-status';
        }

        if (data.ammonia) {
            ammoniaStatus.textContent = this.getAmmoniaStatus(data.ammonia);
            ammoniaStatus.className = `stat-status ${this.getAmmoniaStatusClass(data.ammonia)}`;
        } else {
            ammoniaStatus.textContent = 'No data';
            ammoniaStatus.className = 'stat-status';
        }
    }
    */

    /* 
    setNoDataStatus() {
        const statusElements = [
            this.getStatusElement('water-temp'),
            this.getStatusElement('ph-level'),
            this.getStatusElement('dissolved-oxygen'),
            this.getStatusElement('ammonia')
        ];

        statusElements.forEach(element => {
            element.textContent = 'Enter data';
            element.className = 'stat-status';
        });
    }
    */

    getStatusElement(id) {
        return document.getElementById(id).parentElement.querySelector('.stat-status');
    }

    getTemperatureStatus(temp) {
        if (temp >= 22 && temp <= 26) return 'Optimal';
        if (temp >= 20 && temp <= 28) return 'Good';
        return 'Critical';
    }

    getTemperatureStatusClass(temp) {
        if (temp >= 22 && temp <= 26) return 'good';
        if (temp >= 20 && temp <= 28) return 'warning';
        return 'critical';
    }

    getPHStatus(ph) {
        if (ph >= 6.0 && ph <= 7.5) return 'Optimal';
        if (ph >= 5.5 && ph <= 8.0) return 'Good';
        return 'Critical';
    }

    getPHStatusClass(ph) {
        if (ph >= 6.0 && ph <= 7.5) return 'good';
        if (ph >= 5.5 && ph <= 8.0) return 'warning';
        return 'critical';
    }

    getOxygenStatus(oxygen) {
        if (oxygen >= 6) return 'Excellent';
        if (oxygen >= 4) return 'Good';
        return 'Low';
    }

    getOxygenStatusClass(oxygen) {
        if (oxygen >= 6) return 'good';
        if (oxygen >= 4) return 'warning';
        return 'critical';
    }

    getAmmoniaStatus(ammonia) {
        if (ammonia <= 0.25) return 'Safe';
        if (ammonia <= 0.5) return 'Monitor';
        return 'High';
    }

    getAmmoniaStatusClass(ammonia) {
        if (ammonia <= 0.25) return 'good';
        if (ammonia <= 0.5) return 'warning';
        return 'critical';
    }

    showAlert(title, message) {
        if (Notification.permission === 'granted') {
            new Notification(title, { body: message });
        } else {
            alert(`${title}: ${message}`);
        }
    }

    updateSettings() {
        const settings = {
            tempAlerts: document.getElementById('temp-alerts')?.checked || false,
            phAlerts: document.getElementById('ph-alerts')?.checked || false,
            autoFeed: document.getElementById('auto-feed')?.checked || false,
            autoLights: document.getElementById('auto-lights')?.checked || false
        };
        
        localStorage.setItem('aquaponicsSettings', JSON.stringify(settings));

    }

    loadSettings() {
        const savedSettings = localStorage.getItem('aquaponicsSettings');
        if (savedSettings) {
            const settings = JSON.parse(savedSettings);
            const tempAlertsCheckbox = document.getElementById('temp-alerts');
            const phAlertsCheckbox = document.getElementById('ph-alerts');
            const autoFeedCheckbox = document.getElementById('auto-feed');
            const autoLightsCheckbox = document.getElementById('auto-lights');
            
            if (tempAlertsCheckbox) tempAlertsCheckbox.checked = settings.tempAlerts ?? true;
            if (phAlertsCheckbox) phAlertsCheckbox.checked = settings.phAlerts ?? true;
            if (autoFeedCheckbox) autoFeedCheckbox.checked = settings.autoFeed ?? true;
            if (autoLightsCheckbox) autoLightsCheckbox.checked = settings.autoLights ?? true;
        }
    }

    initializeFishCalculator() {
        let fishCalculatorDiv = document.getElementById('fish-calc');
        if (!fishCalculatorDiv) {

            return;
        }
        
        const systemConfig = this.loadSystemConfig();
        const tankVolumeL = systemConfig.total_fish_volume || 1000;
        const tankVolumeM3 = (tankVolumeL / 1000).toFixed(1);
        
        // Add fish-calculator class for proper identification when moving between tabs
        fishCalculatorDiv.className = 'calculator-content active fish-calculator';
        
        fishCalculatorDiv.innerHTML = `
            <div class="fish-calc-header clean">
                <div class="calc-title-clean">
                    <div class="title-icon-clean">üêü</div>
                    <h2>Fish Stocking Calculator</h2>
                    <p>Design optimal stocking plans for your aquaponics system</p>
                </div>
                ${this.activeSystemId ? `
                    <div class="system-info-banner">
                        <div class="system-info-content">
                            <div class="system-badge">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                                </svg>
                                Active System
                            </div>
                            <div class="system-name">${systemConfig.system_name || 'Current System'}</div>
                            <div class="system-stats">
                                <span class="stat">
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                        <path d="M21 16V4H3v12h3v3l3-3h3l3 3v-3h3zm-10-8h2v2h-2V8zm-4 0h2v2H7V8zm8 0h2v2h-2V8z"/>
                                    </svg>
                                    ${tankVolumeL}L (${tankVolumeM3}m¬≥)
                                </span>
                                ${systemConfig.fish_type ? `
                                    <span class="stat">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>
                                        </svg>
                                        ${systemConfig.fish_type.charAt(0).toUpperCase() + systemConfig.fish_type.slice(1)}
                                    </span>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                ` : ''}
            </div>

            <div class="fish-calc-content clean">
                <div class="calc-section">
                    <div class="section-header clean">
                        <h3>üè† Tank Setup</h3>
                    </div>
                    <div class="form-row">
                        <label for="tank-volume">Tank Volume (m¬≥)</label>
                        <input type="number" id="tank-volume" step="0.1" placeholder="Enter volume" value="${tankVolumeM3}">
                    </div>
                    <div class="form-row">
                        <label for="fish-type">Fish Species</label>
                        <select id="fish-type">
                            <option value="">Choose species...</option>
                            <option value="tilapia">Tilapia - Hardy & Fast Growing</option>
                            <option value="trout">Trout - Cool Water Premium</option>
                            <option value="bass">Bass - Sport Fish</option>
                            <option value="catfish">Catfish - Very Resilient</option>
                            <option value="barramundi">Barramundi - Warm Water Premium</option>
                            <option value="carp">Carp - Extremely Hardy</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="stocking-density">Target Density (kg/m¬≥)</label>
                        <input type="number" id="stocking-density" min="1" step="1" placeholder="Enter density">
                        <div class="density-hint" id="density-indicator">Select species for recommendations</div>
                    </div>
                </div>

                <div class="calc-section">
                    <div class="section-header clean">
                        <h3><img src="/icons/new-icons/Afraponix Go Icons_growth.svg" alt="Growth" class="heading-icon" style="width: 1.5em; height: 1.5em; vertical-align: middle; margin-right: 0.5em;"> Growth & Harvest</h3>
                    </div>
                    
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="fingerling-weight">Starting Weight (g)</label>
                            <input type="number" id="fingerling-weight" step="0.1" placeholder="Fingerling weight">
                        </div>
                        <div class="form-row">
                            <label for="fish-harvest-weight">Harvest Weight (g)</label>
                            <input type="number" id="fish-harvest-weight" step="1" placeholder="Target weight">
                        </div>
                    </div>
                    
                    <div class="growth-preview" id="growth-timeline">
                        <div class="growth-stage">
                            <span class="stage-label">Start:</span>
                            <span class="stage-value" id="start-weight">--g</span>
                        </div>
                        <div class="growth-arrow">‚Üí</div>
                        <div class="growth-stage">
                            <span class="stage-label">Harvest:</span>
                            <span class="stage-value" id="fish-harvest-weight-display">--g</span>
                        </div>
                    </div>
                </div>

                <div class="calc-section">
                    <div class="section-header clean">
                        <h3>üçΩÔ∏è Feeding Schedule</h3>
                    </div>
                    <div class="form-row">
                        <label for="feedings-per-day">Daily Feedings</label>
                        <select id="feedings-per-day">
                            <option value="1">Once daily - Evening</option>
                            <option value="2" selected>Twice daily - Morning & Evening</option>
                            <option value="3">Three times - Morning, Noon & Evening</option>
                            <option value="4">Four times - Every 6 hours</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label for="feeding-times">Feeding Times</label>
                        <input type="text" id="feeding-times" placeholder="e.g. 08:00, 18:00" value="08:00, 18:00">
                        <div class="field-hint">Use 24-hour format separated by commas</div>
                    </div>
                    
                    <div class="schedule-preview" id="feeding-preview">
                        <div class="preview-label">Schedule Preview:</div>
                        <div class="schedule-display" id="schedule-timeline">
                            <!-- Dynamic feeding times will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="calc-buttons">
                <button class="calc-btn primary" id="calculate-stocking">
                    üìà Calculate Stocking Plan
                </button>
                <button class="calc-btn secondary" id="clear-fish-calc">
                    üóëÔ∏è Reset Form
                </button>
            </div>

            <div class="results-section" id="fish-results" style="display: none;">
                <div class="results-header">
                    <h3>üìà Stocking Analysis Results</h3>
                    <p>Based on your system specifications and fish requirements</p>
                </div>
                <div id="stocking-summary" class="results-grid"></div>
                <div id="growth-chart-container" class="chart-container"></div>
                <div id="feeding-schedule" class="schedule-container"></div>
                <div id="feeding-recommendations" class="recommendations-container"></div>
            </div>
        `;

        this.bindFishCalculatorEvents();
        
        // Prepopulate system info display and fish type
        this.updateFishCalculatorSystemInfo();
        
        // Auto-select fish type from system configuration
        if (systemConfig.fish_type && systemConfig.system_name !== 'No System Selected') {
            document.getElementById('fish-type').value = systemConfig.fish_type;
            this.updateFishDefaults();
        }
    }
    
    bindFishCalculatorEvents() {
        // Set up event listeners for fish calculator
        const fishTypeElement = document.getElementById('fish-type');
        const calculateButton = document.getElementById('calculate-stocking');
        const clearButton = document.getElementById('clear-fish-calc');
        const fingerlingWeightElement = document.getElementById('fingerling-weight');
        const harvestWeightElement = document.getElementById('fish-harvest-weight');
        const feedingsPerDayElement = document.getElementById('feedings-per-day');
        const feedingTimesElement = document.getElementById('feeding-times');
        
        if (fishTypeElement) {
            fishTypeElement.addEventListener('change', this.updateFishDefaults.bind(this));
        }
        if (calculateButton) {
            calculateButton.addEventListener('click', this.calculateStocking.bind(this));
        }
        if (clearButton) {
            clearButton.addEventListener('click', this.clearFishCalculator.bind(this));
        }
        
        // Add real-time preview updates
        if (fingerlingWeightElement) {
            fingerlingWeightElement.addEventListener('input', this.updateGrowthTimeline.bind(this));
        }
        if (harvestWeightElement) {
            harvestWeightElement.addEventListener('input', this.updateGrowthTimeline.bind(this));
        }
        if (feedingsPerDayElement) {
            feedingsPerDayElement.addEventListener('change', this.updateFeedingPreview.bind(this));
        }
        if (feedingTimesElement) {
            feedingTimesElement.addEventListener('input', this.updateFeedingPreview.bind(this));
        }
        
        // Initialize previews
        setTimeout(() => {
            this.updateFeedingPreview();
            this.updateGrowthTimeline();
        }, 100);
    }

    updateFishCalculatorSystemInfo() {
        const systemConfig = this.loadSystemConfig();
        
        // Fish calculator system info is now handled directly in the calculator initialization
        // since the calculator remains in its original Calculators tab location

        // System info is now displayed in the calculator header itself
    }

    updateFishDefaults() {
        const fishType = document.getElementById('fish-type').value;
        if (fishType && this.fishData[fishType]) {
            const fish = this.fishData[fishType];
            document.getElementById('stocking-density').value = fish.defaultDensity;
            document.getElementById('fingerling-weight').value = fish.defaultFingerlingWeight;
            document.getElementById('fish-harvest-weight').value = fish.harvestWeight;
            
            // Update density indicator
            this.updateDensityIndicator(fish);
            
            // Update growth timeline
            this.updateGrowthTimeline();
        }
    }
    
    updateDensityIndicator(fish) {
        const indicator = document.getElementById('density-indicator');
        if (indicator && fish) {
            const temp = fish.temperature || 'Varies';
            const densityText = `${fish.name}: Optimal density ${fish.defaultDensity} kg/m¬≥ at ${temp}`;
            indicator.innerHTML = `<span class="indicator-text">${densityText}</span>`;
        }
    }
    
    updateGrowthTimeline() {
        const fingerlingWeight = document.getElementById('fingerling-weight').value;
        const harvestWeight = document.getElementById('fish-harvest-weight').value;
        
        const startWeightElement = document.getElementById('start-weight');
        const harvestWeightElement = document.getElementById('fish-harvest-weight-display');
        
        if (startWeightElement && fingerlingWeight) {
            startWeightElement.textContent = fingerlingWeight + 'g';
        }
        if (harvestWeightElement && harvestWeight) {
            harvestWeightElement.textContent = harvestWeight + 'g';
        }
    }
    
    updateFeedingPreview() {
        const feedingsPerDay = document.getElementById('feedings-per-day').value;
        const feedingTimes = document.getElementById('feeding-times').value;
        const timeline = document.getElementById('schedule-timeline');
        
        if (!timeline) return;
        
        if (feedingTimes && feedingTimes.trim()) {
            const times = feedingTimes.split(',').map(time => time.trim());
            timeline.innerHTML = times.map(time => 
                `<div class="schedule-time">${time}</div>`
            ).join('');
        } else {
            // Generate default times based on frequency
            const defaultTimes = this.generateDefaultFeedingTimes(parseInt(feedingsPerDay));
            timeline.innerHTML = defaultTimes.map(time => 
                `<div class="schedule-time">${time}</div>`
            ).join('');
        }
    }
    
    generateDefaultFeedingTimes(frequency) {
        const times = [];
        switch(frequency) {
            case 1:
                times.push('18:00');
                break;
            case 2:
                times.push('08:00', '18:00');
                break;
            case 3:
                times.push('08:00', '14:00', '20:00');
                break;
            case 4:
                times.push('08:00', '12:00', '16:00', '20:00');
                break;
            default:
                times.push('08:00', '18:00');
        }
        return times;
    }

    calculateStocking() {
        const tankVolume = parseFloat(document.getElementById('tank-volume').value);
        const fishType = document.getElementById('fish-type').value;
        const stockingDensity = parseFloat(document.getElementById('stocking-density').value);
        const fingerlingWeight = parseFloat(document.getElementById('fingerling-weight').value);
        const harvestWeight = parseFloat(document.getElementById('fish-harvest-weight').value);
        const feedingsPerDay = parseInt(document.getElementById('feedings-per-day').value);
        const feedingTimes = document.getElementById('feeding-times').value;

        if (!tankVolume || !fishType || !stockingDensity || !fingerlingWeight || !harvestWeight) {
            this.showNotification('üìù Please fill in all fields.', 'warning');
            return;
        }

        const fish = this.fishData[fishType];
        const harvestWeightKg = harvestWeight / 1000;
        const numberOfFish = Math.floor((tankVolume * stockingDensity) / harvestWeightKg);
        const initialBiomass = (numberOfFish * fingerlingWeight) / 1000;
        const harvestBiomass = (numberOfFish * harvestWeight) / 1000;
        const totalFeedRequired = harvestBiomass * fish.feedConversionRatio;

        // Save feeding schedule to system
        this.saveFeedingSchedule(fishType, feedingsPerDay, feedingTimes);

        this.displayStockingResults(fish, tankVolume, numberOfFish, initialBiomass, harvestBiomass, totalFeedRequired, harvestWeight);
        this.displayFeedingSchedule(fish, numberOfFish, feedingsPerDay, feedingTimes);
        document.getElementById('fish-results').style.display = 'block';
    }

    displayStockingResults(fish, tankVolume, numberOfFish, initialBiomass, harvestBiomass, totalFeedRequired, harvestWeight) {
        const summaryDiv = document.getElementById('stocking-summary');
        summaryDiv.innerHTML = `
            <div class="summary-card">
                <h4>${fish.icon} ${fish.name} Stocking Plan</h4>
                <div class="stats-row">
                    <div class="stat-item">
                        <strong>Tank Volume:</strong> ${tankVolume} m¬≥
                    </div>
                    <div class="stat-item">
                        <strong>Number of Fish:</strong> ${numberOfFish.toLocaleString()} fingerlings
                    </div>
                    <div class="stat-item">
                        <strong>Initial Biomass:</strong> ${initialBiomass.toFixed(1)} kg
                    </div>
                    <div class="stat-item">
                        <strong>Final Harvest Biomass:</strong> ${harvestBiomass.toFixed(1)} kg
                    </div>
                    <div class="stat-item">
                        <strong>Growth Period:</strong> ${fish.growthPeriod} weeks
                    </div>
                    <div class="stat-item">
                        <strong>Total Feed Required:</strong> ${totalFeedRequired.toFixed(1)} kg
                    </div>
                </div>
            </div>
        `;

        // Display growth chart
        this.displayGrowthChart(fish, numberOfFish, harvestWeight);
    }

    displayGrowthChart(fish, numberOfFish, harvestWeight) {
        const chartDiv = document.getElementById('growth-chart-container');
        if (!chartDiv) {
            if (window.errorManager) {
                window.errorManager.warnOnce('missing_chart_container', 'Chart container growth-chart-container not found in DOM', this.activeSystemId);
            } else {
                console.warn('Chart container growth-chart-container not found in DOM');
            }
            return;
        }
        let chartHTML = `
            <h4>Growth Chart & Feeding Schedule</h4>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>Week</th>
                        <th>Avg Weight (g)</th>
                        <th>Total Biomass (kg)</th>
                        <th>Feed Rate (%)</th>
                        <th>Daily Feed/Fish (g)</th>
                        <th>Total Daily Feed (kg)</th>
                    </tr>
                </thead>
                <tbody>
        `;

        const growthFactor = harvestWeight / fish.harvestWeight;
        fish.growthData.forEach(data => {
            const adjustedWeight = Math.round(data.weight * growthFactor);
            const totalBiomass = (numberOfFish * adjustedWeight) / 1000;
            const adjustedFeedAmount = Math.round(data.feedAmount * growthFactor);
            const totalDailyFeed = (numberOfFish * adjustedFeedAmount) / 1000;

            chartHTML += `
                <tr>
                    <td>${data.week}</td>
                    <td>${adjustedWeight}g</td>
                    <td>${totalBiomass.toFixed(1)} kg</td>
                    <td>${data.feedRate}%</td>
                    <td>${adjustedFeedAmount}g</td>
                    <td>${totalDailyFeed.toFixed(2)} kg</td>
                </tr>
            `;
        });

        chartHTML += `
                </tbody>
            </table>
        `;

        chartDiv.innerHTML = chartHTML;
    }

    clearFishCalculator() {
        const systemConfig = this.loadSystemConfig();
        const tankVolumeM3 = systemConfig.total_fish_volume ? (systemConfig.total_fish_volume / 1000).toFixed(1) : '';
        
        document.getElementById('tank-volume').value = tankVolumeM3;
        
        // Reset to system's fish type if available
        if (systemConfig.fish_type && systemConfig.system_name !== 'No System Selected') {
            document.getElementById('fish-type').value = systemConfig.fish_type;
            this.updateFishDefaults();
        } else {
            document.getElementById('fish-type').value = '';
            document.getElementById('stocking-density').value = '';
            document.getElementById('fingerling-weight').value = '';
            document.getElementById('fish-harvest-weight').value = '';
        }
        
        document.getElementById('fish-results').style.display = 'none';
        this.updateFishCalculatorSystemInfo();
    }

    async saveFeedingSchedule(fishType, feedingsPerDay, feedingTimes) {
        if (!this.activeSystemId) return;

        try {
            await this.makeApiCall('/fish/feeding-schedule', {
                method: 'POST',
                body: JSON.stringify({
                    systemId: this.activeSystemId,
                    fishType,
                    feedingsPerDay,
                    feedingTimes
                })
            });
        } catch (error) {
            console.error('Error saving feeding schedule:', error);
        }
    }

    displayFeedingSchedule(fish, numberOfFish, feedingsPerDay, feedingTimes) {
        const scheduleDiv = document.getElementById('feeding-schedule');
        const times = feedingTimes.split(',').map(time => time.trim());

        // Calculate feeding amounts based on current week's data
        const currentWeekData = fish.growthData[fish.growthData.length - 1]; // Use final week as current
        const dailyFeedPerFish = currentWeekData.feedAmount;
        const totalDailyFeed = (numberOfFish * dailyFeedPerFish) / 1000; // Convert to kg
        const feedPerMeal = (totalDailyFeed / feedingsPerDay).toFixed(3);
        const feedPerFishPerMeal = (dailyFeedPerFish / feedingsPerDay).toFixed(1);

        let scheduleHTML = `
            <div class="feeding-schedule-card">
                <h4>üêü Daily Feeding Schedule</h4>
                <div class="feeding-summary">
                    <div class="feeding-stat">
                        <strong>Feedings per Day:</strong> ${feedingsPerDay}
                    </div>
                    <div class="feeding-stat">
                        <strong>Total Daily Feed:</strong> ${totalDailyFeed.toFixed(2)} kg
                    </div>
                    <div class="feeding-stat">
                        <strong>Feed per Meal:</strong> ${feedPerMeal} kg
                    </div>
                    <div class="feeding-stat">
                        <strong>Feed per Fish per Meal:</strong> ${feedPerFishPerMeal}g
                    </div>
                </div>
                
                <div class="feeding-times">
                    <h5>üìÖ Feeding Times</h5>
                    <div class="feeding-schedule-grid">
        `;

        times.forEach((time, index) => {
            if (time) {
                scheduleHTML += `
                    <div class="feeding-time-slot">
                        <div class="feeding-time">${time}</div>
                        <div class="feeding-amount">${feedPerMeal} kg</div>
                        <div class="feeding-notes">Meal ${index + 1}</div>
                    </div>
                `;
            }
        });

        scheduleHTML += `
                    </div>
                </div>
                
                <div class="feeding-tips">
                    <h5>üí° Feeding Tips</h5>
                    <ul>
                        <li>Feed only what fish can consume in 5-10 minutes</li>
                        <li>Remove uneaten food after 15 minutes to prevent water quality issues</li>
                        <li>Monitor fish behavior - healthy fish should be actively feeding</li>
                        <li>Adjust amounts based on water temperature and fish activity</li>
                        <li>Consider reducing feed by 50% if water temperature drops below ${fish.temperature.split('-')[0]}¬∞C</li>
                    </ul>
                </div>
            </div>
        `;

        scheduleDiv.innerHTML = scheduleHTML;
    }

    async initializeDataEntryForms() {
        return this.dataEntry.initializeDataEntryForms();
    }

    // ========================================
    // COMPREHENSIVE TAB HANDLERS INITIALIZATION
    // ========================================
    async initializeAllTabHandlers() {
        console.log("üöÄ Initializing all tab handlers...");
        try {
            this.setupDashboardTabs(); // Dashboard
            this.setupPlantActionTabs(); // Plant Management Action Tabs
            this.setupFishManagementTabs(); // Fish Management (with auto-load fix)
            this.setupSensorTabs(); // Sensor Configuration
            this.setupDataEditTabs(); // Data Editing
            this.setupNutrientManagementTabs(); // Nutrient Management
            this.setupCalculatorTabs(); // Calculator
            this.setupSettingsTabs(); // Settings (already comprehensive)
            console.log("‚úÖ All tab handlers initialized successfully");
        } catch (error) {
            console.error("‚ùå Error initializing tab handlers:", error);
        }
    }

    async loadLatestDataForPreloading() {
        if (!this.activeSystemId) return;
        
        try {
            this.latestData = await this.makeApiCall(`/data/latest/${this.activeSystemId}`);
        } catch (error) {
            console.error('Error loading latest data for preloading:', error);
            this.latestData = {};
        }
    }

    initializeWaterQualityForm() {
        const formDiv = document.querySelector('#water-quality-form .data-entry-section');
        formDiv.innerHTML = `
            <div class="form-section">
                <h3>Water Quality Parameters</h3>
                <div class="form-grid">
                    <div class="form-field">
                        <label for="wq-date">Date & Time:</label>
                        <input type="datetime-local" id="wq-date" value="${new Date().toISOString().slice(0, 16)}">
                    </div>
                    <div class="form-field">
                        <label for="wq-ph">pH Level:</label>
                        <input type="number" id="wq-ph" min="0" max="14" step="0.1" placeholder="6.0 - 8.5">
                    </div>
                    <div class="form-field">
                        <label for="wq-ec">EC/TDS (ppm):</label>
                        <input type="number" id="wq-ec" min="0" step="10" placeholder="400 - 1200">
                    </div>
                    <div class="form-field">
                        <label for="wq-do">Dissolved Oxygen (mg/L):</label>
                        <input type="number" id="wq-do" min="0" step="0.1" placeholder="5.0 - 8.0">
                    </div>
                    <div class="form-field">
                        <label for="wq-temp">Water Temperature (¬∞C):</label>
                        <input type="number" id="wq-temp" min="0" step="0.1" placeholder="18 - 30">
                    </div>
                    <div class="form-field">
                        <label for="wq-humidity">Humidity (%):</label>
                        <input type="number" id="wq-humidity" min="0" max="100" step="1" placeholder="40 - 80">
                    </div>
                    <div class="form-field">
                        <label for="wq-salinity">Salinity (ppt):</label>
                        <input type="number" id="wq-salinity" min="0" step="0.1" placeholder="0 - 1.0">
                    </div>
                    <div class="form-field">
                        <label for="wq-ammonia">Ammonia NH‚ÇÉ (ppm):</label>
                        <input type="number" id="wq-ammonia" min="0" step="0.01" placeholder="< 0.5">
                    </div>
                    <div class="form-field">
                        <label for="wq-nitrite">Nitrite NO‚ÇÇ (ppm):</label>
                        <input type="number" id="wq-nitrite" min="0" step="0.01" placeholder="< 0.5">
                    </div>
                    <div class="form-field">
                        <label for="wq-nitrate">Nitrate NO‚ÇÉ (ppm):</label>
                        <input type="number" id="wq-nitrate" min="0" step="1" placeholder="10 - 150">
                    </div>
                    <div class="form-field">
                        <label for="wq-iron">Iron Fe (ppm):</label>
                        <input type="number" id="wq-iron" min="0" step="0.1" placeholder="1 - 3">
                    </div>
                    <div class="form-field">
                        <label for="wq-potassium">Potassium K (ppm):</label>
                        <input type="number" id="wq-potassium" min="0" step="1" placeholder="40 - 70">
                    </div>
                    <div class="form-field">
                        <label for="wq-calcium">Calcium Ca (ppm):</label>
                        <input type="number" id="wq-calcium" min="0" step="1" placeholder="50 - 100">
                    </div>
                    <!-- Nitrate input field already exists above -->
                    <div class="form-field">
                        <label for="wq-phosphorus">Phosphorus P (ppm):</label>
                        <input type="number" id="wq-phosphorus" min="0" step="0.1" placeholder="5 - 20">
                    </div>
                    <div class="form-field">
                        <label for="wq-magnesium">Magnesium Mg (ppm):</label>
                        <input type="number" id="wq-magnesium" min="0" step="0.1" placeholder="12 - 18">
                    </div>
                </div>
                <div class="form-field">
                    <label for="wq-notes">Notes:</label>
                    <textarea id="wq-notes" placeholder="Additional observations..."></textarea>
                </div>
                <button class="form-btn" onclick="app.saveWaterQualityData()">Save Water Quality Data</button>
            </div>
        `;
        
        // Preload data from latest entry
        this.preloadWaterQualityData();
    }

    initializeFishHealthForm() {
        const formDiv = document.querySelector('#fish-health-form .data-entry-section');
        const systemConfig = this.loadSystemConfig();
        
        // Generate tank options based on system configuration
        let tankOptions = '';
        if (systemConfig && systemConfig.system_name !== 'No System Selected') {
            for (let i = 1; i <= (systemConfig.fish_tank_count || 1); i++) {
                tankOptions += `<option value="${i}">Tank ${i}</option>`;
            }
        } else {
            tankOptions = '<option value="1">Tank 1</option>';
        }
        
        formDiv.innerHTML = `
            <div class="form-section">
                <h3>Fish Health Metrics</h3>
                <div class="form-grid">
                    <div class="form-field">
                        <label for="fh-date">Date & Time:</label>
                        <input type="datetime-local" id="fh-date" value="${new Date().toISOString().slice(0, 16)}">
                    </div>
                    <div class="form-field">
                        <label for="fh-tank">Select Fish Tank:</label>
                        <select id="fh-tank" required>
                            ${tankOptions}
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="fh-count">Current Fish Count:</label>
                        <input type="number" id="fh-count" min="0" step="1" placeholder="Current live fish count (leave blank if only recording mortality)">
                    </div>
                    <div class="form-field">
                        <label for="fh-mortality">Mortality Count:</label>
                        <input type="number" id="fh-mortality" min="0" step="1" placeholder="Fish deaths since last check (will be subtracted automatically)">
                    </div>
                    <div class="form-field">
                        <label for="fh-weight">Average Fish Weight (g):</label>
                        <input type="number" id="fh-weight" min="0" step="1" placeholder="Sample weight">
                    </div>
                    <div class="form-field">
                        <label for="fh-feed">Feed Consumption/Day (kg):</label>
                        <input type="number" id="fh-feed" min="0" step="0.1" placeholder="Daily feed amount">
                    </div>
                    <div class="form-field">
                        <label for="fh-behavior">Fish Behavior:</label>
                        <select id="fh-behavior">
                            <option value="normal">Normal - Active feeding</option>
                            <option value="sluggish">Sluggish - Slow movement</option>
                            <option value="stressed">Stressed - Erratic swimming</option>
                            <option value="diseased">Signs of disease</option>
                        </select>
                    </div>
                </div>
                <div class="form-field">
                    <label for="fh-notes">Health Observations:</label>
                    <textarea id="fh-notes" placeholder="Disease symptoms, unusual behavior, etc..."></textarea>
                </div>
                <button class="form-btn" onclick="app.saveFishHealthData()">Save Fish Health Data</button>
            </div>
        `;
        
        // Preload data from latest entry
        this.preloadFishHealthData();
    }

    async getGrowBedsForSystem() {
        const systemConfig = this.loadSystemConfig();
        
        if (!systemConfig || systemConfig.system_name === 'No System Selected' || !systemConfig.id) {
            // Fallback to default grow beds
            return Array.from({length: 4}, (_, i) => ({
                id: i + 1,
                bed_number: i + 1,
                bed_type: 'media-bed',
                plant_capacity: 20
            }));
        }

        try {
            const response = await fetch(`/api/grow-beds/system/${systemConfig.id}`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                }
            });

            if (response.ok) {
                const growBeds = await response.json();
                return growBeds.length > 0 ? growBeds : [
                    // Default fallback if no grow beds configured
                    ...Array.from({length: systemConfig.grow_bed_count || 4}, (_, i) => ({
                        id: i + 1,
                        bed_number: i + 1,
                        bed_type: 'media-bed',
                        plant_capacity: 20
                    }))
                ];
            } else {
                console.error('Failed to fetch grow beds:', response.statusText);
                // Fallback to system config
                return Array.from({length: systemConfig.grow_bed_count || 4}, (_, i) => ({
                    id: i + 1,
                    bed_number: i + 1,
                    bed_type: 'media-bed',
                    plant_capacity: 20
                }));
            }
        } catch (error) {
            console.error('Error fetching grow beds:', error);
            // Fallback to system config
            return Array.from({length: systemConfig.grow_bed_count || 4}, (_, i) => ({
                id: i + 1,
                bed_number: i + 1,
                bed_type: 'media-bed',
                plant_capacity: 20
            }));
        }
    }

    initializeOperationsForm() {
        const formDiv = document.querySelector('#operations-form .data-entry-section');
        formDiv.innerHTML = `
            <div class="form-section">
                <h3>System Operations</h3>
                <div class="form-grid">
                    <div class="form-field">
                        <label for="ops-date">Date & Time:</label>
                        <input type="datetime-local" id="ops-date" value="${new Date().toISOString().slice(0, 16)}">
                    </div>
                    <div class="form-field">
                        <label for="ops-type">Operation Type:</label>
                        <select id="ops-type">
                            <option value="water-change">Water Change</option>
                            <option value="maintenance">Equipment Maintenance</option>
                            <option value="chemical-addition">Chemical Addition</option>
                            <option value="system-failure">System Failure</option>
                            <option value="cleaning">System Cleaning</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="ops-volume">Water Volume Changed (L):</label>
                        <input type="number" id="ops-volume" min="0" step="1" placeholder="If water change">
                    </div>
                    <div class="form-field">
                        <label for="ops-chemical">Chemical Added:</label>
                        <input type="text" id="ops-chemical" placeholder="pH adjuster, nutrients, etc.">
                    </div>
                    <div class="form-field">
                        <label for="ops-amount">Amount Added:</label>
                        <input type="text" id="ops-amount" placeholder="Quantity and units">
                    </div>
                    <div class="form-field">
                        <label for="ops-duration">Downtime Duration (hours):</label>
                        <input type="number" id="ops-duration" min="0" step="0.1" placeholder="If system was down">
                    </div>
                </div>
                <div class="form-field">
                    <label for="ops-notes">Operation Details:</label>
                    <textarea id="ops-notes" placeholder="Detailed description of the operation..."></textarea>
                </div>
                <button class="form-btn" onclick="app.saveOperationsData()">Save Operations Data</button>
            </div>
        `;
    }

    async loadDataRecords() {
        return this.dataProcessor.loadAllData(this.activeSystemId);
    }

    async getPreviousFishCount(tankId) {
        try {
            // Get all fish health data for this system
            const response = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}&limit=50`);
            const entries = response || [];
            
            // Find the most recent entry for this tank
            const tankEntries = entries.filter(entry => entry.fish_tank_id === tankId);
            if (tankEntries.length > 0) {
                return tankEntries[0]; // Most recent entry
            }
            return null;
        } catch (error) {
            console.error('Failed to get previous fish count:', error);
            return null;
        }
    }

    async saveWaterQualityData() {
        try {
            const result = await this.dataEntry.saveWaterQualityData();
            if (result) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
            return result;
        } catch (error) {
            console.error('Failed to save water quality data:', error);
            this.showNotification('‚ùå Failed to save water quality data. Please try again.', 'error');
            return false;
        }
    }

    async saveFishHealthData() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }

        const tankId = parseInt(document.getElementById('fh-tank').value);
        const enteredCount = parseInt(document.getElementById('fh-count').value) || 0;
        const mortality = parseInt(document.getElementById('fh-mortality').value) || 0;
        
        // Get the previous fish count for this tank to handle mortality correctly
        let finalCount = enteredCount;
        
        // If mortality is entered but no count is entered, get previous count and subtract mortality
        if (mortality > 0 && enteredCount === 0) {
            const previousData = await this.getPreviousFishCount(tankId);
            const previousCount = previousData ? previousData.count || 0 : 0;
            finalCount = Math.max(0, previousCount - mortality);

        }
        // If both count and mortality are entered, subtract mortality from entered count
        else if (mortality > 0 && enteredCount > 0) {
            finalCount = Math.max(0, enteredCount - mortality);

        }

        const data = {
            date: document.getElementById('fh-date').value,
            fish_tank_id: tankId,
            count: finalCount, // Use the adjusted count after subtracting mortality
            mortality: mortality,
            average_weight: parseFloat(document.getElementById('fh-weight').value),
            feed_consumption: parseFloat(document.getElementById('fh-feed').value),
            behavior: document.getElementById('fh-behavior').value,
            notes: document.getElementById('fh-notes').value
        };

        try {
            await this.performSaveWithProgress('fish', async () => {
                // API call
                await this.makeApiCall(`/data/entries/fish-health`, {
                    method: 'POST',
                    body: JSON.stringify({
                        system_id: this.activeSystemId,
                        fish_tank_id: data.fish_tank_id,
                        date: data.date,
                        count: data.count,
                        mortality: data.mortality,
                        average_weight: data.average_weight,
                        feed_consumption: data.feed_consumption,
                        behavior: data.behavior,
                        notes: data.notes
                    })
                });
                
                await this.loadDataRecords();
                await this.updateFishTankSummary();
                
                return { success: true, data };
            });
            
            // Success actions after modal closes
            this.showNotification('Fish health data saved successfully!', 'success');
            this.clearForm('fish-health');
        } catch (error) {
            console.error('Failed to save fish health data:', error);
            this.showNotification('‚ùå Failed to save fish health data. Please try again.', 'error');
        }
    }

    async savePlantGrowthData() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }

        const data = {
            date: document.getElementById('pg-date').value,
            crop_type: document.getElementById('pg-crop').value,
            count: parseInt(document.getElementById('pg-count').value),
            harvest_weight: parseFloat(document.getElementById('pg-harvest-weight').value),
            plants_harvested: parseInt(document.getElementById('pg-plants-harvested').value) || null,
            new_seedlings: parseInt(document.getElementById('pg-new-seedlings').value) || null,
            pest_control: document.getElementById('pg-pest-control').value,
            health: document.getElementById('pg-health').value,
            growth_stage: document.getElementById('pg-stage').value,
            notes: document.getElementById('pg-notes').value
        };

        try {
            await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(data)
            });
            
            await this.loadDataRecords();
            this.showNotification('Plant growth data saved successfully!', 'success');
            this.clearForm('plant-growth');
        } catch (error) {
            console.error('Failed to save plant growth data:', error);
            this.showNotification('‚ùå Failed to save plant growth data. Please try again.', 'error');
        }
    }

    async saveOperationsData() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }

        const data = {
            date: document.getElementById('ops-date').value,
            operation_type: document.getElementById('ops-type').value,
            water_volume: parseFloat(document.getElementById('ops-volume').value),
            chemical_added: document.getElementById('ops-chemical').value,
            amount_added: document.getElementById('ops-amount').value,
            downtime_duration: parseFloat(document.getElementById('ops-duration').value),
            notes: document.getElementById('ops-notes').value
        };

        try {
            await this.makeApiCall(`/data/operations/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify(data)
            });
            
            await this.loadDataRecords();
            this.showNotification('‚öôÔ∏è Operations data saved successfully!', 'success');
            this.clearForm('operations');
        } catch (error) {
            console.error('Failed to save operations data:', error);
            this.showNotification('‚ùå Failed to save operations data. Please try again.', 'error');
        }
    }

    clearForm(formType) {
        const formElements = document.querySelectorAll(`#${formType}-form input, #${formType}-form select, #${formType}-form textarea`);
        formElements.forEach(element => {
            if (element.type === 'datetime-local') {
                element.value = new Date().toISOString().slice(0, 16);
            } else if (element.id === 'fh-tank') {
                // Reset fish tank selector to first tank
                element.selectedIndex = 0;
            } else {
                element.value = '';
            }
        });
    }

    clearAllForms() {
        // Clear all data entry forms
        const formTypes = ['water-quality', 'fish-health', 'plant-growth', 'operations'];
        formTypes.forEach(formType => {
            this.clearForm(formType);
        });
        
        // Clear any other open forms or modals
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            if (modal.classList.contains('show')) {
                modal.classList.remove('show');
            }
        });
    }

    // These methods are now handled by API calls in loadUserData()

    getActiveSystem() {
        return this.activeSystemId ? this.systems[this.activeSystemId] : null;
    }

    setupSystemSelector() {
        const systemSelect = document.getElementById('active-system');
        const addSystemBtn = document.getElementById('add-system-btn');

        // Don't populate dropdown here - wait until after authentication
        // this.updateSystemSelector(); // REMOVED: This was causing systems to load before auth

        // Add event listeners
        systemSelect.addEventListener('change', (e) => {
            this.switchToSystem(e.target.value);
        });

        addSystemBtn.addEventListener('click', () => {
            this.showAddSystemDialog();
        });
    }

    updateSystemSelector() {
        if (this.systemManager && this.systemManager.updateSystemSelector) {
            console.log('üîÑ Calling SystemManager.updateSystemSelector with systems:', Object.keys(this.systems || {}));
            return this.systemManager.updateSystemSelector();
        } else {
            console.warn('SystemManager or updateSystemSelector method not available', {
                systemManager: !!this.systemManager,
                hasMethod: !!(this.systemManager?.updateSystemSelector),
                systemsCount: Object.keys(this.systems || {}).length
            });
        }
    }

    async switchToSystem(systemId) {
        return this.systemManager.switchToSystem(systemId);
    }

    showAddSystemDialog() {
        // Show the new system modal instead of a prompt
        const modal = document.getElementById('new-system-modal');

        modal.classList.add('show');

        // Reset wizard to step 1
        this.currentSystemStep = 1;
        this.systemWizardData = {
            fishTanks: [],
            growBeds: [],
            allocations: {}
        };
        
        // Reset form to default values
        document.getElementById('new-system-name').value = '';
        document.getElementById('new-system-type').value = '';
        document.getElementById('new-fish-tank-count').value = '1';
        document.getElementById('new-grow-bed-count').value = '2';
        
        // Initialize with default tank and bed configurations
        this.updateFishTankFields(1);
        this.updateGrowBedFields(2);
        
        // Focus on the system name input and update UI after modal is shown
        setTimeout(() => {
            // Update wizard UI after modal is visible
            this.updateWizardUI();
            document.getElementById('new-system-name').focus();
        }, 100);
    }
    
    closeNewSystemModal() {
        const modal = document.getElementById('new-system-modal');
        modal.classList.remove('show');
    }
    
    // =====================================================
    // COMPREHENSIVE NUTRIENT INFORMATION MODAL
    // =====================================================
    
    async showComprehensiveNutrientInfo(nutrientCode) {
        const modal = document.getElementById('comprehensive-nutrient-modal');
        const loadingDiv = document.getElementById('nutrient-modal-loading');
        const errorDiv = document.getElementById('nutrient-modal-error');
        const contentDiv = document.getElementById('nutrient-modal-content');
        
        try {
            // Show modal with loading state
            modal.style.display = 'flex';
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            contentDiv.style.display = 'none';
            
            // Get current system ID for context
            const systemId = this.activeSystemId;
            
            // Fetch comprehensive nutrient data
            const result = await CropKnowledgeAPI.fetchNutrientDetails(nutrientCode, systemId);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to fetch nutrient information');
            }
            
            const nutrientData = result.data;
            
            // Hide loading, show content
            loadingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            
            // Populate modal with nutrient data
            this.populateNutrientModal(nutrientData);
            
        } catch (error) {
            console.error('Error loading comprehensive nutrient info:', error);
            
            // Show error state
            loadingDiv.style.display = 'none';
            contentDiv.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.querySelector('p').textContent = error.message || 'Failed to load nutrient information';
        }
    }
    
    populateNutrientModal(nutrientData) {
        // Update modal title and basic info with defensive checks
        const modalName = document.getElementById('nutrient-modal-name');
        const nutrientSymbol = document.getElementById('nutrient-symbol');
        const nutrientUnit = document.getElementById('nutrient-unit');
        const mobilityElement = document.getElementById('nutrient-mobility');
        const description = document.getElementById('nutrient-description');
        const functions = document.getElementById('nutrient-functions');
        const deficiencySymptoms = document.getElementById('deficiency-symptoms');
        const toxicitySymptoms = document.getElementById('toxicity-symptoms');
        const uptakeInteractions = document.getElementById('uptake-interactions');
        
        if (modalName) modalName.textContent = `${nutrientData.name} (${nutrientData.symbol})`;
        if (nutrientSymbol) nutrientSymbol.textContent = nutrientData.symbol;
        if (nutrientUnit) nutrientUnit.textContent = nutrientData.unit;
        
        if (mobilityElement) {
            mobilityElement.textContent = nutrientData.mobility;
            mobilityElement.setAttribute('data-mobility', nutrientData.mobility);
        }
        
        if (description) description.textContent = nutrientData.description || 'No description available.';
        if (functions) functions.textContent = nutrientData.primary_functions || 'No function information available.';
        if (deficiencySymptoms) deficiencySymptoms.textContent = nutrientData.deficiency_symptoms || 'No deficiency information available.';
        if (toxicitySymptoms) toxicitySymptoms.textContent = nutrientData.toxicity_symptoms || 'No toxicity information available.';
        if (uptakeInteractions) uptakeInteractions.textContent = nutrientData.uptake_interactions || 'No interaction information available.';
        
        const commonSources = document.getElementById('common-sources');
        if (commonSources) commonSources.textContent = nutrientData.common_sources || 'No source information available.';
        
        // Populate system context if available
        this.populateSystemContext(nutrientData.system_context);
        
        // Populate ratio information
        this.populateRatioInformation(nutrientData.ratio_info);
        
        // Populate deficiency images
        this.populateDeficiencyImages(nutrientData.deficiency_images);
        
        // Populate competition interactions
        this.populateCompetitionInteractions(nutrientData.competitions);
        
        // Populate pH availability chart
        this.populatePHAvailability(nutrientData.ph_availability);
    }
    
    populateSystemContext(systemContext) {
        const contextSection = document.getElementById('system-context-section');
        const contextContainer = document.getElementById('system-crop-recommendations');
        
        if (!systemContext || !systemContext.current_crops || systemContext.current_crops.length === 0) {
            contextSection.style.display = 'none';
            return;
        }
        
        contextSection.style.display = 'block';
        
        let contextHTML = '<p class="context-intro">Based on crops currently growing in your system:</p>';
        
        Object.entries(systemContext.crop_ranges).forEach(([cropCode, cropData]) => {
            contextHTML += `
                <div class="crop-recommendation-card">
                    <div class="crop-recommendation-header">
                        <h5 class="crop-recommendation-name">${cropData.crop_name}</h5>
                    </div>
                    <div class="stage-recommendations">
                        ${Object.entries(cropData.stages).map(([stageCode, stageData]) => `
                            <div class="stage-recommendation">
                                <div class="stage-name">${stageData.stage_name}</div>
                                <div class="stage-values">
                                    <span class="target-value">${stageData.target} ppm</span>
                                    <span class="range-values">(${stageData.min} - ${stageData.max})</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });
        
        contextContainer.innerHTML = contextHTML;
    }
    
    populateRatioInformation(ratioInfo) {
        const ratioContainer = document.getElementById('ratio-info-content');
        
        if (!ratioInfo) {
            ratioContainer.innerHTML = '<p>No ratio information available for this nutrient.</p>';
            return;
        }
        
        let ratioHTML = '';
        
        if (ratioInfo.is_ratio_based) {
            // Ratio-based nutrient
            ratioHTML = `
                <div class="ratio-explanation">
                    <div class="ratio-explanation-title">
                        üìä Ratio-Based Nutrient
                    </div>
                    <p>This nutrient concentration is calculated as a ratio relative to ${ratioInfo.base_nutrient} levels in your system.</p>
                </div>
                <div class="ratio-stages">
                    ${Object.entries(ratioInfo.stages).map(([stageCode, stageData]) => `
                        <div class="ratio-stage-card">
                            <div class="stage-header">${stageData.stage_name}</div>
                            <div class="ratio-values">
                                <div class="ratio-average">${stageData.avg_ratio}:1</div>
                                <div class="ratio-range">Range: ${stageData.min_ratio} - ${stageData.max_ratio}</div>
                                ${stageData.notes ? `<div class="ratio-notes">${stageData.notes}</div>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        } else if (ratioInfo.fixed_ranges) {
            // Fixed-range nutrient
            ratioHTML = `
                <div class="fixed-range-explanation">
                    <div class="fixed-range-title">
                        üìè Fixed Concentration Range
                    </div>
                    <p>This nutrient uses absolute concentration values (ppm) rather than ratios.</p>
                </div>
                <div class="ratio-stages">
                    ${Object.entries(ratioInfo.fixed_ranges).map(([stageCode, stageData]) => `
                        <div class="ratio-stage-card">
                            <div class="stage-header">${stageData.stage_name}</div>
                            <div class="ratio-values">
                                <div class="ratio-average">${stageData.avg_ppm} ppm</div>
                                <div class="ratio-range">Range: ${stageData.min_ppm} - ${stageData.max_ppm} ppm</div>
                                ${stageData.notes ? `<div class="ratio-notes">${stageData.notes}</div>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        ratioContainer.innerHTML = ratioHTML;
    }
    
    populateDeficiencyImages(deficiencyImages) {
        const imagesSection = document.getElementById('deficiency-images-section');
        const imagesGrid = document.getElementById('deficiency-images-grid');
        
        if (!deficiencyImages || deficiencyImages.length === 0) {
            imagesSection.style.display = 'none';
            return;
        }
        
        imagesSection.style.display = 'block';
        
        const imagesHTML = deficiencyImages.map(image => `
            <div class="deficiency-image-card">
                <img src="${image.image_url || image.image_filename}" alt="${image.caption}" class="deficiency-image">
                <div class="image-caption">${image.caption || 'Deficiency symptoms'}</div>
                <span class="deficiency-stage-badge ${image.deficiency_stage}">${image.deficiency_stage}</span>
                ${image.plant_type ? `<div class="plant-type">Plant: ${image.plant_type}</div>` : ''}
            </div>
        `).join('');
        
        imagesGrid.innerHTML = imagesHTML;
    }
    
    populateCompetitionInteractions(competitions) {
        const interactionsSection = document.getElementById('interactions-section');
        const competitionContainer = document.getElementById('competition-interactions');
        
        if (!competitions || competitions.length === 0) {
            interactionsSection.style.display = 'none';
            return;
        }
        
        interactionsSection.style.display = 'block';
        
        const competitionsHTML = competitions.map(comp => `
            <div class="competition-card">
                <div class="competition-header">
                    <div class="competition-nutrient">${comp.competing_name} (${comp.competing_symbol})</div>
                    <div>
                        <span class="competition-type-badge ${comp.competition_type}">${comp.competition_type}</span>
                        <span class="competition-strength">${comp.competition_strength}</span>
                    </div>
                </div>
                <div class="competition-description">${comp.competition_description}</div>
                ${comp.optimal_ratio_notes ? `<div class="optimal-ratio-notes">Optimal ratio: ${comp.optimal_ratio_notes}</div>` : ''}
            </div>
        `).join('');
        
        competitionContainer.innerHTML = competitionsHTML;
    }
    
    populatePHAvailability(phRanges) {
        const phSection = document.getElementById('ph-availability-section');
        const phDataGrid = document.getElementById('ph-availability-data');
        
        if (!phRanges || phRanges.length === 0) {
            phSection.style.display = 'none';
            return;
        }
        
        phSection.style.display = 'block';
        
        const phDataHTML = phRanges.map(range => `
            <div class="ph-data-item">
                <div class="ph-range">pH ${range.ph_min} - ${range.ph_max}</div>
                <div class="availability-percentage">${range.availability_percentage}%</div>
                <div class="availability-bar">
                    <div class="availability-fill" style="width: ${range.availability_percentage}%"></div>
                </div>
            </div>
        `).join('');
        
        phDataGrid.innerHTML = phDataHTML;
        
        // Create simple pH availability chart
        this.createPHAvailabilityChart(phRanges);
    }
    
    createPHAvailabilityChart(phRanges) {
        const canvas = document.getElementById('ph-availability-canvas');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set up chart dimensions
        const padding = 40;
        const chartWidth = canvas.width - 2 * padding;
        const chartHeight = canvas.height - 2 * padding;
        
        // Draw axis
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // X-axis
        ctx.moveTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding, canvas.height - padding);
        // Y-axis
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.stroke();
        
        // Draw pH availability bars
        const barWidth = chartWidth / phRanges.length;
        
        phRanges.forEach((range, index) => {
            const barHeight = (range.availability_percentage / 100) * chartHeight;
            const x = padding + index * barWidth;
            const y = canvas.height - padding - barHeight;
            
            // Color based on availability
            if (range.availability_percentage >= 80) {
                ctx.fillStyle = '#80FB7B';
            } else if (range.availability_percentage >= 50) {
                ctx.fillStyle = '#f59e0b';
            } else {
                ctx.fillStyle = '#ef4444';
            }
            
            ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
            
            // Draw pH range labels
            ctx.fillStyle = '#333';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${range.ph_min}-${range.ph_max}`, x + barWidth/2, canvas.height - padding + 15);
        });
        
        // Draw labels
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('pH Range', canvas.width / 2, canvas.height - 5);
        
        ctx.save();
        ctx.translate(15, canvas.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Availability %', 0, 0);
        ctx.restore();
    }
    
    updateWizardUI() {
        // Update step visibility
        document.querySelectorAll('.wizard-step').forEach(step => {
            step.classList.toggle('active', parseInt(step.dataset.step) === this.currentSystemStep);
        });
        
        // Update progress indicators
        document.querySelectorAll('.progress-step').forEach(step => {
            const stepNum = parseInt(step.dataset.step);
            step.classList.toggle('active', stepNum === this.currentSystemStep);
            step.classList.toggle('completed', stepNum < this.currentSystemStep);
        });
        
        // Update navigation buttons
        const modal = document.getElementById('new-system-modal');
        const prevBtn = modal.querySelector('.prev-btn');
        const nextBtn = modal.querySelector('.next-btn');
        const submitBtn = modal.querySelector('.submit-btn');

        if (prevBtn) prevBtn.style.display = this.currentSystemStep > 1 ? 'flex' : 'none';
        if (nextBtn) nextBtn.style.display = this.currentSystemStep < 4 ? 'flex' : 'none';
        if (submitBtn) submitBtn.style.display = this.currentSystemStep === 4 ? 'flex' : 'none';
    }
    
    // Helper function to collect bed data directly from form fields
    collectBedDataFromForm(bedIndex, bedType) {

        if (!bedType) return {};
        
        const formData = {};
        
        if (bedType === 'dwc') {
            formData.length = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            formData.width = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            formData.height = parseFloat(document.getElementById(`bed-height-${bedIndex}`)?.value) || 0;
        } else if (bedType === 'vertical') {
            formData.length = parseFloat(document.getElementById(`base-length-${bedIndex}`)?.value) || 0;
            formData.width = parseFloat(document.getElementById(`base-width-${bedIndex}`)?.value) || 0;
            formData.height = parseFloat(document.getElementById(`base-height-${bedIndex}`)?.value) || 0;
            formData.verticals = parseInt(document.getElementById(`vertical-count-${bedIndex}`)?.value) || 0;
            formData.plantsPerVertical = parseInt(document.getElementById(`plants-per-vertical-${bedIndex}`)?.value) || 0;
        } else if (bedType === 'nft') {
            formData.troughLength = parseFloat(document.getElementById(`trough-length-${bedIndex}`)?.value) || 0;
            formData.channels = parseInt(document.getElementById(`bed-channels-${bedIndex}`)?.value) || 0;
            formData.plantSpacing = parseFloat(document.getElementById(`plant-spacing-${bedIndex}`)?.value) || 0;
            formData.reservoirVolume = parseFloat(document.getElementById(`reservoir-volume-${bedIndex}`)?.value) || 0;
        } else if (bedType === 'ebb_flow') {
            formData.length = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            formData.width = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            formData.height = parseFloat(document.getElementById(`bed-height-${bedIndex}`)?.value) || 0;
            formData.plantSpacing = parseFloat(document.getElementById(`plant-spacing-${bedIndex}`)?.value) || 0;
        }

        return formData;
    }

    async validateCurrentStep() {

        const errors = [];
        
        switch(this.currentSystemStep) {
            case 1:
                // Step 1: Quickstart options - just validate that an option is selected
                const setupType = document.querySelector('input[name="system-setup"]:checked')?.value;
                if (!setupType) {
                    errors.push('Please select a setup method');
                }
                break;
                
            case 2:
                // Step 2: Basic info validation (only for custom setup)
                const name = document.getElementById('new-system-name').value.trim();
                const type = document.getElementById('new-system-type').value;
                const tankCount = parseInt(document.getElementById('new-fish-tank-count').value);
                const bedCount = parseInt(document.getElementById('new-grow-bed-count').value);
                
                if (!name) {
                    errors.push('System name is required');
                    this.highlightError('new-system-name');
                }
                if (!type) {
                    errors.push('System type is required');
                    this.highlightError('new-system-type');
                }
                if (!tankCount || tankCount < 1 || tankCount > 10) {
                    errors.push('Number of fish tanks must be between 1 and 10');
                    this.highlightError('new-fish-tank-count');
                }
                if (!bedCount || bedCount < 1 || bedCount > 20) {
                    errors.push('Number of grow beds must be between 1 and 20');
                    this.highlightError('new-grow-bed-count');
                }
                break;
                
            case 3:
                // For step 3 (fish tanks), we need to give the DOM time to update after HTML generation
                // This ensures that when validation runs, the form elements have their values set
                await new Promise(resolve => setTimeout(resolve, 50));
                const debugEl = document.getElementById('tank-volume-1');

                // Save current data first to ensure we validate current values
                const tempStep = this.currentSystemStep;
                this.currentSystemStep = 3; // Temporarily set to 3 for saveCurrentStepData
                await this.saveCurrentStepData();
                this.currentSystemStep = tempStep; // Restore original step
                
                const tankCountForValidation = this.systemWizardData.fishTankCount || parseInt(document.getElementById('new-fish-tank-count').value);
                for (let i = 1; i <= tankCountForValidation; i++) {
                    // Use saved data if available, otherwise read from DOM
                    const savedTank = this.systemWizardData.fishTanks?.[i-1];
                    const tankNameEl = document.getElementById(`tank-name-${i}`);
                    const tankVolumeEl = document.getElementById(`tank-volume-${i}`);
                    const fishTypeEl = document.getElementById(`tank-fish-${i}`);
                    const stockingDensityEl = document.getElementById(`tank-stocking-${i}`);
                    const harvestWeightEl = document.getElementById(`tank-harvest-${i}`);
                    
                    const tankName = savedTank?.name || tankNameEl?.value?.trim() || '';
                    const tankVolume = (savedTank && savedTank.volume !== null) ? savedTank.volume.toString() : (tankVolumeEl?.value?.trim() || '');
                    const fishType = savedTank?.fishType || fishTypeEl?.value || '';
                    const stockingDensity = (savedTank && savedTank.stockingDensity !== null) ? savedTank.stockingDensity.toString() : (stockingDensityEl?.value?.trim() || '');
                    const harvestWeight = (savedTank && savedTank.harvestWeight !== null) ? savedTank.harvestWeight.toString() : (harvestWeightEl?.value?.trim() || '');

                    if (!tankName) {
                        errors.push(`Tank ${i} name is required`);
                        this.highlightError(`tank-name-${i}`);
                    }
                    
                    const volumeNum = parseFloat(tankVolume);
                    if (!tankVolume || isNaN(volumeNum) || volumeNum <= 0) {
                        errors.push(`Tank ${i} volume must be greater than 0`);
                        this.highlightError(`tank-volume-${i}`);
                    }
                    
                    if (!fishType) {
                        errors.push(`Tank ${i} fish type is required`);
                        this.highlightError(`tank-fish-${i}`);
                    }
                    
                    const densityNum = parseFloat(stockingDensity);
                    if (!stockingDensity || isNaN(densityNum) || densityNum <= 0) {
                        errors.push(`Tank ${i} stocking density must be greater than 0`);
                        this.highlightError(`tank-stocking-${i}`);
                    }
                    
                    const weightNum = parseFloat(harvestWeight);
                    if (!harvestWeight || isNaN(weightNum) || weightNum <= 0) {
                        errors.push(`Tank ${i} target harvest weight must be greater than 0`);
                        this.highlightError(`tank-harvest-${i}`);
                    }
                }
                break;
                
            case 4:
                // Similar timing fix for step 4 (grow beds)
                await new Promise(resolve => setTimeout(resolve, 50));
                
                const bedCountForValidation = parseInt(document.getElementById('new-grow-bed-count').value);
                for (let i = 1; i <= bedCountForValidation; i++) {
                    const bedName = document.getElementById(`bed-name-${i}`)?.value?.trim() || '';
                    const bedType = document.getElementById(`bed-type-${i}`)?.value || '';
                    
                    if (!bedName) {
                        errors.push(`Grow Bed ${i} name is required`);
                        this.highlightError(`bed-name-${i}`);
                    }
                    if (!bedType) {
                        errors.push(`Grow Bed ${i} type is required`);
                        this.highlightError(`bed-type-${i}`);
                    }
                    
                    // Validate type-specific required fields
                    if (bedType) {
                        if (bedType === 'dwc' || bedType === 'flood-drain' || bedType === 'media-flow') {
                            const length = document.getElementById(`bed-length-${i}`)?.value;
                            const width = document.getElementById(`bed-width-${i}`)?.value;
                            const height = document.getElementById(`bed-height-${i}`)?.value;
                            
                            if (!length || parseFloat(length) <= 0) {
                                errors.push(`Grow Bed ${i} length is required`);
                                this.highlightError(`bed-length-${i}`);
                            }
                            if (!width || parseFloat(width) <= 0) {
                                errors.push(`Grow Bed ${i} width is required`);
                                this.highlightError(`bed-width-${i}`);
                            }
                            if (!height || parseFloat(height) <= 0) {
                                errors.push(`Grow Bed ${i} height/depth is required`);
                                this.highlightError(`bed-height-${i}`);
                            }
                        } else if (bedType === 'vertical') {
                            const length = document.getElementById(`bed-length-${i}`)?.value;
                            const width = document.getElementById(`bed-width-${i}`)?.value;
                            const height = document.getElementById(`bed-height-${i}`)?.value;
                            const verticals = document.getElementById(`bed-verticals-${i}`)?.value;
                            const plantsPerVertical = document.getElementById(`bed-plants-per-vertical-${i}`)?.value;
                            
                            if (!length || parseFloat(length) <= 0) {
                                errors.push(`Grow Bed ${i} base length is required`);
                                this.highlightError(`bed-length-${i}`);
                            }
                            if (!width || parseFloat(width) <= 0) {
                                errors.push(`Grow Bed ${i} base width is required`);
                                this.highlightError(`bed-width-${i}`);
                            }
                            if (!height || parseFloat(height) <= 0) {
                                errors.push(`Grow Bed ${i} base height is required`);
                                this.highlightError(`bed-height-${i}`);
                            }
                            if (!verticals || parseInt(verticals) <= 0) {
                                errors.push(`Grow Bed ${i} number of verticals is required`);
                                this.highlightError(`bed-verticals-${i}`);
                            }
                            if (!plantsPerVertical || parseInt(plantsPerVertical) <= 0) {
                                errors.push(`Grow Bed ${i} plants per vertical is required`);
                                this.highlightError(`bed-plants-per-vertical-${i}`);
                            }
                        } else if (bedType === 'nft') {
                            const length = document.getElementById(`bed-length-${i}`)?.value;
                            const channels = document.getElementById(`bed-channels-${i}`)?.value;
                            const width = document.getElementById(`bed-width-${i}`)?.value;
                            
                            if (!length || parseFloat(length) <= 0) {
                                errors.push(`Grow Bed ${i} channel length is required`);
                                this.highlightError(`bed-length-${i}`);
                            }
                            if (!channels || parseInt(channels) <= 0) {
                                errors.push(`Grow Bed ${i} number of channels is required`);
                                this.highlightError(`bed-channels-${i}`);
                            }
                            if (!width || parseFloat(width) <= 0) {
                                errors.push(`Grow Bed ${i} channel width is required`);
                                this.highlightError(`bed-width-${i}`);
                            }
                        }
                    }
                }
                break;
        }
        
        if (errors.length > 0) {
            this.showNotification(errors[0], 'warning');
            // Clear error highlights after 3 seconds
            setTimeout(() => this.clearErrorHighlights(), 3000);
            return false;
        }
        
        this.clearErrorHighlights();
        return true;
    }
    
    highlightError(fieldId) {
        const field = document.getElementById(fieldId);
        if (field) {
            field.classList.add('error-field');
        }
    }
    
    clearErrorHighlights() {
        document.querySelectorAll('.error-field').forEach(field => {
            field.classList.remove('error-field');
        });
    }
    
    async saveCurrentStepData() {
        switch(this.currentSystemStep) {
            case 1:
                // Quickstart options step - save setup type choice
                const setupType = document.querySelector('input[name="system-setup"]:checked')?.value;
                this.systemWizardData.setupType = setupType;
                
                if (setupType === 'demo') {
                    // Skip wizard and create demo system directly
                    await this.createDemoSystemAndFinish();
                    return;
                }
                break;
                
            case 2:
                // Basic info step - save system name, type, and counts (only for custom setup)
                this.systemWizardData.systemName = document.getElementById('new-system-name').value;
                this.systemWizardData.systemType = document.getElementById('new-system-type').value;
                this.systemWizardData.fishTankCount = parseInt(document.getElementById('new-fish-tank-count').value) || 1;
                this.systemWizardData.growBedCount = parseInt(document.getElementById('new-grow-bed-count').value) || 2;
                break;
                
            case 3:
                // Fish tanks step - save tank data
                this.systemWizardData.fishTanks = [];
                const tankCount = this.systemWizardData.fishTankCount || 1;
                
                for (let i = 1; i <= tankCount; i++) {
                    const name = document.getElementById(`tank-name-${i}`)?.value || `Tank ${i}`;
                    const volume = document.getElementById(`tank-volume-${i}`)?.value;
                    const fishType = document.getElementById(`tank-fish-${i}`)?.value;
                    const stockingDensity = document.getElementById(`tank-stocking-${i}`)?.value;
                    const harvestWeight = document.getElementById(`tank-harvest-${i}`)?.value;
                    
                    this.systemWizardData.fishTanks.push({
                        name,
                        volume: volume ? parseFloat(volume) : null,
                        fishType,
                        stockingDensity: stockingDensity ? parseInt(stockingDensity) : null,
                        harvestWeight: harvestWeight ? parseInt(harvestWeight) : null
                    });
                }
                break;
                
            case 4:
                // Grow beds step - save bed data

                this.systemWizardData.growBeds = [];
                const bedCount = this.systemWizardData.growBedCount || 2;

                for (let i = 1; i <= bedCount; i++) {
                    const name = document.getElementById(`bed-name-${i}`)?.value || `Bed ${i}`;
                    const type = document.getElementById(`bed-type-${i}`)?.value;
                    const length = document.getElementById(`bed-length-${i}`)?.value;
                    const width = document.getElementById(`bed-width-${i}`)?.value;
                    const height = document.getElementById(`bed-height-${i}`)?.value;
                    
                    // Additional fields for specific types
                    const verticals = document.getElementById(`bed-verticals-${i}`)?.value;
                    const plantsPerVertical = document.getElementById(`bed-plants-per-vertical-${i}`)?.value;
                    const channels = document.getElementById(`bed-channels-${i}`)?.value;
                    
                    const bedData = {
                        name,
                        type,
                        length: length ? parseFloat(length) : null,
                        width: width ? parseFloat(width) : null,
                        height: height ? parseFloat(height) : null,
                        verticals: verticals ? parseInt(verticals) : null,
                        plantsPerVertical: plantsPerVertical ? parseInt(plantsPerVertical) : null,
                        channels: channels ? parseInt(channels) : null
                    };

                    this.systemWizardData.growBeds.push(bedData);
                }

                break;
        }
    }
    
    async nextSystemStep() {
        if (!(await this.validateCurrentStep())) return;
        
        // Save current step data before moving to next step
        await this.saveCurrentStepData();
        
        if (this.currentSystemStep < 4) {
            this.currentSystemStep++;
            this.updateWizardUI();
            
            // Initialize specific steps when reaching them
            if (this.currentSystemStep === 3) {
                // Ensure fish tank fields are properly initialized
                const tankCount = parseInt(document.getElementById('new-fish-tank-count').value) || 1;
                this.updateFishTankFields(tankCount);
            } else if (this.currentSystemStep === 4) {
                // Ensure grow bed fields are properly initialized
                const bedCount = parseInt(document.getElementById('new-grow-bed-count').value) || 2;
                this.updateGrowBedFields(bedCount);
            }
        }
    }
    
    async prevSystemStep() {
        if (this.currentSystemStep > 1) {
            // Save current step data before moving to previous step
            await this.saveCurrentStepData();
            this.currentSystemStep--;
            this.updateWizardUI();
        }
    }
    
    updateFishTankFields(count) {
        const container = document.getElementById('fish-tank-details');
        container.innerHTML = '';
        
        for (let i = 1; i <= count; i++) {
            // Check if we have existing data for this tank
            const existingTank = this.systemWizardData.fishTanks[i-1];
            
            // Use demo data if available, otherwise use existing or defaults
            let tankData = {};
            if (this.systemWizardData.setupType === 'demo' && this.systemWizardData.demoData?.fish_tanks[i-1]) {
                const demoTank = this.systemWizardData.demoData.fish_tanks[i-1];
                tankData = {
                    name: demoTank.name,
                    volume: demoTank.volume,
                    fishType: demoTank.fish_type,
                    stockingDensity: demoTank.stocking_density,
                    harvestWeight: demoTank.target_harvest_weight
                };
            } else {
                tankData = {
                    name: existingTank?.name || `Tank ${i}`,
                    volume: (existingTank && existingTank.volume !== null) ? existingTank.volume : 1000,
                    fishType: existingTank?.fishType || 'tilapia',
                    stockingDensity: existingTank?.stockingDensity || null,
                    harvestWeight: existingTank?.harvestWeight || null
                };
            }
            
            const fishDefaults = this.fishData[tankData.fishType];

            const tankHtml = `
                <div class="detail-card">
                    <div class="detail-card-header">
                        <span>üêü</span>
                        <span>Fish Tank ${i}</span>
                    </div>
                    <div class="detail-fields fish-tank-fields">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Tank Name</span>
                            </label>
                            <input type="text" class="modern-input" id="tank-name-${i}" 
                                   placeholder="Tank ${i}" value="${tankData.name}" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Volume (L)</span>
                            </label>
                            <input type="number" class="modern-input" id="tank-volume-${i}" 
                                   value="${tankData.volume}" min="100" step="50" required placeholder="1000">
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Fish Type</span>
                            </label>
                            <select class="modern-select" id="tank-fish-${i}" onchange="app.updateFishDefaults(${i}, this.value)" required>
                                <option value="tilapia" ${tankData.fishType === 'tilapia' ? 'selected' : ''}>Tilapia</option>
                                <option value="carp" ${tankData.fishType === 'carp' ? 'selected' : ''}>Carp</option>
                                <option value="catfish" ${tankData.fishType === 'catfish' ? 'selected' : ''}>Catfish</option>
                                <option value="trout" ${tankData.fishType === 'trout' ? 'selected' : ''}>Trout</option>
                            </select>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Stocking Density (fish/m¬≥)</span>
                            </label>
                            <input type="number" class="modern-input" id="tank-stocking-${i}" 
                                   value="${tankData.stockingDensity || fishDefaults.defaultDensity}" min="1" step="1" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Target Harvest Weight (g)</span>
                            </label>
                            <input type="number" class="modern-input" id="tank-harvest-${i}" 
                                   value="${tankData.harvestWeight || fishDefaults.harvestWeight}" min="50" step="50" required>
                        </div>
                    </div>
                </div>
            `;
            container.innerHTML += tankHtml;
            
            // Explicitly set field values after DOM insertion to ensure they stick
            // Capture values in closure to ensure they're available in setTimeout
            const tankVolume = tankData.volume;
            const tankStockingDensity = (existingTank && existingTank.stockingDensity !== null) ? existingTank.stockingDensity : fishDefaults.defaultDensity;
            const tankHarvestWeight = (existingTank && existingTank.harvestWeight !== null) ? existingTank.harvestWeight : fishDefaults.harvestWeight;
            
            setTimeout(() => {
                const volumeEl = document.getElementById(`tank-volume-${i}`);
                const stockingEl = document.getElementById(`tank-stocking-${i}`);
                const harvestEl = document.getElementById(`tank-harvest-${i}`);

                if (volumeEl) volumeEl.value = tankVolume;
                if (stockingEl) stockingEl.value = tankStockingDensity;
                if (harvestEl) harvestEl.value = tankHarvestWeight;
            }, 0);
        }
    }
    
    updateFishDefaults(tankNum, fishType) {
        if (!this.fishData[fishType]) return;
        
        const fishDefaults = this.fishData[fishType];
        const stockingField = document.getElementById(`tank-stocking-${tankNum}`);
        const harvestField = document.getElementById(`tank-harvest-${tankNum}`);
        
        if (stockingField) stockingField.value = fishDefaults.defaultDensity;
        if (harvestField) harvestField.value = fishDefaults.harvestWeight;
    }
    
    updateGrowBedFields(count) {
        const container = document.getElementById('grow-bed-details');
        container.innerHTML = '';
        
        const bedTypes = {
            'media-flow': 'Media Flow Through (MFT)',
            'flood-drain': 'Flood & Drain (F&D)',
            'dwc': 'Deep Water Culture (DWC)',
            'vertical': 'Vertical Growing',
            'nft': 'NFT (Nutrient Film Technique)'
        };
        
        for (let i = 1; i <= count; i++) {
            // Check if we have existing data for this bed
            const existingBed = this.systemWizardData.growBeds[i-1];
            
            // Use demo data if available, otherwise use existing or defaults
            let bedData = {};
            if (this.systemWizardData.setupType === 'demo' && this.systemWizardData.demoData?.grow_beds[i-1]) {
                const demoBed = this.systemWizardData.demoData.grow_beds[i-1];
                bedData = {
                    name: demoBed.bed_name,
                    type: demoBed.type,
                    area: demoBed.area_m2,
                    depth: demoBed.depth
                };
            } else {
                bedData = {
                    name: existingBed?.name || `Bed ${i}`,
                    type: existingBed?.type || '',
                    area: existingBed?.area || '',
                    depth: existingBed?.depth || ''
                };
            }
            
            const bedHtml = `
                <div class="detail-card">
                    <div class="detail-card-header">
                        <img src="/icons/new-icons/Afraponix Go Icons_flow through.svg" alt="Grow Bed" class="bed-config-icon" />
                        <span>Grow Bed ${i}</span>
                    </div>
                    <div class="detail-fields" style="grid-template-columns: 1fr 1fr; margin-bottom: 1rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Bed Name</span>
                            </label>
                            <input type="text" class="modern-input" id="bed-name-${i}" 
                                   placeholder="Bed ${i}" value="${bedData.name}" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Bed Type</span>
                            </label>
                            <select class="modern-select" id="bed-type-${i}" onchange="app.updateBedTypeFields(${i})" required>
                                <option value="">Select Type</option>
                                ${Object.entries(bedTypes).map(([value, name]) => 
                                    `<option value="${value}" ${bedData.type === value ? 'selected' : ''}>${name}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    
                    <!-- Dynamic fields container - moved outside detail-fields -->
                    <div id="bed-type-fields-${i}" class="bed-type-fields" style="margin-top: 1rem;">
                        <!-- Type-specific fields will be inserted here -->
                    </div>
                </div>
            `;
            container.innerHTML += bedHtml;
            
            // If bed has a type (from existing or demo data), populate the type-specific fields
            if (bedData.type) {
                setTimeout(() => {
                    this.updateBedTypeFields(i);
                }, 0);
            }
        }
    }
    
    updateBedTypeFields(bedIndex) {
        const typeSelect = document.getElementById(`bed-type-${bedIndex}`);
        const fieldsContainer = document.getElementById(`bed-type-fields-${bedIndex}`);
        
        if (!typeSelect || !fieldsContainer) return;
        
        const bedType = typeSelect.value;
        const existingBed = this.systemWizardData.growBeds?.[bedIndex-1];
        
        // Get demo data if available
        let bedData = {};
        if (this.systemWizardData.setupType === 'demo' && this.systemWizardData.demoData?.grow_beds[bedIndex-1]) {
            const demoBed = this.systemWizardData.demoData.grow_beds[bedIndex-1];
            bedData = {
                area: demoBed.area_m2,
                depth: demoBed.depth,
                length: Math.sqrt(demoBed.area_m2), // Approximate square dimensions
                width: Math.sqrt(demoBed.area_m2)
            };
        } else {
            bedData = {
                area: existingBed?.area || '',
                depth: existingBed?.depth || '',
                length: existingBed?.length || '',
                width: existingBed?.width || ''
            };
        }
        
        if (!bedType) {
            fieldsContainer.innerHTML = '';
            return;
        }
        
        let html = '';
        
        if (bedType === 'dwc') {
            html = `
                <div class="bed-dimensions" style="margin-top: 1rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Bed Dimensions</h4>
                    <div class="dimension-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Length (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-length" id="bed-length-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="2.0" value="${bedData.length}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Width (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-width" id="bed-width-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="1.0" value="${bedData.width}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Depth (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-height" id="bed-height-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="0.3" value="${existingBed?.height || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                </div>
                <div class="calculation-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Volume</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-volume">0</span> L
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Area</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-area">0.0</span> m¬≤
                        </div>
                    </div>
                </div>
                <p style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; text-align: center; font-style: italic;">
                    DWC: Volume = L√óW√óH, Area = L√óW
                </p>
            `;
        } else if (bedType === 'flood-drain') {
            html = `
                <div class="bed-dimensions" style="margin-top: 1rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Bed Dimensions</h4>
                    <div class="dimension-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Length (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-length" id="bed-length-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="2.0" value="${bedData.length}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Width (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-width" id="bed-width-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="1.0" value="${bedData.width}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Media Depth (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-height" id="bed-height-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="0.25" value="${existingBed?.height || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                </div>
                <div class="calculation-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Volume</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-volume">0</span> L
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Area</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-area">0.0</span> m¬≤
                        </div>
                    </div>
                </div>
                <p style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; text-align: center; font-style: italic;">
                    F&D: Volume = L√óW√óH√ó0.3 (media porosity), Area = L√óW
                </p>
            `;
        } else if (bedType === 'media-flow') {
            html = `
                <div class="bed-dimensions" style="margin-top: 1rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Bed Dimensions</h4>
                    <div class="dimension-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Length (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-length" id="bed-length-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="2.0" value="${bedData.length}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Width (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-width" id="bed-width-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="1.0" value="${bedData.width}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Height/Depth (m)</span>
                            </label>
                            <input type="number" class="modern-input bed-height" id="bed-height-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="0.3" value="${existingBed?.height || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                </div>
                <div class="calculation-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Volume</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-volume">0</span> L
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Area</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-area">0.0</span> m¬≤
                        </div>
                    </div>
                </div>
                <p style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; text-align: center; font-style: italic;">
                    MFT: Volume = L√óW√óH, Area = L√óW
                </p>
            `;
        } else if (bedType === 'vertical') {
            html = `
                <div class="bed-dimensions" style="margin-top: 1rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Base Dimensions</h4>
                    <div class="dimension-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Base Length (m)</span>
                            </label>
                            <input type="number" class="modern-input base-length" id="bed-length-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="1.0" value="${existingBed?.length || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Base Width (m)</span>
                            </label>
                            <input type="number" class="modern-input base-width" id="bed-width-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="1.0" value="${bedData.width}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Base Height (m)</span>
                            </label>
                            <input type="number" class="modern-input base-height" id="bed-height-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="0.5" value="${existingBed?.height || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                    
                    <h4 style="margin: 1.5rem 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Vertical Configuration</h4>
                    <div class="vertical-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Number of Verticals</span>
                            </label>
                            <input type="number" class="modern-input vertical-count" id="bed-verticals-${bedIndex}" 
                                   min="1" step="1" placeholder="4" value="${existingBed?.verticals || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Plants per Vertical</span>
                            </label>
                            <input type="number" class="modern-input plants-per-vertical" id="bed-plants-per-vertical-${bedIndex}" 
                                   min="1" step="1" placeholder="12" value="${existingBed?.plantsPerVertical || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                </div>
                <div class="calculation-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Volume</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-volume">0</span> L
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Area</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-area">0.0</span> m¬≤
                        </div>
                    </div>
                </div>
                <p style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; text-align: center; font-style: italic;">
                    Vertical: Volume = Base√óH, Area = Verticals√óPlants√ó0.05m¬≤
                </p>
            `;
        } else if (bedType === 'nft') {
            html = `
                <div class="bed-dimensions" style="margin-top: 1rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #2c3e50; font-size: 0.9rem; font-weight: 600;">Channel Configuration</h4>
                    <div class="dimension-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Channel Length (m)</span>
                            </label>
                            <input type="number" class="modern-input channel-length" id="bed-length-${bedIndex}" 
                                   min="0.1" step="0.1" placeholder="3.0" value="${existingBed?.length || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Number of Channels</span>
                            </label>
                            <input type="number" class="modern-input channel-count" id="bed-channels-${bedIndex}" 
                                   min="1" step="1" placeholder="6" value="${existingBed?.channels || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                        <div class="form-field">
                            <label class="modern-label">
                                <span class="label-text">Channel Width (m)</span>
                            </label>
                            <input type="number" class="modern-input channel-width" id="bed-width-${bedIndex}" 
                                   min="0.05" step="0.01" placeholder="0.1" value="${existingBed?.width || ''}" 
                                   onchange="app.calculateBedMetrics(${bedIndex})" required>
                        </div>
                    </div>
                </div>
                <div class="calculation-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Volume</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-volume">0</span> L
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Area</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: #2c3e50;">
                            <span class="calculated-area">0.0</span> m¬≤
                        </div>
                    </div>
                </div>
                <p style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; text-align: center; font-style: italic;">
                    NFT: Volume = Channels√óLength√ó0.002m¬≥, Area = Channels√óLength√óWidth
                </p>
            `;
        }
        
        fieldsContainer.innerHTML = html;
        
        // Calculate initial values if fields have data
        setTimeout(() => {
            this.calculateBedMetrics(bedIndex);
        }, 0);
    }
    
    calculateBedMetricsForSaving(bedType, bedData) {
        let volume = 0;
        let area = 0;
        
        if (bedType === 'dwc' || bedType === 'media-flow') {
            const length = parseFloat(bedData.length) || 0;
            const width = parseFloat(bedData.width) || 0;
            const height = parseFloat(bedData.height) || 0;
            volume = length * width * height * 1000; // Convert to liters
            area = length * width;
        } else if (bedType === 'flood-drain') {
            const length = parseFloat(bedData.length) || 0;
            const width = parseFloat(bedData.width) || 0;
            const height = parseFloat(bedData.height) || 0;
            volume = length * width * height * 0.3 * 1000; // 30% for media porosity
            area = length * width;
        } else if (bedType === 'vertical') {
            const length = parseFloat(bedData.length) || 0;
            const width = parseFloat(bedData.width) || 0;
            const height = parseFloat(bedData.height) || 0;
            const verticals = parseFloat(bedData.verticals) || 0;
            const plantsPerVertical = parseFloat(bedData.plantsPerVertical) || 0;
            volume = length * width * height * 1000;
            area = verticals * plantsPerVertical * 0.05; // 0.05m¬≤ per plant
        } else if (bedType === 'nft') {
            const length = parseFloat(bedData.length) || 0;
            const width = parseFloat(bedData.width) || 0;
            const channels = parseFloat(bedData.channels) || 0;
            volume = channels * length * 0.002 * 1000; // 0.002m¬≥ per channel meter
            area = channels * length * width;
        }
        
        return { volume, area };
    }
    
    calculateBedMetrics(bedIndex) {
        const typeSelect = document.getElementById(`bed-type-${bedIndex}`);
        const fieldsContainer = document.getElementById(`bed-type-fields-${bedIndex}`);
        
        if (!typeSelect || !fieldsContainer) return;
        
        const bedType = typeSelect.value;
        let volume = 0;
        let area = 0;
        
        if (bedType === 'dwc' || bedType === 'media-flow') {
            const length = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            const width = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            const height = parseFloat(document.getElementById(`bed-height-${bedIndex}`)?.value) || 0;
            
            volume = length * width * height * 1000; // Convert to liters
            area = length * width;
            
        } else if (bedType === 'flood-drain') {
            const length = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            const width = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            const height = parseFloat(document.getElementById(`bed-height-${bedIndex}`)?.value) || 0;
            
            volume = length * width * height * 0.3 * 1000; // 30% porosity, convert to liters
            area = length * width;
            
        } else if (bedType === 'vertical') {
            const baseLength = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            const baseWidth = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            const baseHeight = parseFloat(document.getElementById(`bed-height-${bedIndex}`)?.value) || 0;
            const verticals = parseFloat(document.getElementById(`bed-verticals-${bedIndex}`)?.value) || 0;
            const plantsPerVertical = parseFloat(document.getElementById(`bed-plants-per-vertical-${bedIndex}`)?.value) || 0;
            
            volume = baseLength * baseWidth * baseHeight * 1000; // Convert to liters
            area = verticals * plantsPerVertical * 0.05; // 0.05m¬≤ per plant site
            
        } else if (bedType === 'nft') {
            const channelLength = parseFloat(document.getElementById(`bed-length-${bedIndex}`)?.value) || 0;
            const channelCount = parseFloat(document.getElementById(`bed-channels-${bedIndex}`)?.value) || 0;
            const channelWidth = parseFloat(document.getElementById(`bed-width-${bedIndex}`)?.value) || 0;
            
            volume = channelCount * channelLength * 0.002 * 1000; // Minimal volume, convert to liters
            area = channelCount * channelLength * channelWidth;
        }
        
        // Update display in the calculation summary
        const volumeSpan = fieldsContainer.querySelector('.calculated-volume');
        const areaSpan = fieldsContainer.querySelector('.calculated-area');
        
        if (volumeSpan) volumeSpan.textContent = Math.round(volume);
        if (areaSpan) areaSpan.textContent = area.toFixed(1);
        
        // Update any existing plant allocation total plants calculations for this bed
        this.refreshTotalPlantsCalculations(bedIndex);
    }
    
    refreshTotalPlantsCalculations(bedIndex) {
        // This function updates total plants calculations when bed configuration changes
        // It handles both system setup (where bed configs are being modified) and 
        // existing system allocation views
        
        try {
            // For vertical beds, update the total plants calculation if it exists in allocations
            const typeSelect = document.getElementById(`bed-type-${bedIndex}`);
            if (!typeSelect || typeSelect.value !== 'vertical') return;
            
            const verticals = parseFloat(document.getElementById(`bed-verticals-${bedIndex}`)?.value) || 0;
            const plantsPerVertical = parseFloat(document.getElementById(`bed-plants-per-vertical-${bedIndex}`)?.value) || 0;
            
            if (verticals > 0 && plantsPerVertical > 0) {
                // Try to find and update any existing allocation displays for this bed
                // The bed ID in allocations might be different from bedIndex, so we need to check all beds
                const totalPlantsSpans = document.querySelectorAll('[id^="total-plants-"]');
                
                totalPlantsSpans.forEach(span => {
                    // Extract bed ID from the span ID
                    const bedId = span.id.replace('total-plants-', '');
                    
                    // Check if this bed matches our configuration (this is imperfect but the best we can do)
                    // In a more robust implementation, we'd have better bed tracking
                    const plantsInput = document.getElementById(`plants-${bedId}`);
                    if (plantsInput) {
                        // Get the plants per vertical from the input (this might be the updated value)
                        const currentPlantsPerVertical = parseInt(plantsInput.value) || plantsPerVertical;
                        const totalPlants = verticals * currentPlantsPerVertical;
                        span.textContent = `Total: ${totalPlants} plants`;

                    }
                });
                
                // Also check if we're in the crop allocation settings and update accordingly
                // This will refresh the allocation display if it's currently visible
                if (document.getElementById('grow-bed-allocation-container')) {
                    // Debounce the refresh to avoid too many rapid updates
                    clearTimeout(this._refreshTimeout);
                    this._refreshTimeout = setTimeout(() => {
                        this.refreshAllocationDisplay();
                    }, 500);
                }
            }
        } catch (error) {
            console.error('Error refreshing total plants calculations:', error);
        }
    }
    
    async refreshAllocationDisplay() {
        // Helper function to refresh the allocation display
        try {
            if (this.activeSystemId && document.getElementById('grow-bed-allocation-container')) {
                // REMOVED: Allocation loading - replaced with direct batch tracking

            }
        } catch (error) {
            console.error('Error refreshing allocation display:', error);
        }
    }
    
    // Removed - plant allocation is now done in the main app
    async initializePlantAllocation_removed() {
        const container = document.getElementById('plant-allocation-container');
        const bedCount = parseInt(document.getElementById('new-grow-bed-count').value);
        
        // Load custom crops for allocation
        let customCrops = [];
        try {
            const response = await this.makeApiCall('/plants/custom-crops');
            customCrops = response || [];

        } catch (error) {
            console.error('Failed to load custom crops:', error);
        }
        
        container.innerHTML = '';
        
        for (let i = 1; i <= bedCount; i++) {
            const bedName = document.getElementById(`bed-name-${i}`)?.value || `Bed ${i}`;
            const allocationHtml = `
                <div class="allocation-bed">
                    <div class="allocation-bed-header">
                        <img src="/icons/new-icons/Afraponix Go Icons_flow through.svg" alt="Grow Bed" class="bed-config-icon" />
                        <span>${bedName} - Plant Allocation</span>
                    </div>
                    <div class="allocation-crops-wrapper" style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(69, 231, 221, 0.2); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <div class="allocation-crops">
                            <div class="allocation-row">
                                <select class="modern-select" id="bed-${i}-crop-1">
                                    <option value="">No crop allocated</option>
                                    <optgroup label="Leafy Greens">
                                        <option value="lettuce">Lettuce</option>
                                        <option value="lettuce_batavian">Lettuce - Batavian</option>
                                        <option value="lettuce_butter">Lettuce - Butter</option>
                                        <option value="lettuce_cos">Lettuce - Cos</option>
                                        <option value="lettuce_icty">Lettuce - Icty</option>
                                        <option value="lettuce_datem">Lettuce - Datem</option>
                                        <option value="lettuce_oak">Lettuce - Oak</option>
                                        <option value="spinach">Spinach</option>
                                        <option value="kale">Kale</option>
                                        <option value="swiss_chard">Swiss Chard</option>
                                        <option value="arugula">Arugula</option>
                                        <option value="pac_choi">Pac Choi</option>
                                        <option value="celery">Celery</option>
                                    </optgroup>
                                    <optgroup label="Herbs">
                                        <option value="basil">Basil</option>
                                        <option value="mint">Mint</option>
                                        <option value="parsley">Parsley</option>
                                        <option value="cilantro">Cilantro</option>
                                        <option value="chives">Chives</option>
                                        <option value="oregano">Oregano</option>
                                        <option value="thyme">Thyme</option>
                                    </optgroup>
                                    <optgroup label="Onions & Leeks">
                                        <option value="spring_onion">Spring Onion</option>
                                        <option value="leeks">Leeks</option>
                                    </optgroup>
                                    <optgroup label="Fruiting Vegetables">
                                        <option value="tomatoes">Tomatoes</option>
                                        <option value="peppers">Peppers</option>
                                        <option value="cucumbers">Cucumbers</option>
                                        <option value="eggplant">Eggplant</option>
                                    </optgroup>
                                    ${customCrops.length > 0 ? `
                                        <optgroup label="Custom Crops">
                                            ${customCrops.map(crop => 
                                                `<option value="${crop.crop_name.toLowerCase().replace(/\s+/g, '_')}">${this.cleanCustomCropName(crop.crop_name)}</option>`
                                            ).join('')}
                                        </optgroup>
                                    ` : ''}
                                    <optgroup label="Fruiting Crops">
                                        <option value="tomatoes">Tomatoes</option>
                                        <option value="peppers">Peppers</option>
                                        <option value="cucumbers">Cucumbers</option>
                                    </optgroup>
                                </select>
                                <input type="number" class="modern-input" placeholder="%" min="0" max="100" id="bed-${i}-alloc-1">
                            </div>
                        </div>
                    </div>
                    <div class="allocation-summary" style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(52, 152, 219, 0.1); border-radius: 8px; font-size: 0.9rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Total Allocated: <strong id="bed-${i}-total">0%</strong></span>
                            <span id="bed-${i}-remaining" style="color: #27ae60;">100% remaining</span>
                        </div>
                    </div>
                    <div class="allocation-actions" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" class="btn-secondary" onclick="app.addAllocationRow(${i})">
                            <span>+</span> Add Crop
                        </button>
                        <button type="button" class="btn-outline" onclick="app.showAddCustomCropDialog(${i})">
                            <span>üåø</span> Add Custom Crop
                        </button>
                    </div>
                </div>
            `;
            container.innerHTML += allocationHtml;
        }
        
        // Add event listeners to update allocation percentages
        for (let i = 1; i <= bedCount; i++) {
            this.updateAllocationSummary(i);
            
            // Add listeners to the first input
            const firstInput = document.getElementById(`bed-${i}-alloc-1`);
            if (firstInput) {
                firstInput.addEventListener('input', () => this.updateAllocationSummary(i));
            }
        }
    }
    
    // Removed - plant allocation is now done in the main app
    updateAllocationSummary_removed(bedNum) {
        const allocationInputs = document.querySelectorAll(`[id^="bed-${bedNum}-alloc-"]`);
        let total = 0;
        
        allocationInputs.forEach(input => {
            const value = parseFloat(input.value) || 0;
            total += value;
        });
        
        const totalElement = document.getElementById(`bed-${bedNum}-total`);
        const remainingElement = document.getElementById(`bed-${bedNum}-remaining`);
        
        if (totalElement) {
            totalElement.textContent = `${total}%`;
            totalElement.style.color = total > 100 ? '#e74c3c' : '#2c3e50';
        }
        
        if (remainingElement) {
            const remaining = 100 - total;
            remainingElement.textContent = remaining >= 0 ? `${remaining}% remaining` : `${Math.abs(remaining)}% over`;
            remainingElement.style.color = remaining >= 0 ? '#27ae60' : '#e74c3c';
        }
    }
    
    // Removed - plant allocation is now done in the main app
    addAllocationRow_removed(bedNum) {
        const container = document.querySelector(`#plant-allocation-container .allocation-bed:nth-child(${bedNum}) .allocation-crops`);
        const rowCount = container.querySelectorAll('.allocation-row').length + 1;
        
        // Clone the first row's select options
        const firstSelect = container.querySelector('select');
        const newRow = document.createElement('div');
        newRow.className = 'allocation-row';
        newRow.innerHTML = `
            <select class="modern-select" id="bed-${bedNum}-crop-${rowCount}">
                ${firstSelect.innerHTML}
            </select>
            <input type="number" class="modern-input" placeholder="%" min="0" max="100" id="bed-${bedNum}-alloc-${rowCount}">
            <button type="button" class="btn-danger-small" onclick="app.removeAllocationRow(${bedNum}, ${rowCount})" style="padding: 0.5rem; border-radius: 4px; background: #e74c3c; color: white; border: none; cursor: pointer;">‚úï</button>
        `;
        container.appendChild(newRow);
        
        // Add event listener to the new input
        const newInput = document.getElementById(`bed-${bedNum}-alloc-${rowCount}`);
        if (newInput) {
            newInput.addEventListener('input', () => this.updateAllocationSummary(bedNum));
        }
    }
    
    // Removed - plant allocation is now done in the main app
    removeAllocationRow_removed(bedNum, rowNum) {
        const container = document.querySelector(`#plant-allocation-container .allocation-bed:nth-child(${bedNum}) .allocation-crops`);
        const rows = container.querySelectorAll('.allocation-row');
        
        // Don't remove if it's the only row
        if (rows.length <= 1) {
            this.showNotification('Cannot remove the last allocation row', 'warning');
            return;
        }
        
        // Find and remove the specific row
        rows.forEach((row, index) => {
            const rowNumber = index + 1;
            if (rowNumber === rowNum) {
                row.remove();
            }
        });
        
        // Update the summary
        this.updateAllocationSummary(bedNum);
    }
    
    async showAddCustomCropDialog(bedNum) {
        // Create modal overlay
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.justifyContent = 'center';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        modalContent.style.maxWidth = '400px';
        modalContent.style.padding = '2rem';
        
        modalContent.innerHTML = `
            <h3 style="color: #2e3192; margin-bottom: 1rem;">Add Custom Crop</h3>
            <div class="form-field">
                <label class="modern-label">
                    <span class="label-icon">üåø</span>
                    <span class="label-text">Crop Name</span>
                </label>
                <input type="text" id="custom-crop-name-input" class="modern-input" 
                       placeholder="e.g., Cherry Tomatoes" autofocus>
            </div>
            <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem; justify-content: flex-end;">
                <button type="button" class="btn-secondary" id="cancel-custom-crop">Cancel</button>
                <button type="button" class="btn-primary" id="save-custom-crop">Add Crop</button>
            </div>
        `;
        
        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);
        
        // Focus the input
        setTimeout(() => {
            document.getElementById('custom-crop-name-input')?.focus();
        }, 100);
        
        // Use CustomCropHandler for save functionality
        if (this.customCropHandler) {
            this.customCropHandler.attachSimpleCropListeners(modalOverlay);
        } else {
            // Fallback for initialization timing issues
            console.warn('CustomCropHandler not available, using fallback');
            const saveHandler = async () => {
                const cropName = document.getElementById('custom-crop-name-input')?.value.trim();
                if (!cropName) {
                    this.showNotification('Please enter a crop name', 'warning');
                    return;
                }
                
                try {
                    const response = await this.makeApiCall('/plants/custom-crops', {
                        method: 'POST',
                        body: JSON.stringify({
                            cropName: cropName,
                            systemId: this.activeSystemId || this.systemWizardData.systemId || null
                        })
                    });
                    
                    if (response) {
                        this.showNotification(`Custom crop "${cropName}" added successfully!`, 'success');
                        modalOverlay.remove();
                        
                        // Refresh the plant allocation section
                        await this.updatePlantAllocationFields();
                    }
                } catch (error) {
                    console.error('Error adding custom crop:', error);
                    this.showNotification('Failed to add custom crop. Please try again.', 'error');
                }
            };
            
            // Event listeners with defensive checks
            const saveCropBtn = document.getElementById('save-custom-crop');
            const cancelCropBtn = document.getElementById('cancel-custom-crop');
            const cropNameInput = document.getElementById('custom-crop-name-input');
            
            if (saveCropBtn) saveCropBtn.addEventListener('click', saveHandler);
            if (cancelCropBtn) cancelCropBtn.addEventListener('click', () => modalOverlay.remove());
            if (cropNameInput) {
                cropNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') saveHandler();
                });
            }
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) modalOverlay.remove();
            });
        }
    }
    
    setupNewSystemModal() {
        // Close button handler
        const closeBtn = document.getElementById('close-new-system-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.closeNewSystemModal());
        }
        
        // Prevent closing when clicking outside modal (force use of X button)
        const modal = document.getElementById('new-system-modal');
        if (modal) {
            modal.addEventListener('click', (e) => {
                // Prevent modal from closing when clicking outside
                e.stopPropagation();
            });
        }
        
        // Form submission handler
        const form = document.getElementById('new-system-form');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                if (!this.validateCurrentStep()) return;
                
                // Collect all wizard data
                const systemData = {
                    system_name: document.getElementById('new-system-name').value,
                    system_type: document.getElementById('new-system-type').value,
                    fish_tank_count: parseInt(document.getElementById('new-fish-tank-count').value),
                    grow_bed_count: parseInt(document.getElementById('new-grow-bed-count').value)
                };
                
                // Collect fish tank details
                systemData.fish_tanks = [];
                let totalFishVolume = 0;
                for (let i = 1; i <= systemData.fish_tank_count; i++) {
                    const tankVolume = parseFloat(document.getElementById(`tank-volume-${i}`).value);
                    totalFishVolume += tankVolume;
                    systemData.fish_tanks.push({
                        name: document.getElementById(`tank-name-${i}`).value,
                        volume: tankVolume,
                        fish_type: document.getElementById(`tank-fish-${i}`).value,
                        stocking_density: parseFloat(document.getElementById(`tank-stocking-${i}`).value),
                        target_harvest_weight: parseFloat(document.getElementById(`tank-harvest-${i}`).value)
                    });
                }
                systemData.total_fish_volume = totalFishVolume;
                
                // Collect grow bed details - get data directly from form since wizard data might be empty

                systemData.grow_beds = [];
                let totalGrowArea = 0;
                
                for (let i = 1; i <= systemData.grow_bed_count; i++) {
                    const bedType = document.getElementById(`bed-type-${i}`)?.value;
                    const bedName = document.getElementById(`bed-name-${i}`)?.value || `Bed ${i}`;
                    
                    // Try to get saved data first, then collect directly from form fields
                    let savedBed = this.systemWizardData.growBeds?.[i-1] || {};
                    
                    // If no saved data, collect directly from current form fields
                    if (!savedBed || Object.keys(savedBed).length === 0) {

                        savedBed = this.collectBedDataFromForm(i, bedType);
                    }

                    // Calculate area based on bed type and dimensions
                    let bedArea = 0;
                    let bedVolume = 0;
                    if (bedType && savedBed) {
                        const metrics = this.calculateBedMetricsForSaving(bedType, savedBed);
                        bedArea = metrics.area;
                        bedVolume = metrics.volume;

                    }
                    
                    totalGrowArea += bedArea;
                    const bedData = {
                        name: bedName,
                        type: bedType,
                        area: bedArea,
                        volume: bedVolume,
                        ...savedBed // Include all the dimensional data
                    };

                    systemData.grow_beds.push(bedData);
                }
                systemData.total_grow_area = totalGrowArea;
                
                // Skip allocations - will redirect to allocation tab
                systemData.allocations = [];
                
                await this.createNewSystem(systemData);
                this.closeNewSystemModal();
                
                // Show notification and redirect to allocation tab
                this.showNotification('‚úÖ System created successfully! Now let\'s set up your crop allocations.', 'success');
                
                // Switch to settings tab and then to allocation sub-tab
                setTimeout(() => {
                    // Switch to settings view
                    this.currentView = 'settings';
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('settings').classList.add('active');
                    const settingsBtn = document.querySelector('[data-view="settings"]');
                    if (settingsBtn) {
                        settingsBtn.classList.add('active');
                    }
                    
                    // Trigger click on allocation tab
                    const allocationTab = document.querySelector('[data-setting="plant-allocations"]');
                    if (allocationTab) {
                        allocationTab.click();
                    }
                }, 500);
            });
        }
    }

    // Create demo system by copying Oribi 1 data
    async createDemoSystem(systemName) {
        try {
            
            // Call the new API endpoint to copy Oribi 1 data
            const response = await this.makeApiCall('/systems/create-demo', {
                method: 'POST',
                body: JSON.stringify({
                    system_name: systemName || 'Oribi 1 Demo System',
                    user_id: this.userId
                })
            });
            
            
            // Check if response is just a message (server-side issue)
            if (response && response.message && !response.id) {
                console.error('Demo system API returned message instead of system object:', response);
                throw new Error(`Server Error: The demo system API is not properly implemented. Expected system object with ID, got: ${response.message}. Please check the /systems/create-demo endpoint implementation.`);
            }
            
            // Ensure the response has an ID
            if (!response || !response.id) {
                console.error('Demo system response missing ID:', response);
                throw new Error('Invalid demo system response - missing ID field');
            }
            
            return response;
            
        } catch (error) {
            console.error('Failed to create demo system:', error);
            throw error;
        }
    }

    async createDemoSystemAndFinish() {
        try {
            const systemName = document.getElementById('new-system-name').value.trim() || 'Oribi 1 Demo System';
            
            // Close the new system modal and show loading modal
            this.closeNewSystemModal();
            this.showDemoLoadingModal();
            
            // Create the demo system with progress tracking
            const demoSystem = await this.createDemoSystemWithProgress(systemName);
            
            // Validate the demo system response
            if (!demoSystem || !demoSystem.id) {
                throw new Error('Invalid demo system created - missing ID');
            }
            
            
            // Update systems list
            this.systems[demoSystem.id] = demoSystem;
            this.updateSystemSelector();
            
            // Switch to the new demo system and refresh all data
            this.updateProgress(90, 'Refreshing application data...');
            await this.switchToSystem(demoSystem.id);
            await this.forceRefreshAllData();
            
            // Navigate to dashboard and update all data
            this.updateProgress(95, 'Opening dashboard with fresh data...');
            this.navigateToDashboard();
            await this.updateDashboardData();
            
            // Complete the process
            this.updateProgress(100, 'Demo system ready!');
            
            // Wait a moment to show completion, then close modal
            setTimeout(() => {
                this.hideDemoLoadingModal();
                
                // Success notification removed - progress modal provides sufficient feedback
                // Users will see the demo system immediately after the modal closes
            }, 1500);
            
        } catch (error) {
            console.error('Failed to create demo system:', error);
            this.hideDemoLoadingModal();
            
            // Check if it's the known server-side API issue
            if (error.message && error.message.includes('Server Error: The demo system API')) {
                this.showNotification('üîß Demo system feature is currently being updated. The API endpoint needs to be fixed on the server. Please try creating a custom system instead, or contact support.', 'error');
            } else if (error.message && error.message.includes('Reference demo system not available')) {
                this.showNotification('üìã Demo system template is missing from the database. Please contact support to initialize the demo system data.', 'error');
            } else if (error.message && error.message.includes('Database constraint error')) {
                this.showNotification('üîó Database constraint issue during demo system creation. This may be due to missing reference data or schema differences.', 'error');
            } else if (error.message && error.message.includes('Database connection error')) {
                this.showNotification('üîå Database connection issue. Please try again in a moment.', 'error');
            } else {
                // Generic error - provide debugging info
                this.showNotification(`‚ùå Failed to create demo system: ${error.message}. Please try creating a custom system instead, or contact support if this persists.`, 'error');
            }
        }
    }

    // Demo Loading Modal Methods
    showDemoLoadingModal() {
        const modal = document.getElementById('demo-loading-modal');
        if (modal) {
            modal.classList.add('show');
            // Reset progress
            this.updateProgress(0, 'Initializing demo system creation...');
            this.markStepActive('step-system');
        }
    }

    hideDemoLoadingModal() {
        const modal = document.getElementById('demo-loading-modal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    updateProgress(percentage, text) {
        const progressFill = document.getElementById('demo-progress-fill');
        const progressText = document.getElementById('demo-progress-text');
        
        if (progressFill) {
            progressFill.style.width = `${percentage}%`;
        }
        
        if (progressText) {
            progressText.textContent = text;
        }
    }

    markStepActive(stepId) {
        // Clear all active/completed states
        const steps = document.querySelectorAll('.loading-step');
        steps.forEach(step => {
            step.classList.remove('active', 'completed');
        });
        
        // Mark current step as active
        const currentStep = document.getElementById(stepId);
        if (currentStep) {
            currentStep.classList.add('active');
        }
    }

    markStepCompleted(stepId) {
        const step = document.getElementById(stepId);
        if (step) {
            step.classList.remove('active');
            step.classList.add('completed');
        }
    }

    async createDemoSystemWithProgress(systemName) {
        // Step 1: Initialize
        this.updateProgress(10, 'Creating system structure...');
        this.markStepActive('step-system');
        await this.delay(300);

        // Step 2: Call the actual API
        this.updateProgress(20, 'Importing sample data from SQLite...');
        const demoSystem = await this.createDemoSystem(systemName);
        
        // Step 3-8: Simulate progress through the import steps
        const steps = [
            { id: 'step-tanks', progress: 30, text: 'Setting up fish tanks...', delay: 400 },
            { id: 'step-beds', progress: 40, text: 'Configuring grow beds...', delay: 350 },
            { id: 'step-water', progress: 55, text: 'Importing water quality data...', delay: 600 },
            { id: 'step-nutrients', progress: 65, text: 'Loading nutrient readings...', delay: 400 },
            { id: 'step-fish', progress: 72, text: 'Adding fish health records...', delay: 350 },
            { id: 'step-plants', progress: 78, text: 'Importing plant data...', delay: 300 },
            { id: 'step-spray', progress: 85, text: 'Setting up spray programmes...', delay: 250 }
        ];

        for (const step of steps) {
            this.markStepCompleted(steps[steps.indexOf(step) - 1]?.id || 'step-system');
            this.markStepActive(step.id);
            this.updateProgress(step.progress, step.text);
            await this.delay(step.delay);
        }

        // Final step
        this.markStepCompleted('step-spray');
        this.markStepActive('step-complete');

        return demoSystem;
    }

    async forceRefreshAllData() {
        // Force refresh all application data
        
        try {
            // Load all data records
            await this.loadDataRecords();
            
            // Update all overview sections
            await this.updatePlantOverview();
            await this.loadFishOverview();
            
            // Update growth beds
            await this.updateGrowBeds();
            
        } catch (error) {
            console.error('‚ö†Ô∏è Error during data refresh:', error);
            // Don't throw - just log the error so the demo system creation completes
        }
    }

    async updateDashboardData() {
        // Specifically update dashboard data and charts
        
        try {
            // Reinitialize and update dashboard charts with fresh data
            await this.initializeCharts();
            
            // Update dashboard from data
            if (typeof this.updateDashboardFromData === 'function') {
                await this.updateDashboardFromData();
            }
            
            // Force update water quality metrics
            if (typeof this.updateWaterQualityMetrics === 'function') {
                await this.updateWaterQualityMetrics();
            }
            
            // Update any other dashboard-specific elements
            if (typeof this.updateDashboardStats === 'function') {
                await this.updateDashboardStats();
            }
            
        } catch (error) {
            console.error('‚ö†Ô∏è Error during dashboard update:', error);
            // Don't throw - just log the error so the demo system creation completes
        }
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Data Capture Save Modal Methods
    showDataSaveModal(dataType = 'data') {
        const modal = document.getElementById('data-save-modal');
        if (modal) {
            modal.classList.add('show');
            // Update header based on data type
            const header = modal.querySelector('.modal-header h2');
            if (header) {
                const typeMap = {
                    'plant': 'Saving Plant Data',
                    'fish': 'Saving Fish Data',
                    'water': 'Saving Water Quality',
                    'nutrient': 'Saving Nutrient Data',
                    'spray': 'Saving Spray Application',
                    'data': 'Saving Data'
                };
                header.textContent = typeMap[dataType] || 'Saving Data';
            }
            // Reset progress
            this.updateSaveProgress(0, 'Preparing data...');
            this.markSaveStepActive('save-step-validate');
        }
    }

    hideDataSaveModal() {
        const modal = document.getElementById('data-save-modal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    updateSaveProgress(percentage, text) {
        const progressFill = document.getElementById('save-progress-fill');
        const progressText = document.getElementById('save-progress-text');
        
        if (progressFill) {
            progressFill.style.width = `${percentage}%`;
        }
        
        if (progressText) {
            progressText.textContent = text;
        }
    }

    markSaveStepActive(stepId) {
        // Clear all active/completed states for save steps
        const steps = document.querySelectorAll('.save-step');
        steps.forEach(step => {
            step.classList.remove('active', 'completed');
        });
        
        // Mark current step as active
        const currentStep = document.getElementById(stepId);
        if (currentStep) {
            currentStep.classList.add('active');
        }
    }

    markSaveStepCompleted(stepId) {
        const step = document.getElementById(stepId);
        if (step) {
            step.classList.remove('active');
            step.classList.add('completed');
        }
    }

    async performSaveWithProgress(dataType, saveFunction) {
        try {
            // Show save modal
            this.showDataSaveModal(dataType);
            
            // Step 1: Validate
            this.updateSaveProgress(20, 'Validating form data...');
            await this.delay(200);
            
            // Step 2: Process
            this.markSaveStepCompleted('save-step-validate');
            this.markSaveStepActive('save-step-process');
            this.updateSaveProgress(40, 'Processing information...');
            await this.delay(300);
            
            // Step 3: Save (call actual save function)
            this.markSaveStepCompleted('save-step-process');
            this.markSaveStepActive('save-step-save');
            this.updateSaveProgress(60, 'Saving to database...');
            
            const result = await saveFunction();
            
            // Step 4: Refresh
            this.markSaveStepCompleted('save-step-save');
            this.markSaveStepActive('save-step-refresh');
            this.updateSaveProgress(80, 'Refreshing displays...');
            await this.delay(200);
            
            // Step 5: Complete
            this.markSaveStepCompleted('save-step-refresh');
            this.markSaveStepActive('save-step-complete');
            this.updateSaveProgress(100, 'Save complete!');
            
            // Wait a moment to show completion
            await this.delay(800);
            
            // Hide modal
            this.hideDataSaveModal();
            
            return result;
            
        } catch (error) {
            console.error('Save operation failed:', error);
            this.hideDataSaveModal();
            throw error;
        }
    }

    async createNewSystem(systemData) {
        const systemId = 'system_' + Date.now();
        
        // Extract additional configuration data for later processing
        const { fish_tanks, grow_beds, allocations, ...basicSystemData } = systemData;
        
        const newSystem = {
            id: systemId,
            ...basicSystemData,
            fish_type: fish_tanks[0]?.fish_type || 'tilapia', // Use first tank's fish type as default
            total_grow_volume: systemData.total_grow_area * 200 // Estimate grow bed volume from area
        };

        try {
            const createdSystem = await this.makeApiCall('/systems', {
                method: 'POST',
                body: JSON.stringify(newSystem)
            });

            this.systems[systemId] = createdSystem;
            this.updateSystemSelector();
            
            // Switch to the new system
            await this.switchToSystem(systemId);
            
            // Save fish tank configuration
            if (fish_tanks && fish_tanks.length > 0) {
                try {
                    // Create each tank individually
                    for (let i = 0; i < fish_tanks.length; i++) {
                        const tank = fish_tanks[i];
                        await this.makeApiCall('/fish-tanks', {
                            method: 'POST',
                            body: JSON.stringify({
                                system_id: systemId,
                                tank_number: i + 1,
                                size_m3: tank.volume / 1000, // Convert liters to m¬≥
                                volume_liters: tank.volume,
                                fish_type: tank.fish_type === 'carp' ? 'other' : tank.fish_type,
                                name: tank.name,
                                stocking_density: tank.stocking_density,
                                target_harvest_weight: tank.target_harvest_weight
                            })
                        });
                    }
                } catch (error) {
                    console.error('Failed to save fish tank configuration:', error);
                }
            }
            
            // Save grow bed configuration
            if (grow_beds && grow_beds.length > 0) {
                try {

                    // Use GrowBedDataProcessor to handle transformation
                    if (this.growBedDataProcessor) {
                        const result = await this.growBedDataProcessor.saveGrowBedsData(grow_beds, systemId);
                    } else {
                        // Fallback: Transform grow beds data for API
                        const growBedsData = grow_beds.map((bed, index) => {
                            // Calculate volume if not already set
                            let volume = bed.volume || 0;
                            if (bed.type && !volume) {
                                const metrics = this.calculateBedMetricsForSaving(bed.type, bed);
                                volume = metrics.volume;
                            }
                            
                            const transformedBed = {
                                bed_number: index + 1,
                                bed_type: bed.type,
                                bed_name: bed.name || `Bed ${index + 1}`,
                                volume_liters: Math.round(volume),
                                area_m2: bed.area || 0,
                                length_meters: bed.length || null,
                                width_meters: bed.width || null,
                                height_meters: bed.height || null,
                                plant_capacity: bed.plantCapacity || null,
                                vertical_count: bed.verticals || null,
                                plants_per_vertical: bed.plantsPerVertical || null,
                                equivalent_m2: bed.area || 0, // Use area as equivalent_m2
                                reservoir_volume: bed.reservoirVolume || null,
                                trough_length: bed.troughLength || null,
                                trough_count: bed.channels || null, // Fix field name
                                plant_spacing: bed.plantSpacing || null,
                                reservoir_volume_liters: bed.reservoirVolume || null
                            };

                            return transformedBed;
                        });

                        const result = await this.makeApiCall(`/grow-beds/system/${systemId}`, {
                            method: 'POST',
                            body: JSON.stringify({
                                growBeds: growBedsData
                            })
                        });
                    }

                    this.showNotification('‚úÖ Grow bed configuration saved successfully', 'success');
                } catch (error) {
                    console.error('Failed to save grow bed configuration:', error);
                    this.showNotification('‚ùå Failed to save grow bed configuration: ' + (error.message || 'Unknown error'), 'error');
                }
            } else {

            }
            
            // Get the created grow bed IDs first
            let createdBedIds = [];
            if (grow_beds && grow_beds.length > 0) {
                if (this.growBedDataProcessor) {
                    createdBedIds = await this.growBedDataProcessor.processCreatedBedIds(grow_beds, systemId);
                } else {
                    // Fallback: Direct API call
                    try {
                        const growBedsResponse = await this.makeApiCall(`/grow-beds/system/${systemId}`);
                        createdBedIds = growBedsResponse.map(bed => ({ 
                            bedNumber: bed.bed_number, 
                            id: bed.id 
                        }));
                    } catch (error) {
                        console.error('Failed to fetch created grow beds:', error);
                    }
                }
            }
            
            // Save plant allocations if provided
            if (allocations && allocations.length > 0 && createdBedIds.length > 0) {
                try {
                    // Create each allocation individually
                    for (const allocation of allocations) {
                        // Find the actual grow bed ID from the created beds
                        const bedInfo = createdBedIds.find(bed => bed.bedNumber === allocation.grow_bed_id);
                        if (bedInfo) {
                            await this.makeApiCall('/plants/allocations', {
                                method: 'POST',
                                body: JSON.stringify({
                                    systemId: systemId,
                                    growBedId: bedInfo.id,
                                    cropType: allocation.crop_type,
                                    percentageAllocated: allocation.allocation_percentage,
                                    plantsPlanted: 0,
                                    datePlanted: new Date().toISOString().split('T')[0]
                                })
                            });
                        }
                    }
                } catch (error) {
                    console.error('Failed to save plant allocations:', error);
                }
            }
            
            // Skip creating default spray programmes - let users add their own as needed

            // Redirect to settings to review/modify configuration
            this.goToSettings();
            this.showNotification(`System "${systemData.system_name}" created successfully!`, 'success');
        } catch (error) {
            console.error('Failed to create system:', error);
            this.showNotification('‚ùå Failed to create system. Please try again.', 'error');
        }
    }

    async deleteSystem(systemId) {
        if (Object.keys(this.systems).length <= 1) {
            this.showNotification('‚ö†Ô∏è Cannot delete the last system. You must have at least one system.', 'warning');
            return;
        }

        const system = this.systems[systemId];
        if (confirm(`Are you sure you want to delete system "${system.system_name}"? This will also delete all associated data.`)) {
            try {
                await this.makeApiCall(`/systems/${systemId}`, { method: 'DELETE' });
                
                delete this.systems[systemId];
                
                // If this was the active system, switch to another one
                if (this.activeSystemId === systemId) {
                    const remainingSystems = Object.keys(this.systems);
                    await this.switchToSystem(remainingSystems.length > 0 ? remainingSystems[0] : '');
                }
                
                this.updateSystemSelector();
                this.loadSystemManagement();
                this.showNotification('System deleted successfully.', 'success');
            } catch (error) {
                console.error('Failed to delete system:', error);
                this.showNotification('‚ùå Failed to delete system. Please try again.', 'error');
            }
        }
    }

    loadSystemConfig() {
        const activeSystem = this.getActiveSystem();
        return activeSystem || {
            system_name: 'No System Selected',
            system_type: 'media-bed',
            fish_type: 'tilapia',
            fish_tank_count: 1,
            total_fish_volume: 1000,
            grow_bed_count: 4,
            total_grow_volume: 800
        };
    }

    async saveSystemConfig() {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select or create a system first.', 'warning');
            return;
        }

        // Calculate total fish volume from individual tanks
        const tankItems = document.querySelectorAll('.fish-tank-item');
        let totalFishVolumeL = 0;
        tankItems.forEach(item => {
            const sizeInput = item.querySelector('.tank-size');
            if (sizeInput && sizeInput.value) {
                const sizeM3 = parseFloat(sizeInput.value) || 0;
                totalFishVolumeL += sizeM3 * 1000; // Convert m¬≥ to liters
            }
        });

        // Calculate total grow bed volume
        const totalGrowVolumeL = await this.calculateTotalGrowBedVolume();
        
        const config = {
            system_name: document.getElementById('system-name').value || 'My Aquaponics System',
            system_type: document.getElementById('system-type-config').value,
            fish_tank_count: parseInt(document.getElementById('fish-tank-count').value) || 1,
            total_fish_volume: totalFishVolumeL || 1000,
            grow_bed_count: parseInt(document.getElementById('grow-bed-count').value) || 4,
            total_grow_volume: totalGrowVolumeL || 800,
            total_grow_area: parseFloat(document.getElementById('total-grow-area').value) || 2.0
        };

        try {
            const updatedSystem = await this.makeApiCall(`/systems/${this.activeSystemId}`, {
                method: 'PUT',
                body: JSON.stringify(config)
            });

            // Save grow bed configuration
            await this.saveGrowBedConfiguration();
            
            // Save fish tank configuration
            await this.saveFishTankConfiguration();
            
            // Recalculate and update the system's total fish volume after individual tanks are saved
            const tankItems = document.querySelectorAll('.fish-tank-item');
            let actualTotalFishVolumeL = 0;
            tankItems.forEach(item => {
                const sizeInput = item.querySelector('.tank-size');
                if (sizeInput && sizeInput.value) {
                    const sizeM3 = parseFloat(sizeInput.value) || 0;
                    actualTotalFishVolumeL += sizeM3 * 1000; // Convert m¬≥ to liters
                }
            });
            
            // Update the system data with the recalculated total
            if (actualTotalFishVolumeL !== updatedSystem.total_fish_volume) {
                updatedSystem.total_fish_volume = actualTotalFishVolumeL;
                // Save the updated total back to the API
                const finalSystemUpdate = await this.makeApiCall(`/systems/${this.activeSystemId}`, {
                    method: 'PUT',
                    body: JSON.stringify({
                        ...config,
                        total_fish_volume: actualTotalFishVolumeL
                    })
                });
                this.systems[this.activeSystemId] = finalSystemUpdate;
            } else {
                this.systems[this.activeSystemId] = updatedSystem;
            }
            this.updateSystemSelector(); // Update dropdown with new name
            this.updateCurrentSystemDisplay(); // Update system name on all tabs
            
            // Reload the grow bed configuration to show saved values
            await this.loadGrowBedConfiguration();
            
            // Reload the fish tank configuration to show saved values
            await this.loadFishTankConfiguration();
            
            // Refresh fish management data to reflect tank changes
            await this.loadDataRecords();
            
            // Refresh fish management views
            if (document.getElementById('tank-information-tab').classList.contains('active')) {
                this.loadTankInformation();
            }
            if (document.getElementById('fish-overview-tab').classList.contains('active')) {
                await this.loadFishOverview();
            }
            
            // Always update the fish tank summary to reflect volume changes
            await this.updateFishTankSummary();
            
            this.showNotification('‚öôÔ∏è System configuration saved successfully!', 'success');
            
            // Refresh calculators and forms with new system data
            this.initializeNutrientCalculator();
            this.initializeFishCalculator();
            this.initializeDataEntryForms(); // Refresh forms including fish health tank selector
        } catch (error) {
            console.error('Failed to save system config:', error);
            this.showNotification('‚ùå Failed to save system configuration. Please try again.', 'error');
        }
    }

    async loadSystemManagement() {
        this.loadSystemConfigToForm();
        this.displaySystemsList();
        this.displayGrowBedStatus();
        
        // Only load configurations if we have an active system
        if (this.activeSystemId && this.activeSystemId !== 'undefined') {
            await this.loadGrowBedConfiguration(); // Load grow bed configuration form
            await this.loadFishTankConfiguration(); // Load fish tank configuration form
            await this.updateReservoirVolume();
        }
    }

    loadSystemConfigToForm() {
        const activeSystem = this.getActiveSystem();
        if (activeSystem) {
            document.getElementById('system-name').value = activeSystem.system_name;
            document.getElementById('system-type-config').value = activeSystem.system_type;
            document.getElementById('fish-tank-count').value = activeSystem.fish_tank_count || 1;
            document.getElementById('total-fish-volume').value = activeSystem.total_fish_volume || 1000;
            document.getElementById('grow-bed-count').value = activeSystem.grow_bed_count || 4;
            document.getElementById('total-grow-area').value = activeSystem.total_grow_area || 2.0;
            
            // Update the auto-calculated grow bed volume display
            this.updateTotalGrowBedVolume();
            
            // Load grow bed configuration
            this.loadGrowBedConfiguration();
            
            // Initialize fish tank configuration
            const tankCount = activeSystem.fish_tank_count || 1;
            this.generateFishTankConfiguration(tankCount);
            this.loadFishTankConfiguration();
            
            // Update display fields
            this.updateSettingsDisplayFields();
        } else {
            // Clear form if no system selected
            document.getElementById('system-name').value = '';
            document.getElementById('system-type-config').value = 'media-bed';
            document.getElementById('fish-tank-count').value = '1';
            document.getElementById('total-fish-volume').value = '';
            document.getElementById('grow-bed-count').value = '4';
            document.getElementById('total-grow-area').value = '';
            
            // Clear the auto-calculated grow bed volume display
            const displayElement = document.getElementById('total-grow-volume-display');
            if (displayElement) {
                displayElement.textContent = 'Auto-calculated: 0 L';
                displayElement.style.color = '#6c757d';
            }
            
            // Initialize default fish tank configuration
            this.generateFishTankConfiguration(1);
        }
    }

    displaySystemsList() {
        // Find or create systems list container
        let systemsListContainer = document.getElementById('systems-list-container');
        if (!systemsListContainer) {
            systemsListContainer = document.createElement('div');
            systemsListContainer.id = 'systems-list-container';
            
            // Insert after system configuration section
            const systemConfigSection = document.querySelector('.form-section');
            systemConfigSection.parentNode.insertBefore(systemsListContainer, systemConfigSection.nextSibling);
        }

        systemsListContainer.innerHTML = `
            <div class="form-section">
                <h3>Manage Systems</h3>
                <div class="systems-list">
                    ${Object.keys(this.systems).length === 0 ? 
                        '<p style="text-align: center; color: #666;">No systems created yet. Click "+ Add System" to create your first system.</p>' :
                        Object.keys(this.systems).map(systemId => {
                            const system = this.systems[systemId];
                            const isActive = systemId === this.activeSystemId;
                            return `
                                <div class="system-item ${isActive ? 'active' : ''}" data-system-id="${systemId}">
                                    <div class="system-info">
                                        <h4>${system.system_name} ${isActive ? '(Active)' : ''}</h4>
                                        <p>Type: ${system.system_type} | Fish: <img src="/icons/new-icons/Afraponix Go Icons_fish.svg" alt="Fish" style="width: 1em; height: 1em; vertical-align: middle;"> ${this.fishData[system.fish_type]?.name || system.fish_type}</p>
                                        <p>Tanks: ${(system.total_fish_volume / 1000).toFixed(1)}m¬≥ | Grow Beds: ${system.total_grow_volume}L</p>
                                        <small>Created: ${this.formatDateDDMMYYYY(new Date(system.created_at))}</small>
                                    </div>
                                    <div class="system-actions">
                                        ${!isActive ? `<button class="form-btn" onclick="app.switchToSystem('${systemId}')">Switch To</button>` : ''}
                                        <button class="form-btn" onclick="app.deleteSystem('${systemId}')" style="background: #dc3545;">Delete</button>
                                    </div>
                                </div>
                            `;
                        }).join('')
                    }
                </div>
            </div>
        `;
    }

    initializeNutrientCalculator() {
        // Just initialize the hydroponic dosing calculator - the HTML is already in place
        setTimeout(() => {
            this.initializeHydroponicDosingCalculator();
            // Update reservoir volume when calculator initializes
            this.updateReservoirVolumeFromSystem();
        }, 100);
    }

    goToSettings() {
        // Switch to settings view
        const navButtons = document.querySelectorAll('.nav-btn');
        const views = document.querySelectorAll('.view');
        
        navButtons.forEach(b => b.classList.remove('active'));
        views.forEach(v => v.classList.remove('active'));
        
        document.getElementById('settings-btn').classList.add('active');
        document.getElementById('settings').classList.add('active');
        
        this.currentView = 'settings';
        
        // Load system management data including grow bed configuration
        this.loadSystemManagement();
    }

    // Legacy methods - keeping for compatibility but they won't be used with new calculator

    // Hydroponic dosing calculator methods
    initializeHydroponicDosingCalculator() {
        this.preloadedNutrients = [
            {
                id: 1,
                name: "General Hydroponics Shiman",
                n: 5.0, p: 1.0, k: 6.0, ca: 4.0, mg: 1.5, fe: 0.1,
                price: 35.00
            },
            {
                id: 2,
                name: "Calcium Nitrate",
                n: 15.5, p: 0.0, k: 0.0, ca: 19.0, mg: 0.0, fe: 0.0,
                price: 18.50
            },
            {
                id: 3,
                name: "Iron Micromix",
                n: 0.0, p: 0.0, k: 0.0, ca: 0.0, mg: 0.0, fe: 6.0,
                price: 45.00
            },
            {
                id: 4,
                name: "Magnesium Sulphate",
                n: 0.0, p: 0.0, k: 0.0, ca: 0.0, mg: 9.7, fe: 0.0,
                price: 12.00
            },
            {
                id: 5,
                name: "Mono Potassium Phosphate",
                n: 0.0, p: 22.8, k: 28.7, ca: 0.0, mg: 0.0, fe: 0.0,
                price: 25.00
            },
            {
                id: 6,
                name: "Calcium Chloride",
                n: 0.0, p: 0.0, k: 0.0, ca: 27.0, mg: 0.0, fe: 0.0,
                price: 15.00
            },
            {
                id: 7,
                name: "Potassium Chloride",
                n: 0.0, p: 0.0, k: 52.4, ca: 0.0, mg: 0.0, fe: 0.0,
                price: 20.00
            }
        ];


        // Core water quality parameters for aquaponics
        this.systemParameters = {
            pH: { optimal_min: 6.4, optimal_max: 7.0, critical_min: 6.0, critical_max: 7.5 },
            ec: { optimal_min: 1000, optimal_max: 3000, unit: "¬µS/cm" },
            salinity: { optimal_min: 1.0, optimal_max: 1.5, critical_max: 2.0, unit: "ppt" },
            dissolved_oxygen: { warm_fish: 4, cold_fish: 6, unit: "ppm" },
            ammonia: { safe_max: 0.1, toxic_threshold: 0.75, unit: "mg/L" },
            nitrite: { safe_max: 0.1, toxic_threshold: 0.75, unit: "mg/L" },
            nitrate: { optimal_min: 5, optimal_max: 80, unit: "mg/L" },
            temperature: { optimal_min: 18, optimal_max: 23, unit: "¬∞C" }
        };

        // Nutrient deficiency diagnostic framework
        this.deficiencyDiagnostic = {
            mobile_nutrients: {
                list: ["nitrate", "phosphorus", "potassium", "magnesium", "sulfur", "chlorine"],
                symptom_location: "older_leaves_first",
                description: "Plant can relocate these nutrients from old to new growth when deficient"
            },
            immobile_nutrients: {
                list: ["calcium", "iron", "boron", "zinc", "copper", "manganese", "molybdenum"],
                symptom_location: "new_leaves_first", 
                description: "Once incorporated, cannot be moved within plant"
            },
            deficiency_treatments: {
                iron: {
                    symptoms: ["Yellowing between veins on NEW leaves", "Veins remain green", "Interveinal chlorosis"],
                    treatments: [
                        { name: "Chelated Iron (DTPA)", dosage: "1.5-2.0 mg/L", frequency: "Weekly", notes: "Effective when pH ‚â§ 7.5" },
                        { name: "Chelated Iron (EDDHA)", dosage: "1.5-2.0 mg/L", frequency: "Weekly", notes: "More stable at higher pH" },
                        { name: "Foliar Iron Spray", dosage: "0.5 g/L", frequency: "2x weekly", notes: "Fast-acting relief" }
                    ]
                },
                potassium: {
                    symptoms: ["Brown scorching on leaf edges", "Weak stems", "Poor flowering", "Affects older leaves first"],
                    treatments: [
                        { name: "Potassium Sulfate (K‚ÇÇSO‚ÇÑ)", dosage: "20-35 mg/L K", frequency: "Weekly", notes: "Also provides sulfur" },
                        { name: "Potassium Hydroxide (KOH)", dosage: "As needed for pH", frequency: "As needed", notes: "pH buffer + K source" },
                        { name: "Foliar Potassium Spray", dosage: "2-3 g/L K‚ÇÇSO‚ÇÑ", frequency: "2x weekly", notes: "Effective for herbs" }
                    ]
                },
                calcium: {
                    symptoms: ["Distorted new growth", "Blossom end rot", "Tip burn in leafy greens", "Affects new growth first"],
                    treatments: [
                        { name: "Calcium Sulfate (Gypsum)", dosage: "20-15 mg/L Ca", frequency: "Bi-weekly", notes: "Most effective treatment" },
                        { name: "Calcium Chloride Spray", dosage: "4 tsp/gallon water", frequency: "Weekly", notes: "Fast-acting foliar" },
                        { name: "Crushed Oyster Shell", dosage: "50-100g per 1000L", frequency: "Monthly", notes: "Slow-release natural source" }
                    ]
                },
                magnesium: {
                    symptoms: ["Yellowing between veins on OLD leaves", "Affects older growth first", "Reduced chlorophyll"],
                    treatments: [
                        { name: "Magnesium Sulfate (Epsom Salt)", dosage: "10 mg/L Mg", frequency: "Every 3 weeks", notes: "Standard Mg treatment" },
                        { name: "Foliar Magnesium Spray", dosage: "1-2 g/L Epsom salt", frequency: "Weekly", notes: "Fast-acting relief" }
                    ]
                },
                phosphorus: {
                    symptoms: ["Reddish or purple leaves", "Delayed flowering", "Poor root development", "Affects older leaves first"],
                    treatments: [
                        { name: "Monopotassium Phosphate (KH‚ÇÇPO‚ÇÑ)", dosage: "10-28 mg/L P", frequency: "Weekly", notes: "Provides both P and K" },
                        { name: "Fish Bone Meal", dosage: "20-50g per 1000L", frequency: "Monthly", notes: "Slow-release organic" }
                    ]
                },
                nitrate: {
                    symptoms: ["General yellowing of older leaves", "Stunted growth", "Pale appearance"],
                    treatments: [
                        { name: "Increase Fish Stocking", dosage: "Target 7+ kg/m¬≥", frequency: "Gradual", notes: "Minimum for adequate nutrients" },
                        { name: "Increase Feeding Rate", dosage: "2-3% body weight", frequency: "Daily", notes: "More feed = more waste" },
                        { name: "Seaweed Extract", dosage: "1-2 ml/L", frequency: "Weekly", notes: "Organic nitrate boost" }
                    ]
                }
            }
        };

        // Weekly supplementation program
        this.supplementationSchedule = {
            iron: { dosage: 1.5, frequency: "Weekly", form: "DTPA or EDDHA with trace elements", unit: "mg/L" },
            potassium: { 
                vegetative: 20, 
                fruiting: 35, 
                frequency: "Weekly", 
                form: "Potassium sulfate or potassium silicate",
                unit: "mg/L"
            },
            calcium: { 
                vegetative: 20, 
                fruiting: 15, 
                frequency: "Bi-weekly", 
                form: "Calcium sulfate (gypsum)",
                unit: "mg/L"
            },
            magnesium: { dosage: 10, frequency: "Every 3 weeks", form: "Magnesium sulfate (Epsom salt)", unit: "mg/L" }
        };

        this.customNutrients = JSON.parse(localStorage.getItem('custom_nutrients') || '[]');
        this.setupDosingTabs();
        this.loadAvailableNutrients();
        this.displayMaintenanceSchedule();
        this.loadCurrentNutrientLevels();
        
        // Set reservoir volume from system configuration
        this.updateReservoirVolumeFromSystem();
    }

    async updateReservoirVolumeFromSystem() {
        const systemConfig = this.loadSystemConfig();
        let tankVolume = systemConfig.total_fish_volume || 0;
        
        // Check if we need to fetch actual tank configurations for correct volume
        if (systemConfig.id) {
            try {
                // Get actual fish tank volumes
                const tankResponse = await fetch(`/api/fish-tanks/system/${systemConfig.id}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                    }
                });
                
                if (tankResponse.ok) {
                    const tanksResponse = await tankResponse.json();
                    // Extract tanks array from response object
                    const tanks = tanksResponse.tanks || tanksResponse;
                    if (tanks && tanks.length > 0) {
                        // Calculate actual total volume from individual tanks
                        tankVolume = tanks.reduce((sum, tank) => {
                            // Use volume_liters directly, or convert size_m3 to liters
                            if (tank.volume_liters) {
                                return sum + parseFloat(tank.volume_liters);
                            } else if (tank.size_m3) {
                                return sum + (parseFloat(tank.size_m3) * 1000);
                            }
                            return sum;
                        }, 0);
                    } else {
                        // If no individual tanks, check if total_fish_volume needs conversion
                        // 7 tanks √ó 7m¬≥ = 49m¬≥ = 49000L
                        // If total_fish_volume is 7000, it might be a data entry error
                        if (systemConfig.fish_tank_count === 7 && tankVolume === 7000) {
                            // Assume 7m¬≥ per tank if we have 7 tanks
                            tankVolume = 7 * 7 * 1000; // 7 tanks √ó 7m¬≥ √ó 1000L/m¬≥
                        }
                    }
                } else {
                    console.error('Failed to fetch tanks:', tankResponse.statusText);
                }
            } catch (error) {
                console.error('Error loading tank configurations:', error);
            }
        }
        
        // Load grow bed configuration if we have an active system
        let growBedVolume = 0;
        
        if (systemConfig.id) {
            try {
                const response = await fetch(`/api/grow-beds/system/${systemConfig.id}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                    }
                });
                
                if (response.ok) {
                    const growBedData = await response.json();
                    
                    // growBedData is directly an array
                    if (Array.isArray(growBedData)) {
                        // First try to use explicit reservoir volumes
                        growBedData.forEach(bed => {
                            if (bed.reservoir_volume_liters) {
                                growBedVolume += parseFloat(bed.reservoir_volume_liters);
                            }
                        });
                        
                        // If no reservoir volumes are set, estimate based on grow bed area
                        // Typical grow bed depth is 30cm with 60% water space after media = ~180L per m¬≤
                        if (growBedVolume === 0) {
                            growBedData.forEach(bed => {
                                if (bed.equivalent_m2) {
                                    // More conservative estimate: 150L per m¬≤ (30cm depth * 0.5 water factor)
                                    // This accounts for media displacement
                                    const bedWaterVolume = parseFloat(bed.equivalent_m2) * 150;
                                    growBedVolume += bedWaterVolume;
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading grow bed configuration:', error);
            }
        }
        
        // Total reservoir volume = tank volume + grow bed water volume
        const totalReservoirVolume = tankVolume + growBedVolume;
        
        // Update the reservoir volume field
        const reservoirField = document.getElementById('reservoir-volume');
        if (reservoirField) {
            reservoirField.value = Math.round(totalReservoirVolume);
            
            // Update the help text to show breakdown
            const helpText = reservoirField.nextElementSibling;
            if (helpText && helpText.tagName === 'SMALL') {
                helpText.innerHTML = `Tank: ${tankVolume}L + Grow Beds: ${Math.round(growBedVolume)}L = Total: ${Math.round(totalReservoirVolume)}L`;
            }
        }
    }
    
    setupDosingTabs() {
        const tabs = document.querySelectorAll('.dosing-tab');
        const contents = document.querySelectorAll('.dosing-content');

        if (tabs.length === 0) {

            return;
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));

                // Add active class to clicked tab
                tab.classList.add('active');

                // Show corresponding content
                const contentId = tab.id.replace('-tab', '-content');
                const content = document.getElementById(contentId);
                if (content) {
                    content.classList.add('active');
                }
            });
        });

        // Setup crop change listener
        const cropSelect = document.getElementById('crop-type');
        if (cropSelect) {
            cropSelect.addEventListener('change', this.updateTargetValues.bind(this));
        }

        // Setup tab listeners to refresh data when switching to calculator
        const calcTab = document.getElementById('nutrient-calc-tab');
        if (calcTab) {
            calcTab.addEventListener('click', () => {
                setTimeout(() => {
                    this.updateReservoirVolumeFromSystem();
                    this.loadCurrentNutrientLevels();
                }, 100);
            });
        }
    }

    updateTargetValues() {
        const crop = document.getElementById('crop-type').value;
        const targetEcField = document.getElementById('target-ec');
        const targetDisplay = document.getElementById('target-values-display');

        if (!crop || !this.cropTargets[crop]) {
            targetDisplay.innerHTML = '<p style="text-align: center; color: #666;">Select crop to view target nutrient levels</p>';
            targetEcField.value = '';
            return;
        }

        const targets = this.cropTargets[crop];
        targetEcField.value = targets.ec;

        targetDisplay.innerHTML = `
            <h4>üêü Aquaponics Target Values for ${crop.charAt(0).toUpperCase() + crop.slice(1)}</h4>
            <p style="font-size: 0.85rem; color: #666; margin-bottom: 12px; font-style: italic;">
                Optimized for aquaponics systems with fish waste nutrient supplementation
            </p>
            <div class="target-values-grid">
                <div class="target-value-item">
                    <div class="target-value-label">N</div>
                    <div class="target-value-amount">${targets.n} ppm</div>
                </div>
                <div class="target-value-item">
                    <div class="target-value-label">P</div>
                    <div class="target-value-amount">${targets.p} ppm</div>
                </div>
                <div class="target-value-item">
                    <div class="target-value-label">K</div>
                    <div class="target-value-amount">${targets.k} ppm</div>
                </div>
                <div class="target-value-item">
                    <div class="target-value-label">Ca</div>
                    <div class="target-value-amount">${targets.ca} ppm</div>
                </div>
                <div class="target-value-item">
                    <div class="target-value-label">Mg</div>
                    <div class="target-value-amount">${targets.mg} ppm</div>
                </div>
                <div class="target-value-item">
                    <div class="target-value-label">Fe</div>
                    <div class="target-value-amount">${targets.fe} ppm</div>
                </div>
            </div>
            <div class="crop-parameters" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div><strong>pH Range:</strong> ${targets.ph_min} - ${targets.ph_max}</div>
                    <div><strong>EC Target:</strong> ${targets.ec} mS/cm</div>
                </div>
                ${targets.notes ? `<div style="font-size: 0.85rem; color: #555; font-style: italic;">üí° ${targets.notes}</div>` : ''}
            </div>
        `;
        
        // Load saved current nutrient levels when crop changes
        this.loadCurrentNutrientLevels();
    }

    calculateHydroponicDosing() {
        const crop = document.getElementById('crop-type').value;
        const reservoirVolume = parseFloat(document.getElementById('reservoir-volume').value);

        if (!crop) {
            this.showNotification('üå± Please select a crop type first.', 'warning');
            return;
        }

        if (!reservoirVolume || reservoirVolume <= 0) {
            this.showNotification('üíß Please enter a valid reservoir volume.', 'warning');
            return;
        }

        const targets = this.cropTargets[crop];
        
        // Get current nutrient levels
        const currentLevels = {
            n: parseFloat(document.getElementById('current-n').value) || 0,
            p: parseFloat(document.getElementById('current-p').value) || 0,
            k: parseFloat(document.getElementById('current-k').value) || 0,
            ca: parseFloat(document.getElementById('current-ca').value) || 0,
            mg: parseFloat(document.getElementById('current-mg').value) || 0,
            fe: parseFloat(document.getElementById('current-fe').value) || 0
        };
        
        // Calculate what's needed (target minus current)
        const needed = {
            n: Math.max(0, targets.n - currentLevels.n),
            p: Math.max(0, targets.p - currentLevels.p),
            k: Math.max(0, targets.k - currentLevels.k),
            ca: Math.max(0, targets.ca - currentLevels.ca),
            mg: Math.max(0, targets.mg - currentLevels.mg),
            fe: Math.max(0, targets.fe - currentLevels.fe)
        };

        const allNutrients = [...this.preloadedNutrients, ...this.customNutrients];
        
        // Calculate optimal nutrient combination based on what's needed
        const dosingPlan = this.optimizeNutrientMix(needed, reservoirVolume, allNutrients);
        
        this.displayDosingResults(dosingPlan, targets, reservoirVolume, currentLevels);
        
        // Switch to mixing schedule tab after calculation
        this.switchToMixingScheduleTab();
    }

    optimizeNutrientMix(targets, volume, availableNutrients) {
        // Simplified optimization algorithm
        const selectedNutrients = [];
        const remaining = { ...targets };

        // Priority order for nutrient fulfillment
        const elementPriority = ['n', 'k', 'p', 'ca', 'mg', 'fe'];

        elementPriority.forEach(element => {
            if (remaining[element] <= 0) return;

            // Find best nutrient for this element
            const suitable = availableNutrients
                .filter(nutrient => nutrient[element] > 0)
                .sort((a, b) => b[element] - a[element]);

            if (suitable.length > 0) {
                const nutrient = suitable[0];
                const needed = remaining[element];
                const concentration = nutrient[element] / 100; // Convert percentage to decimal
                const amount = (needed * volume) / (concentration * 1000); // grams needed

                selectedNutrients.push({
                    nutrient: nutrient,
                    amount: Math.round(amount * 10) / 10, // Round to 1 decimal
                    cost: (amount / 1000) * nutrient.price
                });

                // Reduce remaining requirements based on this nutrient's contribution
                elementPriority.forEach(el => {
                    const contribution = (nutrient[el] / 100) * amount * 1000 / volume;
                    remaining[el] = Math.max(0, remaining[el] - contribution);
                });
            }
        });

        return selectedNutrients;
    }

    displayDosingResults(dosingPlan, targets, volume, currentLevels = null) {
        // Display results in the mixing schedule tab instead of quick calculator
        const resultsDiv = document.getElementById('dosing-results-display');
        
        if (dosingPlan.length === 0) {
            const hasCurrentLevels = currentLevels && Object.values(currentLevels).some(val => val > 0);
            if (hasCurrentLevels) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #80fb7d; font-weight: 600;">‚úÖ Your current nutrient levels are already sufficient for this crop!</p>';
            } else {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #999;">No suitable nutrient combination found.</p>';
            }
            resultsDiv.style.display = 'block';
            return;
        }

        let html = `
            <h4>Recommended Dosing Plan for Aquaponics</h4>
        `;

        // Show current vs target comparison if current levels provided
        if (currentLevels && Object.values(currentLevels).some(val => val > 0)) {
            html += `
                <div style="background: #f0f8ff; padding: 12px; border-radius: 6px; margin-bottom: 12px; border-left: 4px solid #7baaee;">
                    <h5>üìä Current vs Target Levels</h5>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; font-size: 0.85rem;">
                        <div><strong>N:</strong> ${currentLevels.n}‚Üí${targets.n} ppm</div>
                        <div><strong>P:</strong> ${currentLevels.p}‚Üí${targets.p} ppm</div>
                        <div><strong>K:</strong> ${currentLevels.k}‚Üí${targets.k} ppm</div>
                        <div><strong>Ca:</strong> ${currentLevels.ca}‚Üí${targets.ca} ppm</div>
                        <div><strong>Mg:</strong> ${currentLevels.mg}‚Üí${targets.mg} ppm</div>
                        <div><strong>Fe:</strong> ${currentLevels.fe}‚Üí${targets.fe} ppm</div>
                    </div>
                </div>
            `;
        }

        html += `<div class="dosing-results-grid">`;

        dosingPlan.forEach(item => {
            html += `
                <div class="dosing-result-card">
                    <div class="dosing-result-nutrient">${item.nutrient.name}</div>
                    <div class="dosing-result-amount">${item.amount}</div>
                    <div class="dosing-result-unit">grams</div>
                </div>
            `;
        });

        html += `
            </div>
            <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-top: 12px;">
                <p><strong>Reservoir Volume:</strong> ${volume}L</p>
                <p style="font-size: 0.9rem; color: #666; margin-top: 8px;">
                    <em>Dosing calculated for aquaponic system. Mix each nutrient separately to avoid precipitation.</em>
                </p>
            </div>
        `;

        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
        this.generateMixingSchedule(dosingPlan);
    }
    
    switchToMixingScheduleTab() {
        const mixingTab = document.getElementById('mixing-schedule-tab');
        const tabs = document.querySelectorAll('.dosing-tab');
        const contents = document.querySelectorAll('.dosing-content');
        
        if (mixingTab) {
            // Remove active class from all tabs and contents
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));
            
            // Activate mixing schedule tab
            mixingTab.classList.add('active');
            const content = document.getElementById('mixing-schedule-content');
            if (content) {
                content.classList.add('active');
            }
            
            // Auto-scroll to the top of the page
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // Show export options after results are displayed
            this.showExportOptions();
        }
    }

    generateMixingSchedule(dosingPlan) {
        const scheduleDiv = document.getElementById('mixing-schedule-display');
        
        if (dosingPlan.length === 0) {
            scheduleDiv.innerHTML = '<p style="text-align: center; color: #666;">No mixing schedule needed - your current levels are sufficient!</p>';
            return;
        }

        // Separate nutrients by compatibility
        const { week1Nutrients, week2Nutrients } = this.separateNutrientsByCompatibility(dosingPlan);
        
        let html = `
            <h4>üìÖ Two-Week Nutrient Addition Schedule</h4>
            <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin-bottom: 16px; border-left: 4px solid #ffc107;">
                <h5><img src="/icons/new-icons/Afraponix Go Icons_warning.svg" alt="Warning" class="heading-icon" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 0.25em;"> Important: Why Split Into Two Weeks?</h5>
                <p style="margin: 6px 0; font-size: 0.9rem;">
                    Some nutrients can cause precipitation (crystallization) when mixed together, making them unavailable to plants. 
                    This schedule separates incompatible nutrients to ensure maximum nutrient availability.
                </p>
            </div>
        `;

        // Week 1 nutrients
        if (week1Nutrients.length > 0) {
            html += `
                <div class="mixing-week-section">
                    <h5>üóìÔ∏è Week 1: Base Nutrients</h5>
                    <p style="font-size: 0.9rem; color: #666; margin-bottom: 12px;">
                        Add these nutrients first to establish base levels. These are generally compatible with each other.
                    </p>
            `;

            week1Nutrients.forEach((item, index) => {
                const isCalcium = item.nutrient.name.toLowerCase().includes('calcium');
                html += `
                    <div class="mixing-step">
                        <div class="mixing-step-header">
                            <div class="mixing-step-title">Day ${index + 1}: Add ${item.nutrient.name}</div>
                            <div class="mixing-step-time">${item.amount}g</div>
                        </div>
                        <div class="mixing-step-content">
                            ${isCalcium ? 
                                `ü•õ Dissolve ${item.amount}g in 200ml warm water. Add slowly while stirring to prevent cloudiness. Wait 2 hours before adding other nutrients.` :
                                `üíß Dissolve ${item.amount}g in 100-150ml warm water. Add to reservoir and stir gently. Wait 30 minutes before adding next nutrient.`
                            }
                        </div>
                    </div>
                `;
            });

            html += `</div>`;
        }

        // Week 2 nutrients
        if (week2Nutrients.length > 0) {
            html += `
                <div class="mixing-week-section" style="margin-top: 20px;">
                    <h5>üóìÔ∏è Week 2: Secondary Nutrients</h5>
                    <p style="font-size: 0.9rem; color: #666; margin-bottom: 12px;">
                        Add these nutrients in the second week to avoid precipitation with Week 1 nutrients.
                    </p>
            `;

            week2Nutrients.forEach((item, index) => {
                const isIron = item.nutrient.name.toLowerCase().includes('iron');
                html += `
                    <div class="mixing-step">
                        <div class="mixing-step-header">
                            <div class="mixing-step-title">Day ${index + 8}: Add ${item.nutrient.name}</div>
                            <div class="mixing-step-time">${item.amount}g</div>
                        </div>
                        <div class="mixing-step-content">
                            ${isIron ? 
                                `üî∂ Iron is sensitive to pH. Dissolve ${item.amount}g in 150ml cool water with a drop of citric acid. Add during low-light hours to prevent oxidation.` :
                                `üíß Dissolve ${item.amount}g in 100-150ml warm water. Add to reservoir and monitor for any cloudiness.`
                            }
                        </div>
                    </div>
                `;
            });

            html += `</div>`;
        }

        // Final monitoring steps
        html += `
            <div class="mixing-week-section" style="margin-top: 20px;">
                <h5>üìä Daily Monitoring</h5>
                <div class="mixing-step">
                    <div class="mixing-step-header">
                        <div class="mixing-step-title">Daily: Test & Adjust</div>
                        <div class="mixing-step-time">5 min</div>
                    </div>
                    <div class="mixing-step-content">
                        üß™ Test pH daily (keep 6.0-7.0 for aquaponics). Test EC weekly to monitor nutrient levels. 
                        Watch for precipitation (cloudiness) and fish behavior changes.
                    </div>
                </div>
            </div>

            <div style="background: #e8f5e8; padding: 12px; border-radius: 6px; margin-top: 16px; border-left: 4px solid #80fb7d;">
                <h5>‚úÖ Success Indicators</h5>
                <ul style="margin: 6px 0; padding-left: 16px; font-size: 0.9rem;">
                    <li>Water remains clear (no cloudiness or precipitation)</li>
                    <li>Fish continue normal feeding behavior</li>
                    <li>Plants show improved color and growth within 1-2 weeks</li>
                    <li>pH remains stable between 6.0-7.0</li>
                </ul>
            </div>
        `;

        scheduleDiv.innerHTML = html;
    }

    separateNutrientsByCompatibility(dosingPlan) {
        const week1Nutrients = [];
        const week2Nutrients = [];

        dosingPlan.forEach(item => {
            const nutrientName = item.nutrient.name.toLowerCase();
            
            // Week 1: Primary nutrients that are generally compatible
            if (nutrientName.includes('potassium') || 
                nutrientName.includes('magnesium') || 
                nutrientName.includes('general hydroponics') ||
                nutrientName.includes('npk')) {
                week1Nutrients.push(item);
            }
            // Week 2: Nutrients that can cause precipitation with others
            else if (nutrientName.includes('calcium') || 
                     nutrientName.includes('iron') || 
                     nutrientName.includes('phosphate')) {
                week2Nutrients.push(item);
            }
            // Default to week 1 for unknown nutrients
            else {
                week1Nutrients.push(item);
            }
        });

        return { week1Nutrients, week2Nutrients };
    }

    showDosingNotification(message, type = 'info', duration = 4000) {
        // Remove any existing notifications
        const existingNotification = document.querySelector('.dosing-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `dosing-notification dosing-notification-${type}`;
        
        // Set icon based on type
        let icon = '';
        switch (type) {
            case 'success':
                icon = '‚úÖ';
                break;
            case 'warning':
                icon = '‚ö†Ô∏è';
                break;
            case 'error':
                icon = '‚ùå';
                break;
            default:
                icon = '‚ÑπÔ∏è';
        }
        
        notification.innerHTML = `
            <span class="notification-icon">${icon}</span>
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        // Add to page
        const dosingContainer = document.querySelector('.dosing-content');
        if (dosingContainer) {
            dosingContainer.insertBefore(notification, dosingContainer.firstChild);
        }

        // Auto-remove after duration
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, duration);
    }

    showExportOptions() {
        // Add export buttons to the mixing schedule tab
        let exportDiv = document.getElementById('export-options');
        if (!exportDiv) {
            exportDiv = document.createElement('div');
            exportDiv.id = 'export-options';
            exportDiv.className = 'export-options-container';
            
            const mixingContent = document.getElementById('mixing-schedule-content');
            if (mixingContent) {
                mixingContent.appendChild(exportDiv);
            }
        }
        
        exportDiv.innerHTML = `
            <div style="background: #f8fafc; padding: 20px; border-radius: 10px; margin-top: 20px; border: 1px solid #e2e8f0;">
                <h4 style="margin: 0 0 15px 0; color: #1e293b;">üìÑ Export Nutrient Plan</h4>
                <p style="color: #64748b; margin-bottom: 15px; font-size: 0.9rem;">Save or share your complete nutrient dosing and mixing schedule</p>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <button onclick="app.exportToPDF()" class="export-btn pdf-btn">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" style="margin-right: 6px;">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                        </svg>
                        Save as PDF
                    </button>
                    <button onclick="app.emailNutrientPlan()" class="export-btn email-btn">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" style="margin-right: 6px;">
                            <path d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z"/>
                        </svg>
                        Email Plan
                    </button>
                    <button onclick="app.copyPlanToClipboard()" class="export-btn clipboard-btn">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" style="margin-right: 6px;">
                            <path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/>
                        </svg>
                        Copy to Clipboard
                    </button>
                </div>
            </div>
        `;
    }

    exportToPDF() {
        try {
            // Get the complete nutrient plan content
            const dosingResults = document.getElementById('dosing-results-display');
            const mixingSchedule = document.getElementById('mixing-schedule-display');
            
            if (!dosingResults || !mixingSchedule) {
                this.showNotification('‚ùå No nutrient plan available to export', 'error');
                return;
            }
            
            // Create a new window for PDF generation
            const printWindow = window.open('', '_blank');
            
            const currentDate = new Date().toLocaleDateString();
            const systemConfig = this.loadSystemConfig();
            const systemName = systemConfig.name || 'Aquaponics System';
            
            const htmlContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Nutrient Dosing Plan - ${systemName}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
                        h1, h2, h3, h4, h5 { color: #2d3748; margin-top: 20px; }
                        h1 { border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                        .header { text-align: center; margin-bottom: 30px; }
                        .system-info { background: #f7fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
                        .dosing-results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
                        .dosing-result-card { background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; text-align: center; }
                        .dosing-result-nutrient { font-weight: bold; color: #2d3748; margin-bottom: 8px; }
                        .dosing-result-amount { font-size: 1.5rem; font-weight: bold; color: #667eea; }
                        .dosing-result-unit { color: #64748b; font-size: 0.9rem; }
                        .mixing-step { background: #f8fafc; border-left: 4px solid #667eea; padding: 15px; margin: 10px 0; border-radius: 0 8px 8px 0; }
                        .mixing-step-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
                        .mixing-step-title { font-weight: bold; color: #2d3748; }
                        .mixing-step-time { color: #667eea; font-weight: bold; }
                        .mixing-step-content { color: #4a5568; }
                        .mixing-week-section { margin: 20px 0; }
                        .warning-box { background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin: 15px 0; }
                        .success-box { background: #e8f5e8; border-left: 4px solid #28a745; padding: 12px; margin: 15px 0; }
                        .page-break { page-break-before: always; }
                        @media print { 
                            body { margin: 0; font-size: 12px; }
                            .no-print { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>üå± Nutrient Dosing & Mixing Plan</h1>
                        <div class="system-info">
                            <p><strong>System:</strong> ${systemName}</p>
                            <p><strong>Generated:</strong> ${currentDate}</p>
                            <p><strong>Generated by:</strong> Afraponix Go - Aquaponics Management System</p>
                        </div>
                    </div>
                    
                    <div class="dosing-plan">
                        ${dosingResults.innerHTML}
                    </div>
                    
                    <div class="mixing-schedule page-break">
                        ${mixingSchedule.innerHTML}
                    </div>
                    
                    <div class="footer page-break" style="margin-top: 40px; text-align: center; color: #64748b; font-size: 0.9rem;">
                        <p>This nutrient plan was generated by Afraponix Go on ${currentDate}</p>
                        <p>Always monitor your system's pH, EC levels, and fish behavior when adding nutrients</p>
                        <p>For questions or support, consult your aquaponics system documentation</p>
                    </div>
                </body>
                </html>
            `;
            
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            
            // Wait for content to load, then trigger print dialog
            setTimeout(() => {
                printWindow.focus();
                printWindow.print();
            }, 500);
            
            this.showNotification('üìÑ PDF export initiated - use your browser\'s print dialog to save', 'success');
            
        } catch (error) {
            console.error('Error exporting to PDF:', error);
            this.showNotification('‚ùå Error exporting to PDF. Please try again.', 'error');
        }
    }

    async emailNutrientPlan() {
        try {
            // Get the nutrient plan content
            const dosingResults = document.getElementById('dosing-results-display');
            const mixingSchedule = document.getElementById('mixing-schedule-display');
            
            if (!dosingResults || !mixingSchedule || dosingResults.style.display === 'none') {
                this.showNotification('‚ùå No nutrient plan available to email. Calculate dosing first.', 'error');
                return;
            }
            
            this.showNotification('üìß Sending nutrient plan via email...', 'info');
            
            const currentDate = new Date().toLocaleDateString();
            const systemConfig = this.loadSystemConfig();
            const systemName = systemConfig.name || 'Aquaponics System';
            
            // Get form data
            const cropType = document.getElementById('crop-type').value;
            const reservoirVolume = document.getElementById('reservoir-volume').value;
            
            // Get dosing results
            const dosingCards = dosingResults.querySelectorAll('.dosing-result-card');
            let nutrientList = '';
            dosingCards.forEach(card => {
                const nutrientName = card.querySelector('.dosing-result-nutrient')?.textContent || 'Unknown';
                const amount = card.querySelector('.dosing-result-amount')?.textContent || '0';
                nutrientList += `‚Ä¢ ${nutrientName}: ${amount}g\n`;
            });
            
            // Get mixing schedule content (simplified)
            const mixingSteps = mixingSchedule.querySelectorAll('.mixing-step-title');
            let scheduleText = '';
            mixingSteps.forEach((step, index) => {
                scheduleText += `${index + 1}. ${step.textContent}\n`;
            });
            
            // Create email content
            const emailSubject = `Nutrient Dosing Plan - ${systemName} (${currentDate})`;
            const emailBody = `
<html>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
    <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
        <header style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: #2d3748; border-bottom: 3px solid #667eea; padding-bottom: 10px;">
                üå± Nutrient Dosing & Mixing Plan
            </h1>
            <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <p><strong>System:</strong> ${systemName}</p>
                <p><strong>Crop:</strong> ${cropType}</p>
                <p><strong>Reservoir Volume:</strong> ${reservoirVolume}L</p>
                <p><strong>Generated:</strong> ${currentDate}</p>
            </div>
        </header>
        
        <section style="margin: 30px 0;">
            <h2 style="color: #2d3748;">üìä Nutrients to Add</h2>
            <div style="background: #f8fafc; padding: 20px; border-radius: 8px; border-left: 4px solid #667eea;">
                <pre style="font-family: Arial; font-size: 14px; line-height: 1.8;">${nutrientList}</pre>
            </div>
        </section>
        
        <section style="margin: 30px 0;">
            <h2 style="color: #2d3748;">üìÖ Mixing Schedule</h2>
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                <h3 style="color: #856404; margin-top: 0;"><img src="/icons/new-icons/Afraponix Go Icons_warning.svg" alt="Warning" class="heading-icon" style="width: 1.2em; height: 1.2em; vertical-align: middle; margin-right: 0.5em;"> Important: Why Split Into Two Weeks?</h3>
                <p>Some nutrients can cause precipitation when mixed together. This schedule separates incompatible nutrients to ensure maximum availability.</p>
            </div>
            <pre style="background: #f8fafc; padding: 20px; border-radius: 8px; font-family: Arial; font-size: 14px; line-height: 1.8;">${scheduleText}</pre>
        </section>
        
        <section style="margin: 30px 0;">
            <h2 style="color: #2d3748;">‚ö†Ô∏è Important Instructions</h2>
            <ul style="background: #e8f5e8; padding: 20px; border-radius: 8px; border-left: 4px solid #28a745;">
                <li>Mix each nutrient separately to avoid precipitation</li>
                <li>Add nutrients over 2 weeks to prevent compatibility issues</li>
                <li>Week 1: Primary nutrients (NPK, Magnesium)</li>
                <li>Week 2: Secondary nutrients (Calcium, Iron)</li>
                <li>Monitor pH levels (keep between 6.0-7.0)</li>
                <li>Watch fish behavior after each addition</li>
                <li>Test water quality regularly</li>
            </ul>
        </section>
        
        <footer style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #64748b;">
            <p>This nutrient plan was generated by Afraponix Go on ${currentDate}</p>
            <p>Always monitor your system's pH, EC levels, and fish behavior when adding nutrients</p>
        </footer>
    </div>
</body>
</html>`;
            
            // Send email via API
            const result = await ConfigAPI.sendEmailConfig({
                subject: emailSubject,
                html: emailBody,
                type: 'nutrient_plan'
            });
            
            this.showNotification('‚úÖ Nutrient plan sent successfully to your email!', 'success');
            
        } catch (error) {
            console.error('Error sending email:', error);
            this.showNotification('‚ùå Failed to send email. Falling back to clipboard copy...', 'warning');
            // Fallback to clipboard copy
            await this.copyPlanToClipboard();
        }
    }

    async copyPlanToClipboard(subject = '', body = '') {
        try {
            const currentDate = new Date().toLocaleDateString();
            const systemConfig = this.loadSystemConfig();
            const systemName = systemConfig.name || 'Aquaponics System';
            
            // Get current form values
            const cropType = document.getElementById('crop-type').value;
            const reservoirVolume = document.getElementById('reservoir-volume').value;
            
            // Get dosing results
            const dosingResults = document.getElementById('dosing-results-display');
            const dosingCards = dosingResults.querySelectorAll('.dosing-result-card');
            let nutrientList = '';
            dosingCards.forEach(card => {
                const nutrientName = card.querySelector('.dosing-result-nutrient')?.textContent || 'Unknown';
                const amount = card.querySelector('.dosing-result-amount')?.textContent || '0';
                nutrientList += `- ${nutrientName}: ${amount}g\n`;
            });
            
            const planText = `NUTRIENT DOSING PLAN

System: ${systemName}
Crop: ${cropType}
Reservoir Volume: ${reservoirVolume}L
Generated: ${currentDate}

NUTRIENTS TO ADD:
${nutrientList}

IMPORTANT INSTRUCTIONS:
- Mix each nutrient separately to avoid precipitation
- Add nutrients over 2 weeks to prevent compatibility issues
- Week 1: Add primary nutrients (NPK, Magnesium)
- Week 2: Add secondary nutrients (Calcium, Iron)
- Monitor pH levels (keep between 6.0-7.0)
- Watch fish behavior after each addition
- Test water quality regularly

Generated by Afraponix Go - Aquaponics Management System`;

            await navigator.clipboard.writeText(planText);
            this.showNotification('üìã Nutrient plan copied to clipboard! You can paste it into any email.', 'success');
            
        } catch (error) {
            console.error('Clipboard copy failed:', error);
            this.showNotification('‚ùå Unable to copy to clipboard. Please manually copy the plan from the screen.', 'error');
        }
    }

    extractTextFromHTML(html) {
        // Create a temporary div to parse HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        // Remove script and style elements
        const scripts = tempDiv.querySelectorAll('script, style');
        scripts.forEach(el => el.remove());
        
        // Get text content and clean it up
        let text = tempDiv.textContent || tempDiv.innerText || '';
        
        // Clean up extra whitespace and line breaks
        text = text.replace(/\\s+/g, ' ').trim();
        text = text.replace(/\\n\\s*\\n/g, '\\n\\n');
        
        return text;
    }

    loadAvailableNutrients() {
        const listDiv = document.getElementById('available-nutrients-list');
        if (!listDiv) {

            return;
        }
        const allNutrients = [...this.preloadedNutrients, ...this.customNutrients];

        let html = '';
        allNutrients.forEach(nutrient => {
            const isCustom = !this.preloadedNutrients.find(p => p.id === nutrient.id);
            html += `
                <div class="nutrient-item">
                    <div class="nutrient-item-header">
                        <div class="nutrient-name">${nutrient.name}</div>
                        <div class="nutrient-price">$${nutrient.price}/kg</div>
                    </div>
                    <div class="nutrient-composition">
                        <div class="nutrient-element">
                            <div class="element-symbol">N</div>
                            <div class="element-percentage">${nutrient.n}%</div>
                        </div>
                        <div class="nutrient-element">
                            <div class="element-symbol">P</div>
                            <div class="element-percentage">${nutrient.p}%</div>
                        </div>
                        <div class="nutrient-element">
                            <div class="element-symbol">K</div>
                            <div class="element-percentage">${nutrient.k}%</div>
                        </div>
                        <div class="nutrient-element">
                            <div class="element-symbol">Ca</div>
                            <div class="element-percentage">${nutrient.ca}%</div>
                        </div>
                        <div class="nutrient-element">
                            <div class="element-symbol">Mg</div>
                            <div class="element-percentage">${nutrient.mg}%</div>
                        </div>
                        <div class="nutrient-element">
                            <div class="element-symbol">Fe</div>
                            <div class="element-percentage">${nutrient.fe}%</div>
                        </div>
                    </div>
                    ${isCustom ? `
                        <div class="nutrient-actions">
                            <button onclick="app.deleteCustomNutrient(${nutrient.id})">Delete</button>
                        </div>
                    ` : ''}
                </div>
            `;
        });

        listDiv.innerHTML = html;
    }

    addCustomNutrient() {
        const name = document.getElementById('nutrient-name').value.trim();
        const n = parseFloat(document.getElementById('nutrient-n').value) || 0;
        const p = parseFloat(document.getElementById('nutrient-p').value) || 0;
        const k = parseFloat(document.getElementById('nutrient-k').value) || 0;
        const ca = parseFloat(document.getElementById('nutrient-ca').value) || 0;
        const mg = parseFloat(document.getElementById('nutrient-mg').value) || 0;
        const fe = parseFloat(document.getElementById('nutrient-fe').value) || 0;
        const price = parseFloat(document.getElementById('nutrient-price').value) || 0;

        if (!name) {
            this.showNotification('üß™ Please enter a nutrient name.', 'warning');
            return;
        }

        if (n + p + k + ca + mg + fe === 0) {
            this.showNotification('üìä Please enter at least one nutrient percentage.', 'warning');
            return;
        }

        const newNutrient = {
            id: Date.now(),
            name: name,
            n: n, p: p, k: k, ca: ca, mg: mg, fe: fe,
            price: price
        };

        this.customNutrients.push(newNutrient);
        localStorage.setItem('custom_nutrients', JSON.stringify(this.customNutrients));

        // Clear form
        document.getElementById('nutrient-name').value = '';
        document.getElementById('nutrient-n').value = '';
        document.getElementById('nutrient-p').value = '';
        document.getElementById('nutrient-k').value = '';
        document.getElementById('nutrient-ca').value = '';
        document.getElementById('nutrient-mg').value = '';
        document.getElementById('nutrient-fe').value = '';
        document.getElementById('nutrient-price').value = '';

        this.loadAvailableNutrients();
        this.showNotification('‚úÖ Custom nutrient added successfully!', 'success');
    }

    deleteCustomNutrient(id) {
        // Show confirmation inline instead of using confirm dialog
        const nutrientName = this.customNutrients.find(n => n.id === id)?.name || 'nutrient';
        
        // Create confirmation notification
        const activeForm = document.querySelector('#custom-nutrients-content');
        if (!activeForm) return;

        const confirmationDiv = document.createElement('div');
        confirmationDiv.className = 'inline-notification inline-notification-warning';
        confirmationDiv.innerHTML = `
            <div class="inline-notification-content">
                <span class="inline-notification-icon">‚ö†Ô∏è</span>
                <span class="inline-notification-message">Delete "${nutrientName}"? This action cannot be undone.</span>
                <div style="display: flex; gap: 8px; margin-left: auto;">
                    <button class="form-btn secondary" style="padding: 4px 12px; font-size: 0.8rem;" onclick="this.closest('.inline-notification').remove()">Cancel</button>
                    <button class="form-btn" style="padding: 4px 12px; font-size: 0.8rem; background: #FF3B30;" onclick="app.confirmDeleteNutrient(${id}); this.closest('.inline-notification').remove()">Delete</button>
                </div>
            </div>
        `;
        
        // Remove any existing confirmation
        const existingConfirmation = activeForm.querySelector('.inline-notification');
        if (existingConfirmation) {
            existingConfirmation.remove();
        }
        
        activeForm.insertBefore(confirmationDiv, activeForm.firstChild);
    }

    confirmDeleteNutrient(id) {
        this.customNutrients = this.customNutrients.filter(n => n.id !== id);
        localStorage.setItem('custom_nutrients', JSON.stringify(this.customNutrients));
        this.loadAvailableNutrients();
        this.showNotification('Custom nutrient deleted successfully.', 'success', 2000);
    }

    displayMaintenanceSchedule() {
        const scheduleDiv = document.getElementById('maintenance-schedule-display');
        if (!scheduleDiv) {

            return;
        }
        
        scheduleDiv.innerHTML = `
            <div class="maintenance-item">
                <div class="maintenance-frequency">Daily</div>
                <div class="maintenance-task">
                    Monitor EC and pH levels. Check for nutrient lockout signs in plants.
                </div>
            </div>
            <div class="maintenance-item">
                <div class="maintenance-frequency">Weekly</div>
                <div class="maintenance-task">
                    Top up nutrients as needed (typically 25-50% of original dosing). 
                    Clean filters and check water circulation.
                </div>
            </div>
            <div class="maintenance-item">
                <div class="maintenance-frequency">Bi-weekly</div>
                <div class="maintenance-task">
                    Partial water change (25-30%). Check root health and clean growing media.
                </div>
            </div>
            <div class="maintenance-item">
                <div class="maintenance-frequency">Monthly</div>
                <div class="maintenance-task">
                    Complete nutrient solution change. Deep clean system components. 
                    Calibrate EC and pH meters.
                </div>
            </div>
        `;
    }

    // Current nutrient levels management
    saveCurrentNutrientLevels() {
        if (!this.activeSystemId) {
            this.showNotification('Please select a system first.', 'warning');
            return;
        }

        const currentLevels = {
            n: parseFloat(document.getElementById('current-n').value) || 0,
            p: parseFloat(document.getElementById('current-p').value) || 0,
            k: parseFloat(document.getElementById('current-k').value) || 0,
            ca: parseFloat(document.getElementById('current-ca').value) || 0,
            mg: parseFloat(document.getElementById('current-mg').value) || 0,
            fe: parseFloat(document.getElementById('current-fe').value) || 0,
            updated: new Date().toISOString()
        };

        const storageKey = `current_nutrients_${this.activeSystemId}`;
        localStorage.setItem(storageKey, JSON.stringify(currentLevels));
        
        this.showNotification('üíæ Current nutrient levels saved successfully!', 'success');
    }

    async loadCurrentNutrientLevels() {
        const systemConfig = this.loadSystemConfig();
        if (!systemConfig.id) {
            this.showNotification('‚ö†Ô∏è No active system selected', 'warning');
            return;
        }

        this.showNotification('üîÑ Loading latest nutrient data...', 'info', 2000);

        // First try to get the latest values from water quality data
        await this.loadNutrientsFromWaterQualityData();

        // Then load any manually saved values (these will override if they exist and are more recent)
        const storageKey = `current_nutrients_${systemConfig.id}`;
        const savedLevels = localStorage.getItem(storageKey);
        
        if (savedLevels) {
            const levels = JSON.parse(savedLevels);
            const savedDate = new Date(levels.updated || 0);
            
            // Only use manually saved values if they're more recent than water quality data
            const latestWaterQuality = this.getLatestWaterQualityData();
            const waterQualityDate = latestWaterQuality ? new Date(latestWaterQuality.date) : new Date(0);
            
            if (savedDate > waterQualityDate) {

                document.getElementById('current-n').value = levels.n || '';
                document.getElementById('current-p').value = levels.p || '';
                document.getElementById('current-k').value = levels.k || '';
                document.getElementById('current-ca').value = levels.ca || '';
                document.getElementById('current-mg').value = levels.mg || '';
                document.getElementById('current-fe').value = levels.fe || '';
                
                this.showNotification(`üìä Loaded manually saved nutrient levels from ${this.formatDateDDMMYYYY(savedDate)}`, 'success', 3000);
            }
        }
    }

    async loadNutrientsFromWaterQualityData() {
        const systemConfig = this.loadSystemConfig();
        if (!systemConfig.id) return;
        
        const token = localStorage.getItem('auth_token');
        if (!token) {

            this.showNotification('‚ö†Ô∏è Please log in to load nutrient data', 'warning');
            return;
        }
        
        try {

            // Use the same endpoint that charts use for nutrient data
            const response = await fetch(`${this.API_BASE}/data/nutrients/latest/${systemConfig.id}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error('Failed to fetch latest nutrient data');
            }
            
            const nutrientData = await response.json();
            
            // Check structure of all nutrient data
            if (nutrientData.nitrate) {
            }
            if (nutrientData.potassium) {
            }
            if (nutrientData.phosphorus) {
            }
            
            let waterQuality = nutrientData;
            
            // The nutrient endpoint returns an object with nutrient properties directly
            // No need to extract from array format
            if (waterQuality && typeof waterQuality === 'object') {
                let loadedCount = 0;
                
                // Nitrate/Nitrogen - Use the value directly (assuming it's already in correct form)
                // Check if nitrate is an object with a value property
                let nitrateValue = null;
                if (waterQuality.nitrate) {
                    if (typeof waterQuality.nitrate === 'object' && waterQuality.nitrate.value !== undefined) {
                        nitrateValue = parseFloat(waterQuality.nitrate.value);
                    } else if (typeof waterQuality.nitrate === 'number' || typeof waterQuality.nitrate === 'string') {
                        nitrateValue = parseFloat(waterQuality.nitrate);
                    }
                }
                
                if (nitrateValue !== null && !isNaN(nitrateValue)) {
                    // Use the nitrate value directly - no conversion needed
                    const nValue = nitrateValue.toFixed(1);
                    const nInput = document.getElementById('current-n');
                    if (nInput) {
                        nInput.value = nValue;
                    } else {
                        console.error('Could not find current-n input field');
                    }
                    loadedCount++;
                }
                
                // Phosphorus (P) - Direct from database
                let phosphorusValue = null;
                if (waterQuality.phosphorus) {
                    if (typeof waterQuality.phosphorus === 'object' && waterQuality.phosphorus.value !== undefined) {
                        phosphorusValue = parseFloat(waterQuality.phosphorus.value);
                    } else if (typeof waterQuality.phosphorus === 'number' || typeof waterQuality.phosphorus === 'string') {
                        phosphorusValue = parseFloat(waterQuality.phosphorus);
                    }
                }
                if (phosphorusValue !== null && !isNaN(phosphorusValue)) {
                    document.getElementById('current-p').value = phosphorusValue.toFixed(1);
                    loadedCount++;
                }
                
                // Potassium (K) - Direct from database
                let potassiumValue = null;
                if (waterQuality.potassium) {
                    if (typeof waterQuality.potassium === 'object' && waterQuality.potassium.value !== undefined) {
                        potassiumValue = parseFloat(waterQuality.potassium.value);
                    } else if (typeof waterQuality.potassium === 'number' || typeof waterQuality.potassium === 'string') {
                        potassiumValue = parseFloat(waterQuality.potassium);
                    }
                }
                if (potassiumValue !== null && !isNaN(potassiumValue)) {
                    document.getElementById('current-k').value = potassiumValue.toFixed(0);
                    loadedCount++;
                }
                
                // Calcium (Ca) - Direct from database
                let calciumValue = null;
                if (waterQuality.calcium) {
                    if (typeof waterQuality.calcium === 'object' && waterQuality.calcium.value !== undefined) {
                        calciumValue = parseFloat(waterQuality.calcium.value);
                    } else if (typeof waterQuality.calcium === 'number' || typeof waterQuality.calcium === 'string') {
                        calciumValue = parseFloat(waterQuality.calcium);
                    }
                }
                if (calciumValue !== null && !isNaN(calciumValue)) {
                    document.getElementById('current-ca').value = calciumValue.toFixed(0);
                    loadedCount++;
                }
                
                // Magnesium (Mg) - Direct from database
                let magnesiumValue = null;
                if (waterQuality.magnesium) {
                    if (typeof waterQuality.magnesium === 'object' && waterQuality.magnesium.value !== undefined) {
                        magnesiumValue = parseFloat(waterQuality.magnesium.value);
                    } else if (typeof waterQuality.magnesium === 'number' || typeof waterQuality.magnesium === 'string') {
                        magnesiumValue = parseFloat(waterQuality.magnesium);
                    }
                }
                if (magnesiumValue !== null && !isNaN(magnesiumValue)) {
                    document.getElementById('current-mg').value = magnesiumValue.toFixed(1);
                    loadedCount++;
                }
                
                // Iron (Fe) - Direct from database
                let ironValue = null;
                if (waterQuality.iron) {
                    if (typeof waterQuality.iron === 'object' && waterQuality.iron.value !== undefined) {
                        ironValue = parseFloat(waterQuality.iron.value);
                    } else if (typeof waterQuality.iron === 'number' || typeof waterQuality.iron === 'string') {
                        ironValue = parseFloat(waterQuality.iron);
                    }
                }
                if (ironValue !== null && !isNaN(ironValue)) {
                    document.getElementById('current-fe').value = ironValue.toFixed(1);
                    loadedCount++;
                }

                if (loadedCount > 0) {
                    this.showNotification(`üîÑ Loaded ${loadedCount} nutrient values from water quality data (${this.formatDateDDMMYYYY(new Date(waterQuality.date))})`, 'success', 3000);
                } else {
                    this.showNotification('üìä No nutrient values found in latest water quality data. Enter values manually as needed.', 'info', 4000);
                }
            } else {
                this.showNotification('üìä No recent water quality data found. Please enter values manually or add data in the Data Entry tab.', 'info', 4000);
            }
        } catch (error) {
            console.error('Error loading nutrient data from database:', error);
            this.showNotification('‚ö†Ô∏è Could not load nutrient data from database. Please enter values manually.', 'warning', 4000);
        }
    }

    showDataSourceInfo(waterQualityDate) {
        const currentSection = document.querySelector('.current-values-section');
        let infoDiv = currentSection.querySelector('.data-source-info');
        
        if (!infoDiv) {
            infoDiv = document.createElement('div');
            infoDiv.className = 'data-source-info';
            currentSection.querySelector('.current-values-grid').parentNode.insertBefore(infoDiv, currentSection.querySelector('.current-values-grid').nextSibling);
        }
        
        const date = this.formatDateDDMMYYYY(new Date(waterQualityDate));
        infoDiv.innerHTML = `
            <div style="background: #e8f4fd; padding: 8px 12px; border-radius: 4px; margin: 8px 0; font-size: 0.8rem; color: #334e9d; border-left: 3px solid #7baaee;">
                üìä Values auto-loaded from latest water quality data (${date}). You can override any values by typing new numbers and clicking "Save Current Levels".
            </div>
        `;
    }

    clearCurrentNutrientLevels() {
        document.getElementById('current-n').value = '';
        document.getElementById('current-p').value = '';
        document.getElementById('current-k').value = '';
        document.getElementById('current-ca').value = '';
        document.getElementById('current-mg').value = '';
        document.getElementById('current-fe').value = '';
        
        if (this.activeSystemId) {
            const storageKey = `current_nutrients_${this.activeSystemId}`;
            localStorage.removeItem(storageKey);
        }
        
        this.showNotification('Current nutrient levels cleared.', 'info');
    }

    // Grow bed management methods
    async updateGrowBedCount() {
        const bedCount = parseInt(document.getElementById('grow-bed-count').value) || 4;
        
        try {
            // First, save any existing configuration before regenerating the form
            if (document.querySelector('.grow-bed-item')) {
                await this.saveGrowBedConfiguration();
            }
            
            // Generate new form structure
            window.growBedManager.generateGrowBedConfiguration(bedCount);
            
            // Load existing data into the new form
            await this.loadGrowBedConfiguration();
            
            // Update display fields
            this.updateSettingsDisplayFields();
            
            this.showNotification('Grow bed configuration updated successfully!', 'success');
        } catch (error) {
            console.error('Failed to update grow bed configuration:', error);
            this.showNotification('‚ùå Failed to update grow bed configuration. Please try again.', 'error');
        }
    }

    updateSettingsDisplayFields() {
        // Update fish tank display fields
        const fishTankCount = document.getElementById('fish-tank-count')?.value || '1';
        const fishTankCountDisplay = document.getElementById('fish-tank-count-display');
        if (fishTankCountDisplay) {
            fishTankCountDisplay.textContent = fishTankCount;
        }

        // Update grow bed display fields
        const growBedCount = document.getElementById('grow-bed-count')?.value || '4';
        const growBedCountDisplay = document.getElementById('grow-bed-count-display');
        if (growBedCountDisplay) {
            growBedCountDisplay.textContent = growBedCount;
        }

        // Update total grow area display
        const totalGrowArea = document.getElementById('total-grow-area')?.value || '0';
        const totalGrowAreaDisplay = document.getElementById('total-grow-area-display');
        if (totalGrowAreaDisplay) {
            totalGrowAreaDisplay.textContent = `${parseFloat(totalGrowArea).toFixed(1)} m¬≤`;
        }

        // Update total fish volume (this method already updates the display)
        this.updateTotalFishVolume();
    }

    async updateFishTankCount() {
        const tankCount = parseInt(document.getElementById('fish-tank-count').value) || 1;
        
        try {
            // First, save any existing configuration before regenerating the form
            if (document.querySelector('.fish-tank-item')) {
                await this.saveFishTankConfiguration();
            }
            
            // Generate new form structure
            this.generateFishTankConfiguration(tankCount);
            
            // Load existing data into the new form
            await this.loadFishTankConfiguration();
            
            // Update display fields
            this.updateSettingsDisplayFields();
            
            this.showNotification('üêü Fish tank configuration updated successfully!', 'success');
        } catch (error) {
            console.error('Failed to update fish tank configuration:', error);
            this.showNotification('‚ùå Failed to update fish tank configuration. Please try again.', 'error');
        }
    }

    generateFishTankConfiguration(tankCount) {
        const container = document.getElementById('fish-tanks-container');
        if (!container) return;

        let html = `
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                <p style="margin: 0; color: #666; font-size: 0.9rem;">
                    <strong>‚ö†Ô∏è Important:</strong> Configure and save each fish tank before saving system configuration.
                    <br><strong>Size (m¬≥):</strong> Tank size in cubic meters for volume calculations
                    <br><strong>Fish Type:</strong> Type of fish in each tank for feeding and health calculations
                    <br><strong>Max Stocking Density:</strong> Optional tank-specific density limit (kg/m¬≥). Leave blank to use fish type default.
                </p>
            </div>
        `;

        for (let i = 1; i <= tankCount; i++) {
            html += this.generateFishTankItem(i);
        }

        container.innerHTML = html;
        this.updateTotalFishVolume();
    }

    generateFishTankItem(tankNumber) {
        return `
            <div class="fish-tank-item" data-tank="${tankNumber}">
                <div>
                    <h5>Fish Tank ${tankNumber}</h5>
                    <div class="form-field">
                        <label>Size (m¬≥):</label>
                        <input type="number" class="tank-size" min="0.1" max="50" step="0.1" placeholder="1.0" 
                               onchange="app.updateTotalFishVolume()" oninput="app.updateTankVolume(${tankNumber})">
                    </div>
                    <div class="form-field">
                        <label>Fish Type:</label>
                        <select class="fish-type">
                            <option value="">Select Fish Type</option>
                            <option value="tilapia"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;"><path d="m54.988 41.94366a70.19837 70.19837 0 0 1 -.81409-8.09222 70.18137 70.18137 0 0 1 .81415-8.09235.82984.82984 0 0 0 -1.13495-.88818l-8.77484 3.69257c-3.42117-3.79948-9.97561-6.22548-16.93307-6.22548-9.77 0-18.39685 4.90967-19.1452 10.6911h2.40961a.82254.82254 0 0 1 -.00006 1.64478h-2.40955c.74835 5.78137 9.37524 10.691 19.1452 10.691 6.95746 0 13.5119-2.426 16.933-6.23371l8.7749 3.70075a.82975.82975 0 0 0 1.1349-.88826zm-37.82168-10.14819a1.2337 1.2337 0 0 1 .00006-2.46716 1.2337 1.2337 0 0 1 -.00006 2.46716zm12.33588 6.34882a3.30529 3.30529 0 0 1 -3.28144 3.28949c-.36651.053-4.22149-.81372-4.67108-.88806a.82114.82114 0 0 1 -1.53784-.3866 27.35956 27.35956 0 0 0 .02454-12.418.82327.82327 0 1 1 1.612-.329 27.93369 27.93369 0 0 1 .65789 8.47882 46.883 46.883 0 0 1 4.334-1.89154c.0965-1.40936-.68182-1.23773-.329-2.17932a2.45171 2.45171 0 0 0 .04944-2.43421.82209.82209 0 0 1 -.04938-.85534 2.4518 2.4518 0 0 0 .04938-2.43421.82142.82142 0 0 1 1.34869-.9375 4.00913 4.00913 0 0 1 .2467 3.74182 4.12593 4.12593 0 0 1 0 3.28956 4.0171 4.0171 0 0 1 .31257 2.0971 2.45534 2.45534 0 0 1 1.23358 2.13825zm3.38824-4.30929a4.12652 4.12652 0 0 1 0 3.28955 4.13961 4.13961 0 0 1 -.19739 3.69251.82046.82046 0 1 1 -1.44744-.773 2.45173 2.45173 0 0 0 .04937-2.43427.822.822 0 0 1 -.04937-.85528 2.45173 2.45173 0 0 0 .04937-2.43427.822.822 0 0 1 -.04937-.85529 2.45168 2.45168 0 0 0 .04937-2.43426.82211.82211 0 0 1 -.04937-.85535 2.45158 2.45158 0 0 0 .04937-2.4342.82062.82062 0 0 1 .20557-1.14313c1.09613-.79718 2.34338 1.5622 1.38989 3.94745a4.1265 4.1265 0 0 1 0 3.28954zm4.73694 3.69251a.82058.82058 0 0 1 -1.44738-.77312 2.45169 2.45169 0 0 0 .04932-2.4342.82187.82187 0 0 1 -.04932-.85529 2.45175 2.45175 0 0 0 .04932-2.43426.82059.82059 0 0 1 .20563-1.14313c1.09332-.79889 2.3446 1.5647 1.38989 3.94745a4.13966 4.13966 0 0 1 -.19746 3.69251zm4.72052-1.64478a.82427.82427 0 0 1 -1.45563-.77307 2.45165 2.45165 0 0 0 .04932-2.4342.82809.82809 0 0 1 .20563-1.14313c1.12921-.84806 2.51056 1.82552 1.20068 4.35036zm8.02655 2.90308a21.66 21.66 0 0 1 -2.24512-.78949.82119.82119 0 0 1 .57563-1.53791l1.95727.73194a.82646.82646 0 0 1 -.28778 1.59542zm0-4.11194h-1.135a.82252.82252 0 0 1 0-1.64478h1.135a.82252.82252 0 0 1 0 1.64474zm.28778-4.4903a21.6413 21.6413 0 0 1 -2.24512.78955.82646.82646 0 0 1 -.28778-1.59546l1.95728-.73193a.82116.82116 0 0 1 .57562 1.5378z" fill="#0051b1"/><path d="m26.68964 35.67712-4.58075 2.12177c-.05756.38647-.11512.76483-.181 1.14313l3.95575.81408a1.65689 1.65689 0 0 0 1.97375-1.61181v-1.71875a.82791.82791 0 0 0 -1.16775-.74842z" fill="#0051b1"/><path d="m39.89722 23.037c-6.78473-5.46887-16.81794-6.35706-17.30316-6.3982a.80749.80749 0 0 0 -.87171.68256l-.72369 4.21887a30.11141 30.11141 0 0 1 7.14654-.847 29.66566 29.66566 0 0 1 11.75202 2.34377z" fill="#0051b1"/><path d="m32 2a30 30 0 1 0 30 30 30.03414 30.03414 0 0 0 -30-30zm0 58.29218a28.29221 28.29221 0 1 1 28.29224-28.29218 28.32516 28.32516 0 0 1 -28.29224 28.29218z" fill="#0051b1"/></svg> Tilapia</option>
                            <option value="trout"><svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 100 100" viewBox="0 0 100 100" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;"><path d="m54.96191 59.66748c-1.06738-.04834-4.33496-1.97461-6.31445-3.32666-.18408-.12549-.40771-.19287-.62744-.17236-.104.00635-10.49658.65918-16.03027.25049-2.98706-.2193-5.9267-.75238-8.91229-1.34186 1.31549-1.10309 3.2995-3.04572 3.80927-5.08441.56158-2.24603-.85437-4.50629-1.78333-5.69061 4.54456-1.39368 9.70428-2.93896 16.91223-3.05206.26562-.00439.51855-.11426.70361-.30518 3.12451-3.23096 7.41846-6.32471 8.58447-5.59668.02063.01288.04089.02795.06146.04108-1.77484 1.16016-3.79089 3.77069-4.53265 4.77753-.32727-.04553-.52832-.07349-.52832-.07349l-.27539 1.98047s9.58447 1.3335 12.00098 1.66699c.88135.12158 2.35498.24219 3.91504.37012 2.55859.20996 6.06348.49707 6.95947.82764.11132.041.22851.06151.3457.06151.11914 0 .23779-.021.35107-.06348 1.25146-.46924 3.50293-1.25488 4.21729-1.36475.5459-.08398.92041-.59424.83643-1.14014-.08398-.54639-.60156-.91797-1.14014-.83643-.98291.15088-3.39209 1.01709-4.29688 1.3501-1.25488-.32861-3.77881-.55469-7.10986-.82764-1.53174-.12549-2.97852-.24414-3.80469-.3584-.94812-.13086-3.00031-.41559-5.14307-.7132.87207-.92236 1.70776-1.66272 2.14917-1.89429.43439.54028.69775.91125.70532.92194.31641.45215.94141.56104 1.39258.24512.45215-.31689.56201-.93994.24561-1.39209-.1001-.14307-2.48242-3.52051-5.28955-5.2749-2.95898-1.85107-8.68555 3.47217-10.79248 5.60645-7.41016.17139-12.66748 1.78516-17.31641 3.21191-1.92383.59033-3.74072 1.14795-5.55615 1.55371-6.47803 1.44922-10.71924 4.71582-10.89697 4.854-.32764.25537-.46289.68701-.34033 1.08398.12305.39697.47852.67676.89307.70264.81885.05127 4.4209 1.26318 6.71729 2.10742.11377.04199.23047.06201.34521.06201.40723 0 .79004-.25098.93848-.65527.19043-.51855-.0752-1.09326-.59326-1.28369-.6333-.23291-2.94824-1.07471-4.86865-1.65479.78503-.46039 1.80908-1.00098 3.0116-1.53058.16705.64612.74878 1.12561 1.44714 1.12561.82843 0 1.5-.67157 1.5-1.5 0-.24835-.0661-.47913-.17297-.68542.77515-.25067 1.59387-.48102 2.45593-.67377 1.29089-.28894 2.57617-.65668 3.87842-1.04553.34869.37347 2.40753 2.68005 1.93311 4.57678-.4707 1.88428-3.18262 4.1333-4.18799 4.84131-.10693.0752-.19128.16974-.25867.27301-.38226-.06201-.75275-.13361-1.13879-.19391-2.27246-.35547-4.62207-.72266-6.64795-1.52393-.50098-.19775-.92773-.31982-1.30469-.42725-.65039-.18555-1.12012-.31982-1.72217-.77441-.44043-.33398-1.06885-.24512-1.40039.19531-.33301.44043-.24561 1.06738.19531 1.40039.89941.67969 1.65088.89404 2.37793 1.10205.33691.0957.69873.19824 1.11865.36426 2.23291.88232 4.69385 1.26758 7.07422 1.63965 1.00391.15674 1.99902.31201 2.96045.50342 3.28271.65479 6.50439 1.26221 9.83105 1.50635 5.16113.38281 14.07861-.11572 15.96191-.22803 1.30713.87598 5.21729 3.396 7.06592 3.47998.01562.00049.03076.00098.04639.00098.53125 0 .97363-.41846.99805-.95459.02489-.55173-.40187-1.01951-.95363-1.04441zm-4.18762-18.95288c-.58667-.08154-1.14447-.15906-1.66199-.23096 1.43713-1.80725 3.13007-3.53546 3.82471-3.66772.05853-.01117.10486-.04431.15869-.06476.31415.29108.61145.5896.89056.88403-.89031.57502-1.96044 1.60053-3.21197 3.07941z" fill="#0051b1"/></svg> Trout</option>
                            <option value="catfish"><svg xmlns="http://www.w3.org/2000/svg" id="Layer_2" viewBox="0 0 64 64" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;"><path d="m47.1155295 24.1677246c2.6532764.529534 5.044589 1.4316276 7.1071725 2.6807979.5403006.3273275 1.089329.7242869 1.6183534 1.1759708-.2118264-1.2184634-.5895462-2.4652766-1.2422262-3.1804533-1.813361-1.6640314-26.3839445-6.5062864-29.4265992-6.237697-1.2683462.1151189-1.9344047 1.5526713-2.2573363 2.6267743 5.9503139.0545333 13.8013314.8573712 24.2006359 2.9346073z" fill="#0051b1"/><path d="m33.9545424 31.9742526c-.1123298.5250399-.2545529 1.2942294-.4221916 2.4674375-.1074574.7522017.5920691 1.3611269 1.0176847 1.6561079 1.1030185.7658972 2.3482599.8817827 2.7823035.7711648.304726-1.1298828-.3281664-3.1553755-1.011627-4.604865-.7496996-.2088571-1.539169-.3019605-2.3661695-.2898452z" fill="#0051b1"/><path d="m11.576416 31.2006226c6.5237918 3.6058327 12.8864102 2.7625121 12.8140516-4.8353103 3.0488744-3.5109919 2.2919307 4.4495968-.8329725 7.5376418 3.2568571 2.1349583 7.913564-.7538779 11.4386558-1.2291121 4.4503433 1.2522076 10.0800679-.8130041 13.7398483 1.9389162 4.9116326-7.9367702-16.5277001-3.027739-18.7003735-2.9212553-4.1082576-1.817751 2.8982044-2.0975484 3.7204673-3.2954151 1.0409823-1.3424914-2.6439031-.9227009-3.635791-.5450525-5.5056777-2.1260204 7.9094262-4.4328407 5.7107526 1.0673607 4.588715-1.3431334 11.9827014-1.5430712 15.2460938 1.5915527 5.0143858-12.7196708 3.4850637 13.7859204-16.7236328 11.6218872 1.3293801 1.1420344 1.6478069 2.8973085 1.078125 4.5117188 7.3209905-2.4553212 16.855255-3.2807426 18.803833-7.5292358.0755414.3492258-15.3958173 8.6502329-12.5546226 3.3750429 21.8262046-4.9067795 19.5890925-15.0059387 5.6645264-18.710719-30.0851236-6.0076466-36.8751626-.6155568-38.2037759 1.0587596 7.3892591 6.4491261-6.2090201 1.3941353 2.4348145 6.3632202zm3.8191528-5.0973511c-1.5417271.0226149-1.5417777-2.3995156.0001074-2.3767025 1.5416197-.0226214 1.5416703 2.3995092-.0001074 2.3767025z" fill="#0051b1"/><path d="m45.4893617 33.8510638c-.5898836-.0692623-2.2686868-.3364663-3.7358922-.2695127-1.6119347.0724368-3.2369015.2002914-5.2553191.1914894.0008658.1201989.0113598.523322.0194404.6228865.5760311.1038934 1.5064541.2308742 2.240634.3313045 3.0436433.4171608 5.9693965.8265296 7.8585245 1.8886952.6289879-.4757451 1.2506166-.974722 1.8601245-1.5071756-1.0328734-.6235046-2.14713-1.1599985-2.987512-1.2576871z" fill="#0051b1"/><path d="m14.6230469 39.2182617c-.1254883 0-.2529297-.0239258-.3759766-.0742188-4.4770508-1.8198242-4.7314453-8.3725586-4.7402344-8.6503906-.0170898-.5517578.4155273-1.012207.9672852-1.0297852.5405273-.0214844 1.0126953.4145508 1.0317383.9663086.0019531.0551758.2246094 5.5322266 3.4941406 6.8613281.5117188.2080078.7578125.7910156.5498047 1.3027344-.1577148.3881836-.5317383.6240234-.9267578.6240234z" fill="#0051b1"/><path d="m22.315918 40.6220703c-.0795898 0-.159668-.0092773-.2402344-.0288086-.5361328-.1323242-.8637695-.6743164-.7319336-1.2104492.3754883-1.5244141-2.7802734-5.3032227-3.8393555-5.8193359-.7143555-.3481445-1.1171875-1.0053711-1.340332-1.7016602-.3242188.137207-.7104492.0991211-1.0078125-.1328125-.4350586-.340332-.5117188-.96875-.1713867-1.4038086l1.1489258-1.4682617c.2724609-.3486328.7416992-.4760742 1.1538086-.3144531.4121094.1625977.668457.5761719.6298828 1.0170898-.0722656.8793945.1142578 2.0361328.4628906 2.2060547 1.5092773.7353516 5.5957031 5.293457 4.9057617 8.0957031-.1123047.4560547-.5209961.7607422-.9702148.7607422z" fill="#0051b1"/></svg> Catfish</option>
                            <option value="goldfish"><svg xmlns="http://www.w3.org/2000/svg" id="Capa_1" enable-background="new 0 0 512.248 512.248" height="512" viewBox="0 0 512.248 512.248" width="512" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;"><path d="m460.489 188.173c-14.643-10.65-29.983-19.494-45.785-26.476-16.458-66.72-63.517-106.681-65.925-108.688l-8.078-6.731-97.135 56.663c-25.681 14.98-38.387 44.238-33.495 72.243-9.378 5.949-16.252 11.452-20.536 15.201-23.503-2.036-44.317-16.691-54.014-38.509l-3.416-7.687c-13.378-30.101-43.307-49.551-76.247-49.551h-55.858v83.162c0 35.286 12.647 69.474 35.611 96.266 18.307 21.358 28.389 48.612 28.389 76.742v115.162h15c55.324 0 100.333-45.009 100.333-100.333v-47.773c0-15.186 6.077-29.6 16.612-40.165l15.52 10.548v31.121c0 21.452 8.793 40.883 22.956 54.897-16.018 16.803-25.422 39.402-25.422 63.574v28.132h47.001c46.481 0 86.374-28.722 102.882-69.348 34.123-.298 67.62-11.961 94.462-32.932 27.385-21.394 46.774-51.663 54.598-85.231 2.69-11.543 4.055-28.46 4.057-40.453-2.499-3.08-24.209-29.979-51.51-49.834zm-280.322 63.305c-19.439 16.413-30.833 40.678-30.833 66.386v47.773c0 33.636-23.733 61.833-55.334 68.724v-83.553c0-35.286-12.646-69.474-35.611-96.266-18.307-21.358-28.389-48.613-28.389-76.742v-53.163h25.857c21.097 0 40.265 12.457 48.833 31.735l3.416 7.687c13.214 29.731 40.571 50.363 72.061 55.39zm78.514-122.625 78.321-45.687c5.943 6.112 14.676 16.003 23.312 29.093 7.979 12.094 14.361 24.508 19.171 37.178-17.471-4.496-35.281-6.8-53.152-6.8-35.531 0-64.7 7.748-87.165 17.302 1.029-12.529 7.959-24.346 19.513-31.086zm-2.681 307.117h-16.974c.522-17.505 8.352-33.642 21.119-44.839 8.85 3.539 18.492 5.506 28.59 5.506h36.69c-14.184 23.545-39.992 39.333-69.425 39.333zm222.725-164.319c-6.259 26.855-21.778 51.094-43.701 68.278-35.45-.878-64.024-29.967-64.024-65.625h-30c0 38.056 22.338 70.99 54.589 86.387-12.25 3.89-25.096 5.946-38.049 5.946h-68.805c-26.065 0-47.271-21.205-47.271-47.27v-47.005l-31.101-21.137-.17-39.025c4.878-4.152 13.92-11.102 26.818-17.975 26.879-14.325 56.931-21.588 89.32-21.588 40.684 0 79.615 13.196 115.715 39.222 20.343 14.666 34.059 29.539 39.846 36.32-.321 7.944-1.384 15.818-3.167 23.472z" fill="#0051b1"/><path d="m512 237.97v.036c.32.396.341.419 0-.036z" fill="#0051b1"/><path d="m405.333 243.97h30v30h-30z" fill="#0051b1"/></svg> Goldfish</option>
                            <option value="carp"><svg xmlns="http://www.w3.org/2000/svg" height="300" viewBox="-22 0 464 464" width="300" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;"><path d="m0 120c0 22.585938 20.03125 23.953125 24.046875 24l9.089844.105469-1.214844 9.015625c-1.058594 7.527344-1.738281 29.4375 7.621094 40.191406 3.914062 4.496094 9.296875 6.6875 16.457031 6.6875 17.167969 0 22.390625-10.121094 29.503906-26.632812 4.25-9.847657 9.007813-20.792969 18.742188-26.527344-.054688-3.425782-.230469-6.726563-.230469-10.214844-18.503906 2.773438-35.382813 13.902344-35.574219 14.03125l-8.875-13.3125c.960938-.640625 21.738282-14.28125 45.035156-16.878906.039063-.585938.023438-1.234375.070313-1.800782-9.609375-1.734374-30.175781-4.375-46.128906.929688l-5.0625-15.167969c18.847656-6.296875 41.457031-3.722656 52.96875-1.707031.933593-6.34375 2.101562-12.292969 3.4375-17.886719-7.039063-2.097656-19.6875-4.824219-37.871094-4.824219-30.078125-.007812-72.015625 15.214844-72.015625 39.992188zm0 0" fill="#0051b1"/><path d="m120 312c0 17.648438 14.351562 32 32 32 2.304688 0 4.59375-.320312 6.847656-.855469-11.785156-15.609375-21.664062-33.433593-29.65625-53.425781-5.792968 5.898438-9.191406 13.855469-9.191406 22.28125zm0 0" fill="#0051b1"/><path d="m330.527344 104.414062-5.0625 15.171876c-15.953125-5.304688-36.511719-2.664063-46.128906-.929688.039062.574219.03125 1.222656.070312 1.808594 23.296875 2.597656 44.066406 16.238281 45.035156 16.878906l-8.867187 13.320312c-.191407-.128906-17.140625-11.238281-35.574219-14.03125 0 3.542969-.03125 6.984376-.089844 10.3125 9.632813 5.765626 14.378906 16.628907 18.59375 26.421876 7.113282 16.511718 12.335938 26.632812 29.503906 26.632812 7.167969 0 12.558594-2.191406 16.480469-6.710938 9.398438-10.832031 8.671875-32.664062 7.601563-40.160156l-1.304688-9.136718h9.214844c3.96875-.046876 24-1.417969 24-24 0-24.785157-41.9375-40-72-40-18.175781 0-30.832031 2.726562-37.871094 4.824218 1.335938 5.589844 2.496094 11.542969 3.4375 17.886719 11.511719-2 34.128906-4.574219 52.960938 1.710937zm0 0" fill="#0051b1"/><path d="m240 312c0-29.183594 4.910156-47.511719 10.113281-66.921875 2.949219-11.03125 6.078125-22.765625 8.621094-37.605469-15.132813-2.535156-26.734375-15.625-26.734375-31.472656h16c0 7.800781 5.625 14.296875 13.015625 15.695312 1.808594-15.007812 2.984375-32.992187 2.984375-55.695312 0-.070312-.007812-.128906-.007812-.199219-6.703126 5.070313-14.960938 8.199219-23.992188 8.199219-22.054688 0-40-17.945312-40-40h16c0 13.230469 10.769531 24 24 24 10.449219 0 19.265625-6.753906 22.550781-16.089844-3.71875-33.207031-14.382812-55.628906-22-71.324218-1.519531-3.128907-2.839843-5.921876-4.03125-8.585938h-20.519531v-16h16c0-8.824219-7.175781-16-16-16h-48c-8.824219 0-16 7.175781-16 16h16v16h-20.519531c-1.199219 2.664062-2.519531 5.464844-4.03125 8.585938-7.617188 15.6875-18.28125 38.117187-22 71.324218 3.285156 9.335938 12.101562 16.089844 22.550781 16.089844 13.230469 0 24-10.769531 24-24h16c0 22.054688-17.945312 40-40 40-9.039062 0-17.289062-3.128906-23.992188-8.199219 0 .070313-.007812.128907-.007812.199219 0 19.703125.953125 38.207031 2.6875 55.726562 7.535156-1.277343 13.3125-7.824218 13.3125-15.726562h16c0 16.113281-12 29.34375-27.511719 31.542969 13.464844 100.175781 57.671875 162.136719 134.070313 188.074219-7.3125-19.921876-18.558594-55.210938-18.558594-83.617188zm-16-256h16v16h-16zm-64 16h-16v-16h16zm16 88c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32s-32-14.351562-32-32zm16 136c-17.648438 0-32-14.351562-32-32h16c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32zm1.015625-72h-2.03125c-3.550781 13.792969-16.105469 24-30.984375 24-17.648438 0-32-14.351562-32-32h16c0 8.824219 7.175781 16 16 16s16-7.175781 16-16v-8h32v8c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32-14.878906 0-27.433594-10.207031-30.984375-24zm0 0" fill="#0051b1"/><path d="m256 312c0 1.136719.089844 2.335938.128906 3.503906 9.640625-5.59375 15.871094-15.855468 15.871094-27.503906 0-9.007812-3.910156-17.457031-10.390625-23.414062-3.25 13.605468-5.609375 27.726562-5.609375 47.414062zm0 0" fill="#0051b1"/><path d="m286.425781 425.734375 16.773438-1.695313c.746093-.070312 70.792969-7.589843 116.617187-47.597656-9.089844-6.410156-27.222656-16.441406-51.816406-16.441406-13.183594 0-23.59375 3.902344-34.609375 8.039062-17.039063 6.394532-36.054687 13.503907-65.695313 4.703126 1.625 5.128906 3.234376 9.832031 4.730469 14.042968 9.367188 3.285156 30.894531 8.621094 52-1.9375l7.160157 14.3125c-11.96875 5.984375-23.867188 7.976563-34.410157 7.976563-6.527343 0-12.449219-.800781-17.640625-1.855469l6.265625 14.621094-15.832031-4.167969c-10.039062-2.636719-19.472656-6.015625-28.609375-9.734375 1.976563 8.726562 6.863281 19.199219 19.089844 27.34375l-8.875 13.3125c-16.679688-11.121094-25.765625-27.449219-27.253907-48.488281-8.433593-4.351563-16.488281-9.152344-24.039062-14.542969 1.222656 15.789062 5.878906 40.757812 22.382812 58.535156 13.464844 14.496094 32.761719 21.839844 57.351563 21.839844 21.894531 0 38.457031-5.382812 49.550781-10.792969-10.550781-2.429687-22.65625-7-31.207031-15.550781zm0 0" fill="#0051b1"/></svg> Carp</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label>Max Stocking Density (kg/m¬≥):</label>
                        <input type="number" class="max-stocking-density" min="0" max="100" step="0.1" placeholder="Auto (based on fish type)" 
                               title="Optional: Set tank-specific max stocking density. Leave blank to use fish type default.">
                    </div>
                    <div class="tank-volume">
                        <span id="tank-volume-${tankNumber}">0 L</span>
                    </div>
                </div>
                <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 0.5rem; flex-wrap: wrap;">
                    <button type="button" class="form-btn secondary" onclick="app.saveTankConfiguration(${tankNumber})" 
                            style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">Save Tank Config</button>
                    <button type="button" class="form-btn" onclick="app.deleteTankConfiguration(${tankNumber})" 
                            style="font-size: 0.8rem; padding: 0.3rem 0.6rem; background: #dc3545; border-color: #dc3545;">Delete Tank</button>
                </div>
            </div>
        `;
    }

    updateTankVolume(tankNumber) {
        const tankItem = document.querySelector(`[data-tank="${tankNumber}"]`);
        if (!tankItem) return;

        const sizeInput = tankItem.querySelector('.tank-size');
        const volumeDisplay = document.getElementById(`tank-volume-${tankNumber}`);
        
        if (sizeInput && volumeDisplay) {
            const sizeM3 = parseFloat(sizeInput.value) || 0;
            const volumeL = sizeM3 * 1000; // Convert m¬≥ to liters
            volumeDisplay.textContent = `${volumeL.toLocaleString()} L`;
        }
    }

    updateTotalFishVolume() {
        const tankItems = document.querySelectorAll('.fish-tank-item');
        let totalVolumeL = 0;

        tankItems.forEach(item => {
            const sizeInput = item.querySelector('.tank-size');
            if (sizeInput && sizeInput.value) {
                const sizeM3 = parseFloat(sizeInput.value) || 0;
                totalVolumeL += sizeM3 * 1000; // Convert m¬≥ to liters
            }
        });

        const totalVolumeField = document.getElementById('total-fish-volume');
        if (totalVolumeField) {
            totalVolumeField.value = Math.round(totalVolumeL);
        }

        // Update display field in Fish Tanks tab
        const totalVolumeDisplay = document.getElementById('total-fish-volume-display');
        if (totalVolumeDisplay) {
            totalVolumeDisplay.textContent = `${Math.round(totalVolumeL).toLocaleString()} L`;
        }
    }

    async saveTankConfiguration(tankNumber) {
        if (!this.activeSystemId) {
            this.showNotification('‚ùå Please select a system first.', 'error');
            return;
        }

        const tankItem = document.querySelector(`[data-tank="${tankNumber}"]`);
        if (!tankItem) return;

        const sizeM3 = parseFloat(tankItem.querySelector('.tank-size').value);
        const fishType = tankItem.querySelector('.fish-type').value;
        const maxStockingDensity = parseFloat(tankItem.querySelector('.max-stocking-density').value) || null;

        if (!sizeM3 || !fishType) {
            this.showNotification('‚ùå Please fill in all tank fields before saving.', 'error');
            return;
        }

        const tankData = {
            system_id: this.activeSystemId,
            tank_number: tankNumber,
            size_m3: sizeM3,
            volume_liters: sizeM3 * 1000,
            fish_type: fishType,
            max_stocking_density: maxStockingDensity
        };

        try {
            await this.makeApiCall('/fish-tanks', {
                method: 'POST',
                body: JSON.stringify(tankData)
            });
            
            // Refresh tank configuration display after successful save
            await this.loadFishTankConfiguration();
            
            this.showNotification(`üêü Fish Tank ${tankNumber} configuration saved successfully!`, 'success');
        } catch (error) {
            console.error('Failed to save tank configuration:', error);
            this.showNotification(`‚ùå Failed to save Fish Tank ${tankNumber} configuration.`, 'error');
        }
    }

    showHarvestFishModal(tankNumber) {
        // Force close all Quick Actions menus IMMEDIATELY
        this.hideAllQuickActions();
        
        // Set current date as default
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('harvest-date').value = today;
        
        // Set tank number
        document.getElementById('harvest-tank-number').textContent = tankNumber;
        document.getElementById('harvest-tank-id').value = tankNumber;
        
        // Clear form
        document.getElementById('harvest-fish-form').reset();
        document.getElementById('harvest-date').value = today; // Reset clears this, so set again
        
        // Clear average weight calculation
        document.getElementById('harvest-average-weight').value = '';
        
        // Show modal
        document.getElementById('harvest-fish-modal').style.display = 'flex';
        
        // Add event listeners for automatic calculation
        this.setupHarvestCalculation();
    }

    setupHarvestCalculation() {
        const fishCountInput = document.getElementById('harvest-fish-count');
        const totalWeightInput = document.getElementById('harvest-total-weight');
        const averageWeightInput = document.getElementById('harvest-average-weight');
        
        const calculateAverage = () => {
            const fishCount = parseFloat(fishCountInput.value) || 0;
            const totalWeight = parseFloat(totalWeightInput.value) || 0;
            
            if (fishCount > 0 && totalWeight > 0) {
                const averageWeight = (totalWeight / fishCount).toFixed(2);
                averageWeightInput.value = `${averageWeight} kg`;
            } else {
                averageWeightInput.value = '';
            }
        };
        
        // Remove existing listeners to avoid duplicates
        fishCountInput.removeEventListener('input', calculateAverage);
        totalWeightInput.removeEventListener('input', calculateAverage);
        
        // Add new listeners
        fishCountInput.addEventListener('input', calculateAverage);
        totalWeightInput.addEventListener('input', calculateAverage);
    }

    async submitFishHarvest(event) {
        event.preventDefault();
        
        if (!this.activeSystemId) {
            this.showNotification('‚ùå Please select a system first.', 'error');
            return;
        }
        
        const formData = new FormData(event.target);
        const harvestData = {
            system_id: this.activeSystemId,
            tank_number: parseInt(formData.get('tank_number')),
            harvest_date: formData.get('harvest_date'),
            fish_count: parseInt(formData.get('fish_count')),
            total_weight_kg: parseFloat(formData.get('total_weight')),
            average_weight_kg: parseFloat(formData.get('total_weight')) / parseInt(formData.get('fish_count')),
            notes: formData.get('notes') || ''
        };
        
        try {
            // Record fish harvest via the fish API
            await this.makeApiCall('/fish/harvest', {
                method: 'POST',
                body: JSON.stringify(harvestData)
            });
            
            // Close modal
            this.closeModal('harvest-fish-modal');
            
            // Show success notification
            this.showNotification(
                `üêü Fish harvest recorded successfully! ${harvestData.fish_count} fish (${harvestData.total_weight_kg}kg) from Tank ${harvestData.tank_number}`, 
                'success'
            );
            
            // Refresh any displays that might show harvest data
            await this.loadDataRecords();
            
            // Refresh fish tank information to show updated fish counts
            if (typeof this.loadTankInformation === 'function') {
                await this.loadTankInformation();
            }
            
            // Refresh fish inventory display if available
            if (typeof this.loadFishInventory === 'function') {
                await this.loadFishInventory();
            }
            
            // Also refresh fish overview cards to show updated counts
            await this.loadFishOverview();
            
        } catch (error) {
            console.error('Failed to record fish harvest:', error);
            this.showNotification('‚ùå Failed to record fish harvest. Please try again.', 'error');
        }
    }

    async deleteTankConfiguration(tankNumber) {
        if (!this.activeSystemId) return;

        if (!confirm(`Are you sure you want to delete Fish Tank ${tankNumber} configuration?`)) {
            return;
        }

        try {
            await this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}/tank/${tankNumber}`, {
                method: 'DELETE'
            });
            
            this.showNotification(`Fish Tank ${tankNumber} configuration deleted successfully!`, 'success');
            
            // Refresh the configuration
            const tankCount = parseInt(document.getElementById('fish-tank-count').value) || 1;
            this.generateFishTankConfiguration(tankCount);
            await this.loadFishTankConfiguration();
        } catch (error) {
            console.error('Failed to delete tank configuration:', error);
            this.showNotification(`‚ùå Failed to delete Fish Tank ${tankNumber} configuration.`, 'error');
        }
    }

    async saveFishTankConfiguration() {
        const tankItems = document.querySelectorAll('.fish-tank-item');
        const promises = [];

        tankItems.forEach((item, index) => {
            const tankNumber = index + 1;
            const sizeInput = item.querySelector('.tank-size');
            const fishTypeSelect = item.querySelector('.fish-type');
            
            if (sizeInput.value && fishTypeSelect.value) {
                promises.push(this.saveTankConfiguration(tankNumber));
            }
        });

        if (promises.length > 0) {
            await Promise.all(promises);
        }
    }

    async loadFishTankConfiguration() {
        if (!this.activeSystemId) return;

        try {
            const response = await this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}`);
            const fishTanks = response.tanks || [];
            
            if (fishTanks && fishTanks.length > 0) {
                fishTanks.forEach(tank => {
                    const tankItem = document.querySelector(`[data-tank="${tank.tank_number}"]`);
                    if (tankItem) {
                        const sizeInput = tankItem.querySelector('.tank-size');
                        const fishTypeSelect = tankItem.querySelector('.fish-type');
                        const maxStockingDensityInput = tankItem.querySelector('.max-stocking-density');
                        
                        if (sizeInput && tank.size_m3) {
                            sizeInput.value = tank.size_m3;
                            this.updateTankVolume(tank.tank_number);
                        }
                        
                        if (fishTypeSelect && tank.fish_type) {
                            fishTypeSelect.value = tank.fish_type;
                        }
                        
                        if (maxStockingDensityInput && tank.max_stocking_density) {
                            maxStockingDensityInput.value = tank.max_stocking_density;
                        }
                    }
                });
                
                this.updateTotalFishVolume();
            }
        } catch (error) {
            console.error('Failed to load fish tank configuration:', error);
            // Don't show error notification as this might be a new system without fish tanks yet
        }
    }


    async loadGrowBedConfiguration() {
        if (!this.activeSystemId || this.activeSystemId === 'undefined') {
            console.error('No active system ID for loading grow bed configuration');
            return;
        }

        try {
            
            // Check if container exists first
            const container = document.getElementById('grow-beds-container');
            if (container) {
                const containerStyles = window.getComputedStyle(container);
            }
            if (!container) {
                console.error('grow-beds-container not found in DOM');
                return;
            }
            
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);

            // Wait for growBedManager to be available (loaded at bottom of file)
            if (!window.growBedManager) {
                await new Promise(resolve => {
                    const checkManager = () => {
                        if (window.growBedManager) {
                            resolve();
                        } else {
                            setTimeout(checkManager, 10);
                        }
                    };
                    checkManager();
                });
            }

            // Generate the configuration UI first
            const bedCountElement = document.getElementById('grow-bed-count');
            const systemConfig = this.loadSystemConfig();
            let bedCount = 4; // Default
            
            if (bedCountElement && bedCountElement.value) {
                bedCount = parseInt(bedCountElement.value);
            } else if (systemConfig && systemConfig.grow_bed_count) {
                bedCount = parseInt(systemConfig.grow_bed_count);
            }

            
            if (window.growBedManager && typeof window.growBedManager.generateGrowBedConfiguration === 'function') {
                try {
                    window.growBedManager.generateGrowBedConfiguration(bedCount);
                } catch (error) {
                    console.error('Error in generateGrowBedConfiguration:', error);
                    console.error('Error stack:', error.stack);
                }
            } else {
                console.error('growBedManager.generateGrowBedConfiguration is not available');
                this.showNotification('‚ùå Grow bed configuration manager not loaded. Please refresh the page.', 'error');
                return;
            }
            
            // Also generate initial empty configuration if no existing beds
            if (!growBeds || growBeds.length === 0) {

            }
            
            // Load existing data with a small delay to ensure DOM is ready
            if (growBeds && growBeds.length > 0) {

                setTimeout(() => {
                    growBeds.forEach(bed => {

                        const bedItem = document.querySelector(`[data-bed="${bed.bed_number}"]`);

                        if (bedItem) {
                            // First set the bed type

                            const bedTypeSelect = bedItem.querySelector('.bed-type');
                            if (bedTypeSelect) {
                                bedTypeSelect.value = bed.bed_type;

                                // Update the fields based on bed type
                                window.growBedManager.updateBedFields(bed.bed_number);
                            } else {
                                console.error('Could not find bed type select for bed', bed.bed_number);
                            }
                        
                        // Set the dimension values based on bed type
                        if (bed.bed_type === 'dwc' || bed.bed_type === 'media-flow' || bed.bed_type === 'flood-drain') {
                            if (bed.length_meters) {
                                const lengthField = bedItem.querySelector('.bed-length');
                                if (lengthField) lengthField.value = bed.length_meters;
                            }
                            if (bed.width_meters) {
                                const widthField = bedItem.querySelector('.bed-width');
                                if (widthField) widthField.value = bed.width_meters;
                            }
                            if (bed.height_meters) {
                                const heightField = bedItem.querySelector('.bed-height');
                                if (heightField) heightField.value = bed.height_meters;
                            }
                        } else if (bed.bed_type === 'vertical') {
                            if (bed.length_meters) {
                                const baseLengthField = bedItem.querySelector('.base-length');
                                if (baseLengthField) baseLengthField.value = bed.length_meters;
                            }
                            if (bed.width_meters) {
                                const baseWidthField = bedItem.querySelector('.base-width');
                                if (baseWidthField) baseWidthField.value = bed.width_meters;
                            }
                            if (bed.height_meters) {
                                const baseHeightField = bedItem.querySelector('.base-height');
                                if (baseHeightField) baseHeightField.value = bed.height_meters;
                            }
                            if (bed.vertical_count) {
                                const verticalCountField = bedItem.querySelector('.vertical-count');
                                if (verticalCountField) verticalCountField.value = bed.vertical_count;
                            }
                            if (bed.plants_per_vertical) {
                                const plantsPerVerticalField = bedItem.querySelector('.plants-per-vertical');
                                if (plantsPerVerticalField) plantsPerVerticalField.value = bed.plants_per_vertical;
                            }
                        } else if (bed.bed_type === 'nft') {
                            if (bed.trough_length) {
                                const troughLengthField = bedItem.querySelector('.trough-length');
                                if (troughLengthField) troughLengthField.value = bed.trough_length;
                            }
                            if (bed.trough_count) {
                                const troughCountField = bedItem.querySelector('.trough-count');
                                if (troughCountField) troughCountField.value = bed.trough_count;
                            }
                            if (bed.plant_spacing) {
                                const plantSpacingField = bedItem.querySelector('.plant-spacing');
                                if (plantSpacingField) plantSpacingField.value = bed.plant_spacing;
                            }
                            if (bed.reservoir_volume_liters) {
                                const reservoirVolumeField = bedItem.querySelector('.reservoir-volume');
                                if (reservoirVolumeField) reservoirVolumeField.value = bed.reservoir_volume_liters;
                            }
                        }
                        
                        // Trigger calculation to update the displayed values
                        window.growBedManager.calculateBed(bed.bed_number);
                        } // Close the if (bedItem) block
                    });
                }, 100);
            }
            // Update total grow bed volume display after loading beds
            setTimeout(() => {
                this.updateTotalGrowBedVolume();
            }, 200);
        } catch (error) {
            console.error('Error loading grow bed configuration:', error);
        }
    }

    async saveGrowBedConfiguration() {
        if (!this.activeSystemId) return;

        const configuration = window.growBedManager.getGrowBedConfiguration();

        try {
            await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify({ growBeds: configuration })
            });
            
            // Refresh the grow bed status display after saving
            await this.displayGrowBedStatus();
            
            // Update the total grow bed volume display
            this.updateTotalGrowBedVolume();
        } catch (error) {
            console.error('Error saving grow bed configuration:', error);
            throw error;
        }
    }

    async calculateTotalGrowBedVolume() {
        if (!this.activeSystemId) return 0;

        try {
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            let totalVolume = 0;
            
            if (growBeds && growBeds.length > 0) {
                totalVolume = growBeds.reduce((sum, bed) => {
                    return sum + (bed.volume_liters || 0);
                }, 0);
            }
            
            return totalVolume;
        } catch (error) {
            console.error('Error calculating total grow bed volume:', error);
            return 0;
        }
    }

    async updateTotalGrowBedVolume() {
        const totalVolume = await this.calculateTotalGrowBedVolume();
        const displayElement = document.getElementById('total-grow-volume-display');
        
        if (displayElement) {
            displayElement.textContent = `Auto-calculated: ${Math.round(totalVolume)} L`;
            displayElement.style.color = totalVolume > 0 ? '#28a745' : '#6c757d';
        }
        
        // Update the system object with calculated volume
        if (this.systems[this.activeSystemId]) {
            this.systems[this.activeSystemId].total_grow_volume = totalVolume;
        }
        
        return totalVolume;
    }

    async displayGrowBedStatus() {
        const container = document.getElementById('grow-bed-status-container');
        if (!container || !this.activeSystemId) return;

        try {
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            
            if (!growBeds || growBeds.length === 0) {
                container.innerHTML = `
                    <div class="grow-bed-status-empty">
                        <p style="text-align: center; color: #666; font-style: italic;">
                            No grow bed configuration found. Configure your grow beds above to see their status here.
                        </p>
                    </div>
                `;
                return;
            }

            const statusHtml = growBeds.map(bed => {
                let configDetails = '';
                if (bed.bed_type === 'vertical' && bed.vertical_count && bed.plants_per_vertical) {
                    const totalPlants = bed.vertical_count * bed.plants_per_vertical;
                    configDetails = `${bed.vertical_count} verticals √ó ${bed.plants_per_vertical} plants = ${totalPlants} total plants`;
                } else if (bed.area_m2) {
                    configDetails = `${bed.area_m2} m¬≤ area`;
                } else if (bed.length_meters) {
                    configDetails = `${bed.length_meters} m length`;
                }

                return `
                    <div class="grow-bed-status-item">
                        <div class="bed-status-header">
                            <h4>Bed ${bed.bed_number}</h4>
                            <span class="bed-type-badge">${this.formatBedType(bed.bed_type)}</span>
                        </div>
                        <div class="bed-status-details">
                            <div class="status-row">
                                <span class="status-label">Configuration:</span>
                                <span class="status-value">${configDetails}</span>
                            </div>
                            <div class="status-row">
                                <span class="status-label">Volume:</span>
                                <span class="status-value">${bed.volume_liters}L</span>
                            </div>
                            <div class="status-row">
                                <span class="status-label">Equivalent Area:</span>
                                <span class="status-value">${(parseFloat(bed.equivalent_m2) || 0).toFixed(1)} m¬≤</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="grow-bed-status-grid">
                    ${statusHtml}
                </div>
                <div class="grow-bed-status-summary">
                    <p><strong>Total Beds:</strong> ${growBeds.length}</p>
                    <p><strong>Total Equivalent Area:</strong> ${growBeds.reduce((sum, bed) => sum + (parseFloat(bed.equivalent_m2) || 0), 0).toFixed(1)} m¬≤</p>
                </div>
            `;

        } catch (error) {
            console.error('Error displaying grow bed status:', error);
            container.innerHTML = `
                <div class="grow-bed-status-error">
                    <p style="color: #d32f2f; text-align: center;">
                        Error loading grow bed status. Please try refreshing the page.
                    </p>
                </div>
            `;
        }
    }

    formatBedType(bedType) {
        const typeMap = {
            'flood-drain': 'Flood & Drain',
            'media-flow': 'Media Flow Through',
            'dwc': 'Deep Water Culture',
            'nft': 'NFT',
            'vertical': 'Vertical Growing'
        };
        return typeMap[bedType] || bedType;
    }

    // Update system name display on all tabs
    updateCurrentSystemDisplay() {
        const activeSystem = this.getActiveSystem();
        const systemName = activeSystem ? activeSystem.system_name : 'No System Selected';
        
        console.log('üìä Updating current system display:', {
            activeSystem: activeSystem,
            systemName: systemName,
            activeSystemId: this.activeSystemId
        });
        
        const displays = [
            'current-system-dashboard',
            'current-system-calculators', 
            'current-system-data-entry',
            'current-system-fish-tank',
            'current-system-plants',
            'current-system-settings'
        ];
        
        displays.forEach(displayId => {
            const element = document.getElementById(displayId);
            if (element) {
                element.innerHTML = `<strong>System:</strong> ${systemName}`;
                console.log(`‚úÖ Updated ${displayId} with system name: ${systemName}`);
            } else {
                console.warn(`‚ö†Ô∏è Display element ${displayId} not found`);
            }
        });
    }

    // Data preloading methods
    preloadWaterQualityData() {
        if (!this.latestData || !this.latestData.waterQuality) return;
        
        const latest = this.latestData.waterQuality;
        
        // Preload fields that commonly remain stable (not including date which should be current)
        if (latest.ammonia !== null) document.getElementById('wq-ammonia').value = latest.ammonia;
        if (latest.nitrite !== null) document.getElementById('wq-nitrite').value = latest.nitrite;
        // nitrate field already handled above
        if (latest.phosphorus !== null) document.getElementById('wq-phosphorus').value = latest.phosphorus;
        if (latest.magnesium !== null) document.getElementById('wq-magnesium').value = latest.magnesium;
        if (latest.humidity !== null) document.getElementById('wq-humidity').value = latest.humidity;
        if (latest.salinity !== null) document.getElementById('wq-salinity').value = latest.salinity;
    }

    preloadPlantGrowthData() {
        if (!this.latestData || !this.latestData.plantGrowth) return;
        
        const latest = this.latestData.plantGrowth;
        
        // Preload plant count from latest entry
        if (latest.count) document.getElementById('pg-count').value = latest.count;
    }

    preloadFishHealthData() {
        if (!this.latestData || !this.latestData.fishHealth) return;
        
        const latest = this.latestData.fishHealth;
        
        // Preload fish count from latest entry
        if (latest.count) document.getElementById('fh-count').value = latest.count;
    }

    // SMTP Configuration Management
    async loadSmtpConfig() {
        try {
            const response = await this.makeApiCall('/config/smtp');
            
            document.getElementById('smtp-host').value = response.host || '';
            document.getElementById('smtp-port').value = response.port || '';
            document.getElementById('smtp-user').value = response.auth?.user || '';
            document.getElementById('smtp-pass').value = response.auth?.pass || '';
            document.getElementById('smtp-from-name').value = response.from?.name || '';
            document.getElementById('smtp-from-email').value = response.from?.address || '';
            document.getElementById('smtp-reset-url').value = response.resetUrl || '';
            
            this.showNotification('üìß SMTP configuration loaded successfully', 'success', 2000);
        } catch (error) {
            console.error('Failed to load SMTP config:', error);
            this.showNotification('‚ùå Failed to load SMTP configuration', 'error');
        }
    }

    async saveSmtpConfig() {
        const config = {
            host: document.getElementById('smtp-host').value,
            port: document.getElementById('smtp-port').value,
            secure: false, // Use STARTTLS for port 587
            auth: {
                user: document.getElementById('smtp-user').value,
                pass: document.getElementById('smtp-pass').value
            },
            from: {
                name: document.getElementById('smtp-from-name').value,
                address: document.getElementById('smtp-from-email').value
            },
            resetUrl: document.getElementById('smtp-reset-url').value
        };

        // Validate required fields
        if (!config.host || !config.port || !config.auth.user || !config.auth.pass || !config.from.address || !config.resetUrl) {
            this.showNotification('‚ö†Ô∏è Please fill in all required fields', 'warning');
            return;
        }

        try {
            await this.makeApiCall('/config/smtp', {
                method: 'PUT',
                body: JSON.stringify(config)
            });
            
            this.showNotification('‚úÖ SMTP configuration saved successfully', 'success');
        } catch (error) {
            console.error('Failed to save SMTP config:', error);
            this.showNotification('‚ùå Failed to save SMTP configuration: ' + error.message, 'error');
        }
    }

    async testSmtpConfig() {
        try {
            const response = await this.makeApiCall('/config/smtp/test', {
                method: 'POST'
            });
            
            this.showNotification('üìß Test email sent successfully! Check your inbox.', 'success', 5000);
        } catch (error) {
            console.error('SMTP test failed:', error);
            this.showNotification('‚ùå SMTP test failed: ' + error.message, 'error', 6000);
        }
    }

    // Enhanced Dosing Calculator Methods
    async updateReservoirVolume() {
        const activeSystem = this.getActiveSystem();
        if (activeSystem) {
            // Calculate total grow bed volume from individual beds
            const totalGrowVolume = await this.calculateTotalGrowBedVolume();
            
            // Calculate total reservoir volume = fish tank volume + grow bed volume
            const totalVolume = (activeSystem.total_fish_volume || 0) + totalGrowVolume;
            const reservoirInput = document.getElementById('reservoir-volume');
            if (reservoirInput) {
                reservoirInput.value = totalVolume;
            }
        }
    }

    async loadDosingSchedulePDF() {
        console.log('üì° Loading dosing schedule PDF interface...');
        try {
            // Initialize the dosing schedule interface
            const container = document.getElementById('mixing-schedule-content');
            if (!container) {
                console.warn('Missing mixing-schedule-content container');
                return;
            }

            // Ensure the nutrient calculator is initialized to show current schedule
            await this.initializeNutrientCalculator();
            
            // Display any existing dosing results
            const dosingResults = document.getElementById('dosing-results');
            if (dosingResults && dosingResults.innerHTML.trim()) {
                console.log('üìä Existing dosing schedule found and displayed');
            } else {
                console.log('üìù No existing dosing schedule - calculator ready for new calculations');
            }
        } catch (error) {
            console.error('Error loading dosing schedule PDF interface:', error);
        }
    }

    async downloadDosingSchedulePDF() {
        const resultsDiv = document.getElementById('dosing-results');
        if (!resultsDiv.innerHTML.trim()) {
            this.showMessage('Please calculate dosing first', 'warning');
            return;
        }

        try {
            // Create PDF content
            const pdfContent = this.generatePDFContent();
            
            // Use browser's print to PDF functionality
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Aquaponics Dosing Schedule</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .header { text-align: center; border-bottom: 2px solid #334e9d; padding-bottom: 10px; margin-bottom: 20px; }
                        .section { margin-bottom: 20px; }
                        .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
                        .nutrient-card { border: 1px solid #ddd; padding: 10px; border-radius: 5px; }
                        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px; margin: 10px 0; }
                        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f5f5f5; }
                        @media print { .no-print { display: none; } }
                    </style>
                </head>
                <body>
                    ${pdfContent}
                    <div class="no-print" style="margin-top: 20px; text-align: center;">
                        <button onclick="window.print()">Print/Save as PDF</button>
                        <button onclick="window.close()">Close</button>
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            this.showMessage('Failed to generate PDF', 'error');
        }
    }

    generatePDFContent() {
        const activeSystem = this.getActiveSystem();
        const crop = document.getElementById('crop-type').value;
        const reservoirVolume = document.getElementById('reservoir-volume').value;
        const resultsDiv = document.getElementById('dosing-results');
        
        const systemName = activeSystem ? activeSystem.system_name : 'Unknown System';
        const currentDate = this.formatDateDDMMYYYY(new Date());
        
        return `
            <div class="header">
                <h1>üåø Afraponix Go - Nutrient Dosing Schedule</h1>
                <p><strong>System:</strong> ${systemName} | <strong>Crop:</strong> ${crop} | <strong>Date:</strong> ${currentDate}</p>
                <p><strong>Reservoir Volume:</strong> ${reservoirVolume}L</p>
            </div>
            
            <div class="section">
                <h2>Dosing Instructions</h2>
                ${resultsDiv.innerHTML}
            </div>
            
            <div class="section">
                <h2>Safety Guidelines</h2>
                <div class="warning">
                    <strong>‚ö†Ô∏è Important Safety Notes:</strong>
                    <ul>
                        <li>Always dissolve nutrients in small amounts of water before adding to reservoir</li>
                        <li>Add nutrients slowly and mix thoroughly</li>
                        <li>Test pH after nutrient addition and adjust if necessary (target: 6.0-7.0)</li>
                        <li>Monitor fish behavior for 24 hours after dosing</li>
                        <li>Keep nutrients in cool, dry place away from children</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h2>Monitoring Schedule</h2>
                <table>
                    <tr><th>Frequency</th><th>Parameter</th><th>Target Range</th></tr>
                    <tr><td>Daily</td><td>pH</td><td>6.0 - 7.0</td></tr>
                    <tr><td>Weekly</td><td>EC</td><td>1.5 - 2.5 mS/cm</td></tr>
                    <tr><td>Weekly</td><td>Nitrate</td><td>5 - 150 ppm</td></tr>
                    <tr><td>Monthly</td><td>Full Nutrient Analysis</td><td>As per crop requirements</td></tr>
                </table>
            </div>
            
            <div style="margin-top: 40px; text-align: center; font-size: 0.9em; color: #666;">
                Generated by Afraponix Go Aquaponics Management System
            </div>
        `;
    }

    async emailDosingSchedule() {
        this.showMessage('Email functionality will be available in a future update', 'info');
    }

    // Admin Panel Methods
    async loadAdminUsers() {
        console.log('üöÄ loadAdminUsers() started');
        try {
            console.log('üì° Making API call to /admin/users');
            const users = await this.makeApiCall('/admin/users');
            console.log('‚úÖ Received users data:', users);
            console.log('‚úÖ Users array length:', users ? users.length : 'null/undefined');
            
            if (users && Array.isArray(users)) {
                console.log('üìû Calling displayAdminUsers with', users.length, 'users');
                this.displayAdminUsers(users);
            } else {
                console.error('‚ùå Users data is not an array:', typeof users, users);
                this.showMessage('Invalid users data received', 'error');
            }
        } catch (error) {
            console.error('‚ùå Error loading admin users:', error);
            this.showMessage('Failed to load users', 'error');
        }
    }

    displayAdminUsers(users) {
        console.log('üé® displayAdminUsers() called with', users ? users.length : 'null', 'users');
        const container = document.getElementById('users-list-container');
        console.log('üì¶ Container found:', !!container);
        if (!container) {
            console.error('‚ùå users-list-container not found in DOM!');
            return;
        }

        // Store all users for searching
        this.allAdminUsers = users;
        
        // Update user count
        const countDisplay = document.getElementById('user-count-display');
        if (countDisplay) {
            countDisplay.textContent = `${users.length} user${users.length !== 1 ? 's' : ''} found`;
        }

        let html = '<div class="users-grid">';
        
        users.forEach(user => {
            html += `
                <div class="user-card">
                    <div class="user-header">
                        <h4>${user.first_name || ''} ${user.last_name || ''}</h4>
                        <span class="user-role ${user.user_role}">${user.user_role}</span>
                    </div>
                    <div class="user-details">
                        <div><strong>Username:</strong> ${user.username}</div>
                        <div><strong>Email:</strong> ${user.email}</div>
                        <div><strong>Subscription:</strong> ${user.subscription_status}</div>
                        <div><strong>Created:</strong> ${this.formatDateDDMMYYYY(new Date(user.created_at))}</div>
                    </div>
                    <div class="user-actions">
                        <select onchange="app.updateUserRole(${user.id}, this.value)" class="role-select">
                            <option value="basic" ${user.user_role === 'basic' ? 'selected' : ''}>Basic</option>
                            <option value="subscribed" ${user.user_role === 'subscribed' ? 'selected' : ''}>Subscribed</option>
                            <option value="admin" ${user.user_role === 'admin' ? 'selected' : ''}>Admin</option>
                        </select>
                        <button onclick="app.resetUserPassword(${user.id})" class="admin-btn secondary">Reset Password</button>
                        ${user.id !== this.user.id ? `<button onclick="app.deleteUser(${user.id})" class="admin-btn danger">Delete</button>` : ''}
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }

    searchAdminUsers(searchTerm) {
        if (!this.allAdminUsers) return;
        
        const term = searchTerm.toLowerCase().trim();
        
        if (term === '') {
            // Show all users if search is empty
            this.displayAdminUsers(this.allAdminUsers);
            return;
        }
        
        // Filter users based on search term
        const filteredUsers = this.allAdminUsers.filter(user => {
            const fullName = `${user.first_name || ''} ${user.last_name || ''}`.toLowerCase();
            const username = (user.username || '').toLowerCase();
            const email = (user.email || '').toLowerCase();
            
            return fullName.includes(term) || 
                   username.includes(term) || 
                   email.includes(term);
        });
        
        this.displayAdminUsers(filteredUsers);
    }
    
    async updateUserRole(userId, newRole) {
        try {
            await this.makeApiCall(`/api/admin/users/${userId}`, {
                method: 'PUT',
                body: JSON.stringify({ userRole: newRole })
            });
            
            this.showMessage('User role updated successfully', 'success');
            this.loadAdminUsers();
        } catch (error) {
            console.error('Error updating user role:', error);
            this.showMessage('Failed to update user role', 'error');
        }
    }

    async resetUserPassword(userId) {
        const newPassword = prompt('Enter new password (minimum 6 characters):');
        if (!newPassword || newPassword.length < 6) {
            this.showMessage('Password must be at least 6 characters long', 'error');
            return;
        }

        try {
            await this.makeApiCall(`/api/admin/users/${userId}/reset-password`, {
                method: 'POST',
                body: JSON.stringify({ newPassword })
            });
            
            this.showMessage(`Password reset successfully. New password: ${newPassword}`, 'success');
        } catch (error) {
            console.error('Error resetting password:', error);
            this.showMessage('Failed to reset password', 'error');
        }
    }

    async deleteUser(userId) {
        if (!confirm('Are you sure you want to delete this user? This action cannot be undone.')) {
            return;
        }

        try {
            await this.makeApiCall(`/api/admin/users/${userId}`, {
                method: 'DELETE'
            });
            
            this.showMessage('User deleted successfully', 'success');
            this.loadAdminUsers();
        } catch (error) {
            console.error('Error deleting user:', error);
            this.showMessage('Failed to delete user', 'error');
        }
    }

    async loadAdminStats() {
        console.log('üöÄ loadAdminStats() started');
        try {
            console.log('üì° Making API call to /admin/stats');
            const stats = await this.makeApiCall('/admin/stats');
            this.displayAdminStats(stats);
        } catch (error) {
            console.error('Error loading admin stats:', error);
            this.showMessage('Failed to load statistics', 'error');
        }
    }

    displayAdminStats(stats) {
        const container = document.getElementById('admin-stats-container');
        if (!container) return;

        let html = `
            <div class="stats-grid">
                <div class="stat-card">
                    <h4>Total Systems</h4>
                    <div class="stat-value">${stats.totalSystems}</div>
                </div>
                <div class="stat-card">
                    <h4>Recent Registrations</h4>
                    <div class="stat-value">${stats.recentRegistrations}</div>
                    <small>Last 30 days</small>
                </div>
                <div class="stat-card">
                    <h4>User Breakdown</h4>
                    <div class="user-breakdown">
        `;

        stats.users.forEach(userStat => {
            html += `
                <div class="user-stat">
                    <span class="role ${userStat.user_role}">${userStat.user_role}</span>
                    <span class="count">${userStat.count}</span>
                </div>
            `;
        });

        html += `
                    </div>
                </div>
            </div>
        `;

        container.innerHTML = html;
    }

    // =====================================================
    // ADMIN CROP KNOWLEDGE MANAGEMENT
    // =====================================================

    async loadAdminCrops() {
        console.log('üöÄ loadAdminCrops() started');
        console.log('üîç CropKnowledgeAPI available:', typeof CropKnowledgeAPI);
        console.log('üîç fetchCrops function available:', typeof CropKnowledgeAPI.fetchCrops);
        
        try {
            console.log('üì° Calling CropKnowledgeAPI.fetchCrops()');
            const data = await CropKnowledgeAPI.fetchCrops();
            console.log('‚úÖ Received data:', data);
            
            if (data.success) {
                console.log('‚úÖ Data is successful, calling displayAdminCrops with', data.data.length, 'crops');
                this.displayAdminCrops(data.data);
            } else {
                console.error('‚ùå Data success is false:', data);
                throw new Error(data.error || 'Failed to load crops');
            }
        } catch (error) {
            console.error('‚ùå Error loading admin crops:', error);
            console.error('‚ùå Error stack:', error.stack);
            this.showMessage('Failed to load crops', 'error');
        }
    }

    displayAdminCrops(crops) {
        console.log('üé® displayAdminCrops() called with', crops.length, 'crops');
        const container = document.getElementById('admin-crops-container');
        const countDisplay = document.getElementById('crop-count-display');
        
        console.log('üîç Container found:', !!container);
        console.log('üîç Count display found:', !!countDisplay);
        
        if (!container) {
            console.error('‚ùå admin-crops-container not found!');
            return;
        }

        // Store crops for searching/filtering
        this.allAdminCrops = crops;
        
        // Update count display
        if (countDisplay) {
            countDisplay.textContent = `${crops.length} crop${crops.length !== 1 ? 's' : ''} found`;
        }

        if (crops.length === 0) {
            container.innerHTML = `
                <div class="crop-empty-state">
                    <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="No Crops">
                    <h4>No crops found</h4>
                    <p>Start building your crop knowledge database by adding your first crop.</p>
                    <button class="btn-success" onclick="app.openCropManagementModal()">
                        <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Add" class="btn-icon-svg"> Add First Crop
                    </button>
                </div>
            `;
            return;
        }

        let html = '';
        crops.forEach(crop => {
            const categoryName = this.formatCategoryName(crop.category_code || 'uncategorized');
            
            html += `
                <div class="crop-card" data-crop="${crop.code}">
                    <div class="crop-card-header">
                        <div class="crop-card-title">
                            <h4>${crop.name}</h4>
                            <span class="crop-code">${crop.code}</span>
                        </div>
                        <div class="crop-card-actions">
                            <button class="btn-primary" onclick="app.openNutrientTargetsModal('${crop.code}', '${crop.name}')" 
                                    title="Manage Nutrient Targets">
                                <img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Nutrients" class="btn-icon-svg">
                            </button>
                            <button class="btn-success" onclick="app.openSeedVarietiesModal('${crop.code}', '${crop.name}')" 
                                    title="Manage Seed Varieties">
                                <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Varieties" class="btn-icon-svg">
                            </button>
                            <button class="btn-secondary" onclick="app.editCrop('${crop.code}')" title="Edit Crop">
                                <img src="icons/new-icons/Afraponix Go Icons_settings.svg" alt="Edit" class="btn-icon-svg">
                            </button>
                            <button class="btn-danger" onclick="app.deleteCrop('${crop.code}', '${crop.name}')" title="Delete Crop">
                                √ó
                            </button>
                        </div>
                    </div>
                    
                    <div class="crop-category-badge ${crop.category_code || 'uncategorized'}">
                        ${categoryName}
                    </div>
                    
                    <div class="crop-info-grid">
                        <div class="crop-info-item">
                            <label>Scientific Name:</label>
                            <span>${crop.scientific_name || 'Not specified'}</span>
                        </div>
                        <div class="crop-info-item">
                            <label>Days to Harvest:</label>
                            <span>${crop.days_to_harvest || 'Variable'} days</span>
                        </div>
                        <div class="crop-info-item">
                            <label>EC Range:</label>
                            <span>${this.formatRange(crop.default_ec_min, crop.default_ec_max, 'mS/cm')}</span>
                        </div>
                        <div class="crop-info-item">
                            <label>pH Range:</label>
                            <span>${this.formatRange(crop.default_ph_min, crop.default_ph_max)}</span>
                        </div>
                    </div>
                    
                    <div class="nutrient-targets-summary">
                        <strong>${crop.nutrient_targets_count || 0}</strong> nutrient targets configured
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
    }

    formatCategoryName(categoryCode) {
        const categoryNames = {
            'leafy_greens': 'Leafy Greens',
            'herbs': 'Herbs',
            'fruiting': 'Fruiting Plants',
            'root_vegetables': 'Root Vegetables',
            'brassicas': 'Brassicas',
            'uncategorized': 'Uncategorized'
        };
        return categoryNames[categoryCode] || categoryCode;
    }

    formatRange(min, max, unit = '') {
        if (!min && !max) return 'Not specified';
        if (!min) return `‚â§ ${max}${unit}`;
        if (!max) return `‚â• ${min}${unit}`;
        if (min === max) return `${min}${unit}`;
        return `${min} - ${max}${unit}`;
    }

    searchAdminCrops(searchTerm) {
        if (!this.allAdminCrops) return;

        const filtered = this.allAdminCrops.filter(crop => {
            return crop.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                   crop.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
                   (crop.scientific_name && crop.scientific_name.toLowerCase().includes(searchTerm.toLowerCase())) ||
                   (crop.category_name && crop.category_name.toLowerCase().includes(searchTerm.toLowerCase()));
        });

        this.displayAdminCrops(filtered);
    }

    filterCropsByCategory(categoryCode) {
        if (!this.allAdminCrops) return;

        let filtered = this.allAdminCrops;
        if (categoryCode) {
            filtered = this.allAdminCrops.filter(crop => crop.category_code === categoryCode);
        }

        this.displayAdminCrops(filtered);
    }

    openCropManagementModal(cropCode = null) {
        const modal = document.getElementById('crop-management-modal');
        const title = document.getElementById('crop-modal-title');
        const form = document.getElementById('crop-management-form');
        
        if (!modal) return;

        // Reset form
        form.reset();
        
        if (cropCode) {
            // Edit mode
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Crop" class="heading-icon"> Edit Crop';
            document.getElementById('save-crop-btn').textContent = 'Update Crop';
            this.currentEditingCrop = cropCode;
            this.loadCropForEdit(cropCode);
        } else {
            // Add mode
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Crop" class="heading-icon"> Add New Crop';
            document.getElementById('save-crop-btn').textContent = 'Save Crop';
            this.currentEditingCrop = null;
        }

        modal.style.display = 'block';
    }

    async loadCropForEdit(cropCode) {
        try {
            const data = await CropKnowledgeAPI.fetchCropDetails(cropCode);
            
            if (data.success) {
                const crop = data.data.crop;
                
                // Populate form fields
                document.getElementById('crop-code').value = crop.code;
                document.getElementById('crop-name').value = crop.name;
                document.getElementById('crop-scientific-name').value = crop.scientific_name || '';
                document.getElementById('crop-category').value = crop.category_code || '';
                document.getElementById('crop-ec-min').value = crop.default_ec_min || '';
                document.getElementById('crop-ec-max').value = crop.default_ec_max || '';
                document.getElementById('crop-ph-min').value = crop.default_ph_min || '';
                document.getElementById('crop-ph-max').value = crop.default_ph_max || '';
                document.getElementById('crop-days-harvest').value = crop.days_to_harvest || '';
                document.getElementById('crop-plant-spacing').value = crop.plant_spacing_cm || '';
                document.getElementById('crop-light-requirements').value = crop.light_requirements || '';
                document.getElementById('crop-growing-notes').value = crop.growing_notes || '';
                document.getElementById('crop-research-source').value = crop.research_source || '';
                
                // Disable code field in edit mode
                document.getElementById('crop-code').disabled = true;
            }
        } catch (error) {
            console.error('Error loading crop for edit:', error);
            this.showMessage('Failed to load crop details', 'error');
        }
    }

    closeCropManagementModal() {
        const modal = document.getElementById('crop-management-modal');
        if (modal) {
            modal.style.display = 'none';
            this.currentEditingCrop = null;
            
            // Re-enable code field
            const codeField = document.getElementById('crop-code');
            if (codeField) codeField.disabled = false;
        }
    }

    async saveCrop() {
        const form = document.getElementById('crop-management-form');
        const formData = new FormData(form);
        
        // Validate required fields
        const requiredFields = ['crop-code', 'crop-name', 'crop-category'];
        for (const fieldId of requiredFields) {
            const field = document.getElementById(fieldId);
            if (!field.value.trim()) {
                field.focus();
                this.showMessage(`${field.labels[0].textContent} is required`, 'error');
                return;
            }
        }

        // Collect form data
        const cropData = {
            code: document.getElementById('crop-code').value.trim(),
            name: document.getElementById('crop-name').value.trim(),
            scientific_name: document.getElementById('crop-scientific-name').value.trim(),
            category_code: document.getElementById('crop-category').value,
            default_ec_min: parseFloat(document.getElementById('crop-ec-min').value) || null,
            default_ec_max: parseFloat(document.getElementById('crop-ec-max').value) || null,
            default_ph_min: parseFloat(document.getElementById('crop-ph-min').value) || null,
            default_ph_max: parseFloat(document.getElementById('crop-ph-max').value) || null,
            days_to_harvest: parseInt(document.getElementById('crop-days-harvest').value) || null,
            plant_spacing_cm: parseInt(document.getElementById('crop-plant-spacing').value) || null,
            light_requirements: document.getElementById('crop-light-requirements').value,
            growing_notes: document.getElementById('crop-growing-notes').value.trim(),
            research_source: document.getElementById('crop-research-source').value.trim()
        };

        try {
            const result = await CropKnowledgeAPI.saveAdminCrop(
                cropData, 
                !!this.currentEditingCrop, 
                this.currentEditingCrop
            );
            
            if (result.success) {
                this.showMessage(result.message || 'Crop saved successfully', 'success');
                this.closeCropManagementModal();
                this.loadAdminCrops(); // Refresh the crops list
            } else {
                throw new Error(result.error || 'Failed to save crop');
            }

        } catch (error) {
            console.error('Error saving crop:', error);
            this.showMessage(error.message || 'Failed to save crop', 'error');
        }
    }

    editCrop(cropCode) {
        this.openCropManagementModal(cropCode);
    }

    async deleteCrop(cropCode, cropName) {
        if (!confirm(`Are you sure you want to delete "${cropName}"? This action cannot be undone.`)) {
            return;
        }

        try {
            const result = await CropKnowledgeAPI.deleteAdminCrop(cropCode);
            
            if (result.success) {
                this.showMessage(`Crop "${cropName}" deleted successfully`, 'success');
                this.loadAdminCrops(); // Refresh the crops list
            } else {
                throw new Error(result.error || 'Failed to delete crop');
            }

        } catch (error) {
            console.error('Error deleting crop:', error);
            this.showMessage(error.message || 'Failed to delete crop', 'error');
        }
    }

    async openNutrientTargetsModal(cropCode, cropName) {
        const modal = document.getElementById('nutrient-targets-modal');
        const cropNameSpan = document.getElementById('nutrient-crop-name');
        
        if (!modal) return;

        cropNameSpan.textContent = cropName;
        this.currentNutrientCrop = cropCode;
        
        modal.style.display = 'block';
        await this.loadNutrientTargets(cropCode);
    }

    async loadNutrientTargets(cropCode) {
        try {
            const data = await CropKnowledgeAPI.fetchCropTargets(cropCode);
            
            if (data.success) {
                this.displayNutrientTargets(data.data);
            } else {
                throw new Error(data.error || 'Failed to load nutrient targets');
            }

        } catch (error) {
            console.error('Error loading nutrient targets:', error);
            this.showMessage('Failed to load nutrient targets', 'error');
        }
    }

    displayNutrientTargets(targets) {
        const container = document.getElementById('nutrient-targets-container');
        if (!container) return;

        if (targets.length === 0) {
            container.innerHTML = `
                <div class="crop-empty-state">
                    <img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="No Targets">
                    <h4>No nutrient targets configured</h4>
                    <p>Add nutrient targets to define the optimal growing conditions.</p>
                </div>
            `;
            return;
        }

        let html = '';
        targets.forEach(target => {
            html += `
                <div class="nutrient-target-item" data-target-id="${target.id}">
                    <div class="nutrient-target-header">
                        <div class="nutrient-target-name">
                            <img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Nutrient" class="btn-icon-svg">
                            ${target.nutrient_name} (${target.symbol}) - ${target.stage_name}
                        </div>
                        <button class="btn-danger" onclick="app.deleteNutrientTarget(${target.id})" title="Delete Target">
                            √ó
                        </button>
                    </div>
                    <div class="nutrient-values-grid">
                        <div class="form-field">
                            <label>Target Value</label>
                            <input type="number" step="0.1" value="${target.target_value}" 
                                   onchange="app.updateNutrientTarget(${target.id}, 'target_value', this.value)">
                            <small>${target.unit}</small>
                        </div>
                        <div class="form-field">
                            <label>Min Value</label>
                            <input type="number" step="0.1" value="${target.min_value || ''}" 
                                   onchange="app.updateNutrientTarget(${target.id}, 'min_value', this.value)">
                            <small>${target.unit}</small>
                        </div>
                        <div class="form-field">
                            <label>Max Value</label>
                            <input type="number" step="0.1" value="${target.max_value || ''}" 
                                   onchange="app.updateNutrientTarget(${target.id}, 'max_value', this.value)">
                            <small>${target.unit}</small>
                        </div>
                    </div>
                    <div class="form-field">
                        <label>Notes</label>
                        <textarea rows="2" placeholder="Optional notes about this nutrient target..."
                                  onchange="app.updateNutrientTarget(${target.id}, 'notes', this.value)">${target.notes || ''}</textarea>
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
    }

    closeNutrientTargetsModal() {
        const modal = document.getElementById('nutrient-targets-modal');
        if (modal) {
            modal.style.display = 'none';
            this.currentNutrientCrop = null;
        }
    }

    async updateNutrientTarget(targetId, field, value) {
        try {
            const updateData = {};
            updateData[field] = value === '' ? null : (field === 'notes' ? value : parseFloat(value));
            
            const result = await CropKnowledgeAPI.updateCropTarget(targetId, updateData);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to update nutrient target');
            }

        } catch (error) {
            console.error('Error updating nutrient target:', error);
            this.showMessage('Failed to update nutrient target', 'error');
        }
    }

    async addNutrientTarget() {
        const cropCode = this.currentNutrientCrop;
        if (!cropCode) return;

        try {
            // Show a form to add a new nutrient target
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Add Nutrient Target</h2>
                        <button class="close-btn" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>Nutrient</label>
                            <select id="new-nutrient-code" class="form-input">
                                <option value="nitrogen">Nitrogen (N)</option>
                                <option value="phosphorus">Phosphorus (P)</option>
                                <option value="potassium">Potassium (K)</option>
                                <option value="calcium">Calcium (Ca)</option>
                                <option value="magnesium">Magnesium (Mg)</option>
                                <option value="iron">Iron (Fe)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Growth Stage</label>
                            <select id="new-growth-stage" class="form-input">
                                <option value="seedling">Seedling</option>
                                <option value="vegetative">Vegetative</option>
                                <option value="flowering">Flowering</option>
                                <option value="fruiting">Fruiting</option>
                                <option value="general">General</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Target Value</label>
                            <input type="number" id="new-target-value" class="form-input" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label>Min Value</label>
                            <input type="number" id="new-min-value" class="form-input" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Max Value</label>
                            <input type="number" id="new-max-value" class="form-input" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Notes</label>
                            <textarea id="new-notes" class="form-input" rows="3"></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                        <button class="btn btn-primary" onclick="app.saveNewNutrientTarget()">Save Target</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        } catch (error) {
            console.error('Error showing add nutrient target form:', error);
            this.showMessage('Failed to show add nutrient target form', 'error');
        }
    }

    async saveNewNutrientTarget() {
        try {
            const cropCode = this.currentNutrientCrop;
            const nutrientCode = document.getElementById('new-nutrient-code').value;
            const growthStage = document.getElementById('new-growth-stage').value;
            const targetValue = parseFloat(document.getElementById('new-target-value').value);
            const minValue = document.getElementById('new-min-value').value ? parseFloat(document.getElementById('new-min-value').value) : null;
            const maxValue = document.getElementById('new-max-value').value ? parseFloat(document.getElementById('new-max-value').value) : null;
            const notes = document.getElementById('new-notes').value || null;

            if (!targetValue) {
                this.showMessage('Target value is required', 'error');
                return;
            }

            const targetsData = {
                nutrient_code: nutrientCode,
                growth_stage: growthStage,
                target_value: targetValue,
                min_value: minValue,
                max_value: maxValue,
                notes: notes
            };

            const result = await CropKnowledgeAPI.createCropTargets(cropCode, targetsData);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to add nutrient target');
            }

            // Close the add modal
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (modal.innerHTML.includes('Add Nutrient Target')) {
                    modal.remove();
                }
            });

            // Reload the nutrient targets
            await this.loadNutrientTargets(cropCode);
            this.showMessage('Nutrient target added successfully', 'success');

        } catch (error) {
            console.error('Error saving nutrient target:', error);
            this.showMessage('Failed to save nutrient target', 'error');
        }
    }

    async deleteNutrientTarget(targetId) {
        if (!confirm('Are you sure you want to delete this nutrient target?')) {
            return;
        }

        try {
            const result = await CropKnowledgeAPI.deleteCropTarget(targetId);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to delete nutrient target');
            }

            // Reload the nutrient targets
            await this.loadNutrientTargets(this.currentNutrientCrop);
            this.showMessage('Nutrient target deleted successfully', 'success');

        } catch (error) {
            console.error('Error deleting nutrient target:', error);
            this.showMessage('Failed to delete nutrient target', 'error');
        }
    }

    // Seed Varieties Management Methods
    async openSeedVarietiesModal(cropCode, cropName) {
        const modal = document.getElementById('seed-varieties-modal');
        const cropNameSpan = document.getElementById('varieties-crop-name');
        
        if (!modal) return;

        cropNameSpan.textContent = cropName;
        this.currentVarietiesCrop = cropCode;
        
        modal.style.display = 'block';
        await this.loadSeedVarieties(cropCode);
    }

    async loadSeedVarieties(cropCode) {
        try {
            const data = await CropKnowledgeAPI.fetchSeedVarieties(cropCode);
            
            if (!data.success) {
                throw new Error(data.error || 'Failed to load seed varieties');
            }

            this.displaySeedVarieties(data.varieties || []);

        } catch (error) {
            console.error('Error loading seed varieties:', error);
            this.showMessage('Failed to load seed varieties', 'error');
        }
    }

    displaySeedVarieties(varieties) {
        const container = document.getElementById('seed-varieties-container');
        if (!container) return;

        if (varieties.length === 0) {
            container.innerHTML = `
                <div class="crop-empty-state">
                    <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="No Varieties">
                    <h4>No seed varieties configured</h4>
                    <p>Add seed varieties to make them available for planting.</p>
                </div>
            `;
            return;
        }

        let html = '';
        varieties.forEach(variety => {
            html += `
                <div class="seed-variety-item" data-variety-id="${variety.id}">
                    <div class="seed-variety-content">
                        <div class="seed-variety-name">
                            <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="Variety" class="btn-icon-svg">
                            ${variety.variety_name}
                        </div>
                        <div class="seed-variety-actions">
                            <button class="btn-danger btn-small" onclick="app.deleteSeedVariety(${variety.id}, '${variety.variety_name}')" title="Delete Variety">
                                √ó
                            </button>
                        </div>
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
    }

    closeSeedVarietiesModal() {
        const modal = document.getElementById('seed-varieties-modal');
        if (modal) {
            modal.style.display = 'none';
            this.currentVarietiesCrop = null;
        }
    }

    async addSeedVariety() {
        const cropCode = this.currentVarietiesCrop;
        if (!cropCode) return;

        try {
            // Show a simple prompt for the variety name
            const varietyName = prompt('Enter the name of the new seed variety:');
            if (!varietyName || varietyName.trim() === '') {
                return;
            }

            const varietyData = {
                crop_type: cropCode,
                variety_name: varietyName.trim()
            };

            const result = await CropKnowledgeAPI.saveSeedVariety(varietyData);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to add seed variety');
            }

            // Reload the varieties
            await this.loadSeedVarieties(cropCode);
            this.showMessage(`Seed variety "${varietyName}" added successfully`, 'success');

        } catch (error) {
            console.error('Error adding seed variety:', error);
            this.showMessage('Failed to add seed variety', 'error');
        }
    }

    async deleteSeedVariety(varietyId, varietyName) {
        if (!confirm(`Are you sure you want to delete the seed variety "${varietyName}"?`)) {
            return;
        }

        try {
            const result = await CropKnowledgeAPI.deleteSeedVariety(varietyId);
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to delete seed variety');
            }

            // Reload the varieties
            await this.loadSeedVarieties(this.currentVarietiesCrop);
            this.showMessage(`Seed variety "${varietyName}" deleted successfully`, 'success');

        } catch (error) {
            console.error('Error deleting seed variety:', error);
            this.showMessage('Failed to delete seed variety', 'error');
        }
    }

    // Plant Management Methods
    async loadPlantAllocations() {
        if (!this.activeSystemId) return;
        
        // REMOVED: Allocation system - replaced with direct batch-based space tracking
    }

    // REMOVED: displayPlantAllocations - replaced with batch-based space tracking

    // REMOVED: generateCropOptionsHtml - no longer needed without allocations

    // REMOVED: generateEditCropOptionsHtml - no longer needed without allocations

    getBedTypeDisplayName(bedType) {
        const bedTypeNames = {
            'dwc': 'Deep Water Culture',
            'flood-drain': 'Flood & Drain',
            'nft': 'NFT',
            'vertical': 'Vertical',
            'mft': 'Media Fill Technique'
        };
        return bedTypeNames[bedType] || bedType.toUpperCase();
    }

    getBedTypeIcon(bedType) {
        const iconPath = `/icons/new-icons/`;
        const iconMap = {
            'dwc': 'Afraponix Go Icons_DWC.svg',
            'nft': 'Afraponix Go Icons_NFT.svg', 
            'flood-drain': 'Afraponix Go Icons_flood drain.svg',
            'vertical': 'Afraponix Go Icons_vertical.svg',
            'mft': 'Afraponix Go Icons_flow through.svg'
        };
        
        const iconFile = iconMap[bedType] || 'Afraponix Go Icons_flow through.svg';
        return `<img src="${iconPath}${iconFile}" alt="${this.getBedTypeDisplayName(bedType)}" class="bed-type-icon" />`;
    }

    calculatePlantCount(bedId) {
        const spacingInput = document.getElementById(`spacing-${bedId}`);
        const areaInput = document.getElementById(`area-${bedId}`);
        const calculatedPlantsDiv = document.getElementById(`calculated-plants-${bedId}`);
        
        if (!spacingInput || !areaInput || !calculatedPlantsDiv) return;
        
        const spacing = parseFloat(spacingInput.value) || 30; // Default 30cm
        const area = parseFloat(areaInput.value) || 0;
        
        if (area > 0 && spacing > 0) {
            // Convert area from m¬≤ to cm¬≤
            const areaCm2 = area * 10000;
            
            // Calculate using square grid pattern
            // Each plant needs spacing x spacing cm¬≤
            const spacePerPlant = spacing * spacing;
            const plantCount = Math.floor(areaCm2 / spacePerPlant);
            
            const plantCountSpan = calculatedPlantsDiv.querySelector('.plant-count-value');
            if (plantCountSpan) {
                plantCountSpan.textContent = plantCount;
            }
        }
    }

    updateTotalPlants(bedId) {
        const plantsInput = document.getElementById(`plants-${bedId}`);
        const totalPlantsSpan = document.getElementById(`total-plants-${bedId}`);
        
        if (!plantsInput || !totalPlantsSpan) return;
        
        const plantsPerVertical = parseInt(plantsInput.value) || 0;
        
        // Get the number of verticals from the grow bed data
        // We need to find the bed data to get vertical count
        let verticalCount = 1;
        try {
            // Look for the bed data in the current system
            const bedElement = document.querySelector(`[data-bed-id="${bedId}"]`);
            if (bedElement) {
                const bedData = JSON.parse(bedElement.getAttribute('data-bed-info') || '{}');
                verticalCount = bedData.vertical_count || 1;
            }
        } catch (error) {
            console.error('Error getting vertical count:', error);
        }
        
        const totalPlants = plantsPerVertical * verticalCount;
        totalPlantsSpan.textContent = `Total: ${totalPlants} plants`;
    }

    cleanCustomCropName(cropName) {
        if (!cropName) return '';
        
        // Common patterns to remove from crop names
        const patternsToRemove = [
            /\s+(justin|admin|user|test)\s*$/i,  // Remove common suffixes like usernames
            /\s*_\s*(justin|admin|user|test)\s*$/i,  // Remove underscore patterns
            /\s*-\s*(justin|admin|user|test)\s*$/i,  // Remove hyphen patterns
        ];
        
        let cleanName = cropName;
        
        // Apply each pattern
        patternsToRemove.forEach(pattern => {
            cleanName = cleanName.replace(pattern, '');
        });
        
        // Clean up any extra spaces and normalize
        cleanName = cleanName.trim().replace(/\s+/g, ' ');
        
        // Convert underscores to spaces for better display
        cleanName = cleanName.replace(/_/g, ' ');
        
        return cleanName;
    }

    getCropIcon(cropType) {
        if (!cropType) return 'üå±';
        
        const cropLower = cropType.toLowerCase();
        
        // Map crop types to appropriate icons
        if (cropLower.includes('lettuce')) return 'ü•¨';
        if (cropLower.includes('tomato')) return 'üçÖ';
        if (cropLower.includes('carrot')) return 'ü•ï';
        if (cropLower.includes('pepper')) return 'üå∂Ô∏è';
        if (cropLower.includes('herb') || cropLower.includes('basil') || cropLower.includes('mint')) return 'üåø';
        if (cropLower.includes('spinach')) return 'ü•¨';
        if (cropLower.includes('cucumber')) return 'ü•í';
        if (cropLower.includes('onion') || cropLower.includes('spring_onion')) return 'üßÖ';
        if (cropLower.includes('leeks')) return 'üßÖ';
        if (cropLower.includes('celery')) return 'ü•¨';
        if (cropLower.includes('radish')) return 'ü•¨';
        if (cropLower.includes('beet')) return 'üü£';
        if (cropLower.includes('kale')) return 'ü•¨';
        if (cropLower.includes('chard')) return 'ü•¨';
        
        // Default plant icon
        return 'üå±';
    }

    cleanCropName(cropType) {
        // Use the existing cleanCustomCropName function and capitalize
        const cleanName = this.cleanCustomCropName(cropType);
        return cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
    }

    // Area slider synchronization functions
    updateAreaValue(bedId, value) {
        const areaInput = document.getElementById(`area-${bedId}`);
        if (areaInput) {
            // Check if this is a vertical bed (integer values) or regular bed (decimal values)
            const isVertical = areaInput.getAttribute('step') === '1';
            const newValue = isVertical ? parseInt(value) : parseFloat(value).toFixed(1);
            areaInput.value = newValue;
            
            // For vertical beds, don't call calculatePlantCount as it's not relevant
            if (!isVertical) {
                this.calculatePlantCount(bedId);
            }
        }
    }

    updateAreaSlider(bedId, value) {
        const areaSlider = document.getElementById(`area-slider-${bedId}`);
        if (areaSlider) {
            areaSlider.value = value;
        }
    }

    async addAllocation(bedId) {

        const cropSelect = document.getElementById(`crop-${bedId}`);
        const areaInput = document.getElementById(`area-${bedId}`);
        const plantsInput = document.getElementById(`plants-${bedId}`);
        const spacingInput = document.getElementById(`spacing-${bedId}`);

        if (!cropSelect || !areaInput) {
            console.error('‚ùå Missing form elements');
            this.showNotification('‚ùå Form elements not found. Please refresh the page.', 'error');
            return;
        }
        
        const cropType = cropSelect.value;
        const inputValue = parseFloat(areaInput.value);
        let plants = 0;
        
        // Get bed data for calculations
        const bedData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
        const bed = bedData.find(b => b.id == bedId);
        
        if (bed?.bed_type === 'vertical') {
            // For vertical beds, use direct plant count input
            plants = parseInt(plantsInput?.value) || 0;
            if (!plants || plants <= 0) {
                this.showNotification('Please enter number of plants per vertical', 'warning');
                return;
            }
            // Total plants = plants per vertical * number of verticals
            plants = plants * inputValue;
        } else {
            // For regular beds, calculate from spacing
            const spacing = parseFloat(spacingInput?.value) || 30;
            const areaCm2 = inputValue * 10000;
            const spacePerPlant = spacing * spacing;
            plants = Math.floor(areaCm2 / spacePerPlant);

        }
        
        let percentage;
        let displayValue;
        let displayUnit;
        
        if (bed?.bed_type === 'vertical') {
            // For vertical beds, input is number of verticals
            const totalVerticals = bed.vertical_count || 10;
            percentage = totalVerticals > 0 ? (inputValue / totalVerticals) * 100 : 0;
            displayValue = inputValue;
            displayUnit = 'verticals';
        } else {
            // For other beds, input is area in m¬≤
            const bedAreaM2 = parseFloat(bed?.equivalent_m2) || 0;
            percentage = bedAreaM2 > 0 ? (inputValue / bedAreaM2) * 100 : 0;
            displayValue = inputValue;
            displayUnit = 'm¬≤';
        }

        if (!cropType) {
            this.showNotification('üå± Please select a crop type', 'warning');
            return;
        }
        
        if (!inputValue || inputValue <= 0) {
            this.showNotification(`üìê Please enter a valid ${displayUnit === 'verticals' ? 'number of verticals' : 'area (m¬≤)'}`, 'warning');
            return;
        }
        
        if (bed?.bed_type === 'vertical') {
            const maxVerticals = bed.vertical_count || 10;
            if (inputValue > maxVerticals) {
                this.showNotification(`üìê Cannot exceed ${maxVerticals} verticals`, 'warning');
                return;
            }
        } else {
            const bedAreaM2 = parseFloat(bed?.equivalent_m2) || 0;

            if (inputValue > bedAreaM2) {
                this.showNotification(`üìê Area cannot exceed bed size (${bedAreaM2.toFixed(1)}m¬≤)`, 'warning');
                return;
            }
        }

        if (!this.activeSystemId) {
            console.error('‚ùå No active system ID');
            this.showNotification('‚ùå No active system selected', 'error');
            return;
        }

        // Get plant spacing for non-vertical beds
        let plantSpacing = 30; // default
        if (bed?.bed_type !== 'vertical' && spacingInput) {
            plantSpacing = parseInt(spacingInput.value) || 30;
        }

        try {
            const response = await this.makeApiCall('/plants/allocations', {
                method: 'POST',
                body: JSON.stringify({
                    systemId: this.activeSystemId,
                    growBedId: bedId,
                    cropType,
                    percentageAllocated: percentage,
                    plantsPlanted: plants,
                    datePlanted: new Date().toISOString().split('T')[0],
                    plantSpacing: plantSpacing
                })
            });

            this.showNotification(`üå± ${cropType} allocation (${displayValue} ${displayUnit}) added successfully!`, 'success');
            
            // Reset form
            cropSelect.value = '';
            const areaInput = document.getElementById(`area-${bedId}`);
            const areaSlider = document.getElementById(`area-slider-${bedId}`);
            const defaultValue = bed?.bed_type === 'vertical' ? '1' : '1.0';
            if (areaInput) areaInput.value = defaultValue;
            if (areaSlider) areaSlider.value = defaultValue;
            if (plantsInput) plantsInput.value = '';
            if (spacingInput) spacingInput.value = '30';
            
            // Reset calculated plants display
            const calculatedPlantsDiv = document.getElementById(`calculated-plants-${bedId}`);
            if (calculatedPlantsDiv) {
                const plantCountSpan = calculatedPlantsDiv.querySelector('.plant-count-value');
                if (plantCountSpan) {
                    plantCountSpan.textContent = '0';
                }
            }
            
            this.loadPlantAllocations();
            // Update harvest crop dropdown with new allocation
            await this.populateHarvestCropDropdown();
        } catch (error) {
            console.error('‚ùå Error adding allocation:', error);
            this.showNotification('‚ùå Failed to add crop allocation: ' + (error.message || 'Unknown error'), 'error');
        }
    }

    async editAllocation(allocationId, bedId, cropType, currentAreaM2, currentPlants) {
        // Find the allocation item
        const allocationItem = document.getElementById(`allocation-${allocationId}`);
        if (!allocationItem) return;

        // Get bed information to determine if it's vertical
        let bedData = null;
        try {
            const fullBedData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            bedData = fullBedData.find(bed => bed.id === bedId || bed.bed_number === bedId);
        } catch (error) {
            console.error('Failed to fetch bed data for edit:', error);
        }

        // Get current allocation data to calculate percentage - fetch fresh data
        let allocations = [];
        try {
            allocations = await this.makeApiCall(`/plants/allocations/${this.activeSystemId}`);
        } catch (error) {
            console.error('Failed to fetch allocations for edit:', error);
            allocations = this.dataRecords.plantAllocations || [];
        }
        
        const currentAllocation = allocations.find(alloc => parseInt(alloc.id) === parseInt(allocationId));
        const currentPercentage = currentAllocation ? Math.round(parseFloat(currentAllocation.percentage_allocated) || 0) : 50;

        // Calculate current verticals if it's a vertical bed
        const isVertical = bedData && bedData.bed_type === 'vertical';
        const currentVerticals = isVertical && bedData ? Math.round(currentPercentage * (bedData.vertical_count || 1) / 100) : 0;
        
        // Calculate available area/verticals for editing (current allocation + remaining available)
        let maxEditVerticals = bedData ? bedData.vertical_count || 1 : 1;
        let minEditVerticals = 1;
        let maxEditArea = bedData ? bedData.equivalent_m2 || 2 : 2;
        let currentEditArea = ((currentPercentage / 100) * maxEditArea);
        
        if (isVertical && bedData) {
            // Get all allocations for this bed except the current one being edited
            const otherAllocations = allocations.filter(alloc => parseInt(alloc.grow_bed_id) === parseInt(bedId) && parseInt(alloc.id) !== parseInt(allocationId));
            const otherAllocatedPercentage = otherAllocations.reduce((sum, alloc) => sum + (parseFloat(alloc.percentage_allocated) || 0), 0);
            const availablePercentage = 100 - otherAllocatedPercentage;
            maxEditVerticals = Math.round(availablePercentage * (bedData.vertical_count || 1) / 100);
            
            // If there are no available verticals beyond current allocation, only allow editing within current range
            if (maxEditVerticals <= 0) {
                maxEditVerticals = currentVerticals;
                minEditVerticals = Math.min(1, currentVerticals);
            } else {
                minEditVerticals = 1;
            }
        } else {
            // For regular beds, calculate available area
            const otherAllocations = allocations.filter(alloc => parseInt(alloc.grow_bed_id) === parseInt(bedId) && parseInt(alloc.id) !== parseInt(allocationId));
            const otherAllocatedPercentage = otherAllocations.reduce((sum, alloc) => sum + (parseFloat(alloc.percentage_allocated) || 0), 0);
            const availablePercentage = 100 - otherAllocatedPercentage;
            const availableArea = (availablePercentage / 100) * (bedData ? bedData.equivalent_m2 || 2 : 2);
            maxEditArea = Math.max(0.1, availableArea);
            currentEditArea = Math.min(currentEditArea, maxEditArea);
        }

        // Generate crop options including custom crops with current selection
        const cropOptionsHtml = await this.generateEditCropOptionsHtml(cropType);
        
        // Clean the crop name for display
        const cleanCropName = this.cleanCustomCropName(cropType);
        const displayName = cleanCropName.charAt(0).toUpperCase() + cleanCropName.slice(1);

        // Create edit form HTML based on bed type
        const editFormHtml = `
            <div class="edit-allocation-form">
                <div class="edit-form-header">
                    <h5>${SVGIcons.getIcon('edit', 'icon-svg small')} Edit ${displayName} Allocation</h5>
                </div>
                
                <div class="edit-form-body">
                    <div class="edit-form-row">
                        <label class="edit-label">Crop Type:</label>
                        <select class="edit-crop-select" id="edit-crop-${allocationId}">
                            ${cropOptionsHtml}
                        </select>
                    </div>
                    
                    ${isVertical ? `
                        <div class="edit-form-row">
                            <label class="edit-label">Verticals:</label>
                            <div class="edit-slider-container">
                                <input type="range" class="edit-vertical-slider" id="edit-verticals-${allocationId}" 
                                       min="${minEditVerticals}" max="${maxEditVerticals}" value="${Math.max(minEditVerticals, currentVerticals)}" step="1"
                                       oninput="app.updateEditVerticalValue(${allocationId}, this.value)" />
                                <div class="edit-slider-value">
                                    <span id="edit-vertical-value-${allocationId}">${Math.max(minEditVerticals, currentVerticals)}</span> verticals
                                </div>
                            </div>
                        </div>
                        
                        <div class="edit-form-row">
                            <label class="edit-label">Plants per Vertical:</label>
                            <input type="number" class="edit-plants-per-vertical-input" id="edit-plants-per-vertical-${allocationId}" 
                                   min="1" value="${bedData ? bedData.plants_per_vertical || 48 : 48}" placeholder="Plants per vertical" />
                        </div>
                    ` : `
                        <div class="edit-form-row">
                            <label class="edit-label">Area (m¬≤):</label>
                            <div class="edit-area-container">
                                <div class="edit-area-slider-container">
                                    <input type="range" class="edit-area-slider" id="edit-area-slider-${allocationId}" 
                                           min="0.1" max="${maxEditArea.toFixed(1)}" 
                                           step="0.1" value="${currentEditArea.toFixed(1)}" 
                                           oninput="app.updateEditAreaValue(${allocationId}, this.value)" />
                                    <div class="edit-area-controls-row">
                                        <div class="edit-area-value-display">
                                            <input type="number" class="edit-area-input" id="edit-area-${allocationId}" 
                                                   min="0.1" max="${maxEditArea.toFixed(1)}" 
                                                   step="0.1" value="${currentEditArea.toFixed(1)}" 
                                                   oninput="app.updateEditAreaSlider(${allocationId}, this.value)"
                                                   placeholder="Area in m¬≤" />
                                            <span class="edit-area-unit">m¬≤</span>
                                        </div>
                                        <div class="edit-spacing-display">
                                            <label class="edit-inline-label">Spacing:</label>
                                            <input type="number" class="edit-spacing-input" id="edit-spacing-${allocationId}" 
                                                   min="10" max="100" step="1" value="${currentAllocation ? currentAllocation.plant_spacing || 30 : 30}" 
                                                   placeholder="30" oninput="app.updateEditPlantCountFromSpacing(${allocationId})" />
                                            <span class="edit-spacing-unit">cm</span>
                                        </div>
                                        <div class="edit-plants-display">
                                            <label class="edit-inline-label">Plants:</label>
                                            <input type="number" class="edit-plants-input" id="edit-plants-${allocationId}" 
                                                   min="0" value="${currentPlants}" placeholder="0" readonly />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `}
                </div>
                
                <div class="edit-form-actions">
                    <button onclick="app.saveAllocationEdit(${allocationId}, ${bedId})" class="save-edit-btn">
                        <span class="btn-icon">üíæ</span>
                        Save Changes
                    </button>
                    <button onclick="app.cancelAllocationEdit(${allocationId})" class="cancel-edit-btn">
                        <span class="btn-icon">‚ùå</span>
                        Cancel
                    </button>
                </div>
            </div>
        `;

        // Store original content and replace with edit form
        allocationItem.dataset.originalContent = allocationItem.innerHTML;
        allocationItem.innerHTML = editFormHtml;
        allocationItem.classList.add('editing');
        
        // Calculate initial plant count based on current area for non-vertical beds
        if (!isVertical) {
            await this.updateEditPlantCountFromArea(allocationId, currentEditArea);
        }
    }

    updateEditAreaValue(allocationId, areaValue) {
        const areaInput = document.getElementById(`edit-area-${allocationId}`);
        if (areaInput) {
            areaInput.value = parseFloat(areaValue).toFixed(1);
        }
        
        // Recalculate plant count based on new area
        this.updateEditPlantCountFromArea(allocationId, parseFloat(areaValue));
    }
    
    updateEditAreaSlider(allocationId, areaValue) {
        const areaSlider = document.getElementById(`edit-area-slider-${allocationId}`);
        if (areaSlider) {
            areaSlider.value = parseFloat(areaValue).toFixed(1);
        }
        
        // Recalculate plant count based on new area
        this.updateEditPlantCountFromArea(allocationId, parseFloat(areaValue));
    }
    
    async updateEditPlantCountFromArea(allocationId, allocatedArea) {
        const plantsInput = document.getElementById(`edit-plants-${allocationId}`);
        const spacingInput = document.getElementById(`edit-spacing-${allocationId}`);
        if (!plantsInput) return;
        
        const plantSpacing = spacingInput ? parseFloat(spacingInput.value) || 30 : 30;
        
        if (allocatedArea > 0 && plantSpacing > 0) {
            // Convert area from m¬≤ to cm¬≤
            const areaCm2 = allocatedArea * 10000;
            
            // Calculate using square grid pattern
            const spacePerPlant = plantSpacing * plantSpacing;
            const plantCount = Math.floor(areaCm2 / spacePerPlant);
            
            plantsInput.value = plantCount;
        }
    }
    
    updateEditPlantCountFromSpacing(allocationId) {
        const areaInput = document.getElementById(`edit-area-${allocationId}`);
        const spacingInput = document.getElementById(`edit-spacing-${allocationId}`);
        const plantsInput = document.getElementById(`edit-plants-${allocationId}`);
        
        if (!areaInput || !spacingInput || !plantsInput) return;
        
        const allocatedArea = parseFloat(areaInput.value) || 0;
        const plantSpacing = parseFloat(spacingInput.value) || 30;
        
        if (allocatedArea > 0 && plantSpacing > 0) {
            // Convert area from m¬≤ to cm¬≤
            const areaCm2 = allocatedArea * 10000;
            
            // Calculate using square grid pattern
            const spacePerPlant = plantSpacing * plantSpacing;
            const plantCount = Math.floor(areaCm2 / spacePerPlant);
            
            plantsInput.value = plantCount;
        }
    }

    updateEditVerticalValue(allocationId, value) {
        const verticalValueElement = document.getElementById(`edit-vertical-value-${allocationId}`);
        const plantsInput = document.getElementById(`edit-plants-${allocationId}`);
        const plantsPerVerticalInput = document.getElementById(`edit-plants-per-vertical-${allocationId}`);
        
        if (verticalValueElement) {
            verticalValueElement.textContent = value;
        }
        
        // Update plant count calculation for vertical beds
        if (plantsInput && plantsPerVerticalInput) {
            const plantsPerVertical = parseInt(plantsPerVerticalInput.value) || 48;
            const totalPlants = parseInt(value) * plantsPerVertical;
            plantsInput.value = totalPlants;
        }
    }

    async saveAllocationEdit(allocationId, bedId) {
        const cropSelect = document.getElementById(`edit-crop-${allocationId}`);
        const plantsInput = document.getElementById(`edit-plants-${allocationId}`);
        
        // Check if this is a vertical bed edit (has vertical slider) or regular bed (has area slider)
        const verticalSlider = document.getElementById(`edit-verticals-${allocationId}`);
        const areaInput = document.getElementById(`edit-area-${allocationId}`);
        
        const cropType = cropSelect.value;
        let percentage;
        
        if (verticalSlider) {
            // For vertical beds, calculate percentage from verticals
            const verticals = parseInt(verticalSlider.value) || 1;
            // Get bed data to calculate percentage
            try {
                const fullBedData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
                const bedData = fullBedData.find(bed => bed.id === bedId || bed.bed_number === bedId);
                const totalVerticals = bedData ? bedData.vertical_count || 1 : 1;
                percentage = (verticals / totalVerticals) * 100;
            } catch (error) {
                console.error('Failed to calculate percentage for vertical bed:', error);
                percentage = 50; // fallback
            }
        } else if (areaInput) {
            // For regular beds, calculate percentage from area
            const area = parseFloat(areaInput.value) || 0;
            try {
                const fullBedData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
                const bedData = fullBedData.find(bed => bed.id === bedId || bed.bed_number === bedId);
                const totalArea = bedData ? bedData.equivalent_m2 || 2 : 2;
                percentage = (area / totalArea) * 100;
            } catch (error) {
                console.error('Failed to calculate percentage from area:', error);
                percentage = 50; // fallback
            }
        } else {
            this.showNotification('üå± Unable to determine allocation method', 'error');
            return;
        }
        
        const plants = parseInt(plantsInput.value) || 0;
        const spacingInput = document.getElementById(`edit-spacing-${allocationId}`);
        const plantSpacing = spacingInput ? parseInt(spacingInput.value) || 30 : 30;

        if (!cropType) {
            this.showNotification('üå± Please select a crop type', 'warning');
            return;
        }

        // Validate plant count against bed capacity
        try {
            const fullBedData = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            const bedData = fullBedData.find(bed => bed.id === bedId || bed.bed_number === bedId);
            
            if (bedData && bedData.bed_type !== 'vertical') {
                // For non-vertical beds, calculate expected plants based on area and spacing
                const bedAreaM2 = parseFloat(bedData.equivalent_m2) || 0;
                const areaCm2 = bedAreaM2 * 10000;
                const spacePerPlant = plantSpacing * plantSpacing;
                const maxPlants = Math.floor(areaCm2 / spacePerPlant);

                if (plants > maxPlants * 1.2) { // Allow 20% buffer for flexibility
                    this.showNotification(`üå± ${plants} plants seems too many for ${bedAreaM2.toFixed(1)}m¬≤ bed. Maximum recommended: ${maxPlants} plants with ${plantSpacing}cm spacing.`, 'warning');
                    return;
                }
            }
        } catch (error) {
            console.error('Failed to validate plant count:', error);
            // Continue with saving if validation fails
        }

        try {
            await this.makeApiCall(`/plants/allocations/${allocationId}`, {
                method: 'PUT',
                body: JSON.stringify({
                    cropType,
                    percentageAllocated: percentage,
                    plantsPlanted: plants,
                    plantSpacing: plantSpacing
                })
            });

            this.showNotification(`‚úÖ ${cropType} allocation updated successfully!`, 'success');
            this.loadPlantAllocations();
            // Update harvest crop dropdown with updated allocation
            await this.populateHarvestCropDropdown();
        } catch (error) {
            console.error('Error updating allocation:', error);
            this.showNotification('‚ùå Failed to update crop allocation', 'error');
        }
    }

    cancelAllocationEdit(allocationId) {
        const allocationItem = document.getElementById(`allocation-${allocationId}`);
        if (allocationItem && allocationItem.dataset.originalContent) {
            allocationItem.innerHTML = allocationItem.dataset.originalContent;
            allocationItem.classList.remove('editing');
            delete allocationItem.dataset.originalContent;
        }
    }

    async removeAllocation(allocationId) {
        if (!confirm('Are you sure you want to remove this crop allocation?')) {
            return;
        }

        try {
            await this.makeApiCall(`/plants/allocations/${allocationId}`, {
                method: 'DELETE'
            });
            
            this.showNotification('Crop allocation removed successfully', 'success');
            this.loadPlantAllocations();
            // Update harvest crop dropdown after removing allocation
            await this.populateHarvestCropDropdown();
        } catch (error) {
            console.error('Error removing allocation:', error);
            this.showNotification('‚ùå Failed to remove crop allocation', 'error');
        }
    }

    confirmDeleteSystem() {
        const systemName = this.getCurrentSystemName();
        
        // Set the system name in the modal
        document.getElementById('system-name-to-delete').textContent = systemName;
        
        // Clear any previous input
        const confirmInput = document.getElementById('delete-confirmation');
        confirmInput.value = '';
        confirmInput.classList.remove('valid');
        
        // Reset delete button state
        const deleteBtn = document.getElementById('delete-confirm-btn');
        deleteBtn.disabled = true;
        
        // Show modal
        const modal = document.getElementById('delete-system-modal');
        modal.classList.add('show');
        
        // Focus on input
        setTimeout(() => confirmInput.focus(), 100);
        
        // Add input listener to enable/disable delete button
        const inputHandler = (e) => {
            const isValid = e.target.value === 'DELETE';
            deleteBtn.disabled = !isValid;
            
            if (isValid) {
                e.target.classList.add('valid');
            } else {
                e.target.classList.remove('valid');
            }
        };
        
        // Remove any existing listeners and add new one
        confirmInput.removeEventListener('input', inputHandler);
        confirmInput.addEventListener('input', inputHandler);
        
        // Add Enter key handler
        const enterHandler = (e) => {
            if (e.key === 'Enter' && e.target.value === 'DELETE') {
                this.executeDeleteSystem();
            }
        };
        
        confirmInput.removeEventListener('keydown', enterHandler);
        confirmInput.addEventListener('keydown', enterHandler);
    }

    cancelDeleteSystem() {
        const modal = document.getElementById('delete-system-modal');
        modal.classList.remove('show');
        
        // Clear input
        const confirmInput = document.getElementById('delete-confirmation');
        confirmInput.value = '';
        confirmInput.classList.remove('valid');
    }

    executeDeleteSystem() {
        const confirmInput = document.getElementById('delete-confirmation');
        
        if (confirmInput.value !== 'DELETE') {
            this.showNotification('‚ùå Please type "DELETE" to confirm', 'warning');
            return;
        }
        
        // Hide modal
        this.cancelDeleteSystem();
        
        // Execute deletion
        this.deleteSystem();
    }

    getCurrentSystemName() {
        // Get current system name from the display or default
        const systemDisplay = document.getElementById('current-system-settings');
        if (systemDisplay && systemDisplay.textContent) {
            const match = systemDisplay.textContent.match(/System: (.+)/);
            return match ? match[1] : 'Current System';
        }
        return 'Current System';
    }

    async deleteSystem() {
        if (!this.activeSystemId) {
            this.showNotification('‚ùå No active system to delete', 'error');
            return;
        }

        try {
            this.showNotification('Deleting system...', 'info');
            
            await this.makeApiCall(`/systems/${this.activeSystemId}`, {
                method: 'DELETE'
            });

            this.showNotification('‚úÖ System deleted successfully', 'success');
            
            // Clear local system data
            this.activeSystemId = null;
            this.systems = [];
            
            // Reload user data to get updated system list
            await this.loadUserData();
            
            // If no systems left, show system creation
            if (Object.keys(this.systems).length === 0) {
                // Clear the flag so the modal shows again
                localStorage.removeItem('hasSeenSystemModal');
                this.showAddSystemDialog();
            }
            
        } catch (error) {
            console.error('Error deleting system:', error);
            this.showNotification('‚ùå Failed to delete system: ' + (error.message || 'Unknown error'), 'error');
        }
    }

    async loadCustomCrops() {
        return this.customCropManager.loadCustomCrops();
    }

    displayCustomCrops(crops) {
        return this.customCropManager.displayCustomCrops(crops);
    }

    updateCropDropdowns(customCrops) {
        return this.customCropManager.updateCropDropdowns(customCrops);
    }

    async addCustomCrop() {
        const cropName = document.getElementById('custom-crop-name').value;
        const targetN = parseFloat(document.getElementById('custom-target-n').value) || 0;
        const targetP = parseFloat(document.getElementById('custom-target-p').value) || 0;
        const targetK = parseFloat(document.getElementById('custom-target-k').value) || 0;
        const targetCa = parseFloat(document.getElementById('custom-target-ca').value) || 0;
        const targetMg = parseFloat(document.getElementById('custom-target-mg').value) || 0;
        const targetFe = parseFloat(document.getElementById('custom-target-fe').value) || 0;
        const targetEc = parseFloat(document.getElementById('custom-target-ec').value) || 0;

        if (!cropName.trim()) {
            this.showMessage('Please enter a crop name', 'error');
            return;
        }

        try {
            await this.makeApiCall('/plants/custom-crops', {
                method: 'POST',
                body: JSON.stringify({
                    cropName: cropName.trim(),
                    targetN,
                    targetP,
                    targetK,
                    targetCa,
                    targetMg,
                    targetFe,
                    targetEc
                })
            });

            this.showNotification('‚úÖ Custom crop added successfully!', 'success');
            
            // Clear form
            document.getElementById('custom-crop-name').value = '';
            document.getElementById('custom-target-n').value = '';
            document.getElementById('custom-target-p').value = '';
            document.getElementById('custom-target-k').value = '';
            document.getElementById('custom-target-ca').value = '';
            document.getElementById('custom-target-mg').value = '';
            document.getElementById('custom-target-fe').value = '';
            document.getElementById('custom-target-ec').value = '';
            
            this.loadCustomCrops();
            
            // Refresh allocation dropdowns if on that tab
            const allocationContainer = document.getElementById('grow-bed-allocation-container');
            if (allocationContainer && allocationContainer.style.display !== 'none') {
                this.loadPlantAllocations();
            }
        } catch (error) {
            console.error('Error adding custom crop:', error);
            this.showMessage('Failed to add custom crop', 'error');
        }
    }

    async showAddCustomCropModal() {
        this.showCustomCropModal();
    }
    
    async editCustomCrop(cropId) {
        try {
            // Fetch the crop details
            const crops = await this.makeApiCall('/plants/custom-crops');
            const crop = crops.find(c => c.id === cropId);
            
            if (!crop) {
                this.showNotification('Custom crop not found', 'error');
                return;
            }
            
            // Show modal with existing data
            this.showCustomCropModal(crop);
        } catch (error) {
            console.error('Error loading custom crop:', error);
            this.showNotification('Failed to load custom crop details', 'error');
        }
    }
    
    showCustomCropModal(existingCrop = null) {
        const isEdit = !!existingCrop;
        const modalTitle = isEdit ? 'Edit Custom Crop' : 'Add Custom Crop';
        const buttonText = isEdit ? 'Update Crop' : 'Add Crop';
        
        // Create modal overlay
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.justifyContent = 'center';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        modalContent.style.maxWidth = '500px';
        modalContent.style.padding = '2rem';
        modalContent.style.maxHeight = '90vh';
        modalContent.style.overflowY = 'auto';
        
        modalContent.innerHTML = `
            <h3 style="color: #2e3192; margin-bottom: 1.5rem;">${modalTitle}</h3>
            
            <div class="form-field" style="margin-bottom: 1rem;">
                <label class="modern-label">
                    <span class="label-icon">üåø</span>
                    <span class="label-text">Crop Name</span>
                </label>
                <input type="text" id="custom-crop-name-input" class="modern-input" 
                       placeholder="e.g., Cherry Tomatoes" value="${existingCrop ? this.cleanCustomCropName(existingCrop.crop_name) : ''}" autofocus>
            </div>
            
            <h4 style="color: #495057; margin: 1.5rem 0 1rem 0; font-size: 1rem;">Target Nutrient Levels</h4>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Nitrogen (N) ppm</span>
                    </label>
                    <input type="number" id="target-n" class="modern-input" 
                           placeholder="150" value="${existingCrop?.target_n || ''}" min="0" step="1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Phosphorus (P) ppm</span>
                    </label>
                    <input type="number" id="target-p" class="modern-input" 
                           placeholder="50" value="${existingCrop?.target_p || ''}" min="0" step="1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Potassium (K) ppm</span>
                    </label>
                    <input type="number" id="target-k" class="modern-input" 
                           placeholder="200" value="${existingCrop?.target_k || ''}" min="0" step="1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Calcium (Ca) ppm</span>
                    </label>
                    <input type="number" id="target-ca" class="modern-input" 
                           placeholder="150" value="${existingCrop?.target_ca || ''}" min="0" step="1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Magnesium (Mg) ppm</span>
                    </label>
                    <input type="number" id="target-mg" class="modern-input" 
                           placeholder="50" value="${existingCrop?.target_mg || ''}" min="0" step="1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Iron (Fe) ppm</span>
                    </label>
                    <input type="number" id="target-fe" class="modern-input" 
                           placeholder="2" value="${existingCrop?.target_fe || ''}" min="0" step="0.1">
                </div>
                
                <div class="form-field">
                    <label class="modern-label">
                        <span class="label-text">Target EC (mS/cm)</span>
                    </label>
                    <input type="number" id="target-ec" class="modern-input" 
                           placeholder="2.0" value="${existingCrop?.target_ec || ''}" min="0" step="0.1">
                </div>
            </div>
            
            <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem; justify-content: flex-end;">
                <button type="button" class="btn-secondary" id="cancel-custom-crop">Cancel</button>
                <button type="button" class="btn-primary" id="save-custom-crop">${buttonText}</button>
            </div>
        `;
        
        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);
        
        // Focus the input
        setTimeout(() => {
            document.getElementById('custom-crop-name-input')?.focus();
        }, 100);
        
        // Use CustomCropHandler for save functionality
        if (this.customCropHandler) {
            this.customCropHandler.attachAdvancedCropListeners(modalOverlay, isEdit, existingCrop);
        } else {
            // Fallback for initialization timing issues
            console.warn('CustomCropHandler not available, using fallback');
            const saveHandler = async () => {
                const cropName = document.getElementById('custom-crop-name-input')?.value.trim();
                if (!cropName) {
                    this.showNotification('Please enter a crop name', 'warning');
                    return;
                }
                
                const cropData = {
                    cropName: cropName,
                    targetN: parseFloat(document.getElementById('target-n')?.value) || 0,
                    targetP: parseFloat(document.getElementById('target-p')?.value) || 0,
                    targetK: parseFloat(document.getElementById('target-k')?.value) || 0,
                    targetCa: parseFloat(document.getElementById('target-ca')?.value) || 0,
                    targetMg: parseFloat(document.getElementById('target-mg')?.value) || 0,
                    targetFe: parseFloat(document.getElementById('target-fe')?.value) || 0,
                    targetEc: parseFloat(document.getElementById('target-ec')?.value) || 0,
                    systemId: this.activeSystemId
                };
                
                try {
                    if (isEdit) {
                        await this.makeApiCall(`/plants/custom-crops/${existingCrop.id}`, {
                            method: 'PUT',
                            body: JSON.stringify(cropData)
                        });
                        this.showNotification(`Custom crop "${cropName}" updated successfully!`, 'success');
                    } else {
                        await this.makeApiCall('/plants/custom-crops', {
                            method: 'POST',
                            body: JSON.stringify(cropData)
                        });
                        this.showNotification(`Custom crop "${cropName}" added successfully!`, 'success');
                    }
                    
                    modalOverlay.remove();
                    
                    // Refresh the custom crops display
                    await this.loadCustomCrops();
                    
                    // Update dropdowns in allocations if we're on that tab
                    const allocationsTab = document.querySelector('[data-content="allocate-crops"]');
                    if (allocationsTab && allocationsTab.classList.contains('active')) {
                        await this.loadPlantAllocations();
                    }
                } catch (error) {
                    console.error('Error saving custom crop:', error);
                    this.showNotification('Failed to save custom crop. Please try again.', 'error');
                }
            };
            
            // Event listeners with defensive checks
            const saveCropEditBtn = document.getElementById('save-custom-crop');
            const cancelCropEditBtn = document.getElementById('cancel-custom-crop');
            
            if (saveCropEditBtn) saveCropEditBtn.addEventListener('click', saveHandler);
            if (cancelCropEditBtn) cancelCropEditBtn.addEventListener('click', () => modalOverlay.remove());
            
            // Allow Enter key to save from any input
            const inputs = modalContent.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') saveHandler();
                });
            });
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) modalOverlay.remove();
            });
        }
    }

    async deleteCustomCrop(cropId) {
        if (!confirm('Are you sure you want to delete this custom crop?')) {
            return;
        }

        try {
            await this.makeApiCall(`/plants/custom-crops/${cropId}`, {
                method: 'DELETE'
            });

            this.showNotification('Custom crop deleted successfully!', 'success');
            this.loadCustomCrops();
            
            // Refresh allocation dropdowns if on that tab
            const allocationContainer = document.getElementById('grow-bed-allocation-container');
            if (allocationContainer && allocationContainer.style.display !== 'none') {
                this.loadPlantAllocations();
            }
        } catch (error) {
            console.error('Error deleting custom crop:', error);
            this.showMessage('Failed to delete custom crop', 'error');
        }
    }

    // Custom Crop Integration with Global Database
    async submitToGlobalDatabase(customCropId, cropName) {
        try {
            // Get the custom crop data first
            const customCrops = await this.makeApiCall('/plants/custom-crops');
            const customCrop = customCrops.find(crop => crop.id === customCropId);
            
            if (!customCrop) {
                throw new Error('Custom crop not found');
            }

            // Show detailed submission form
            this.showCropSubmissionForm(customCrop, cropName);

        } catch (error) {
            console.error('Error preparing crop submission:', error);
            this.showMessage(`Failed to prepare "${cropName}" for submission: ${error.message}`, 'error');
        }
    }

    showCropSubmissionForm(customCrop, cropName) {
        // Create submission modal
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'block';
        modal.innerHTML = `
            <div class="modal-content large-modal">
                <div class="modal-header">
                    <h3 class="heading-3">
                        <img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Submit" class="heading-icon"> Submit "${cropName}" to Global Database
                    </h3>
                    <button class="modal-close" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="crop-submission-form">
                        <div class="form-section">
                            <h4 class="heading-4">Basic Information</h4>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Crop Name *</label>
                                    <input type="text" id="submit-crop-name" class="form-input" value="${this.cleanCustomCropName(customCrop.crop_name)}" required>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Scientific Name</label>
                                    <input type="text" id="submit-scientific-name" class="form-input" placeholder="e.g., Lactuca sativa">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Category *</label>
                                    <select id="submit-category" class="form-input" required>
                                        <option value="">Select category...</option>
                                        <option value="leafy_greens">Leafy Greens</option>
                                        <option value="herbs">Herbs</option>
                                        <option value="fruiting_plants">Fruiting Plants</option>
                                        <option value="root_vegetables">Root Vegetables</option>
                                        <option value="brassicas">Brassicas</option>
                                        <option value="user_submitted">User Submitted</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h4 class="heading-4">Growing Parameters</h4>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Days to Harvest</label>
                                    <input type="number" id="submit-days-harvest" class="form-input" placeholder="30-120" min="1" max="365">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Plant Spacing (cm)</label>
                                    <input type="number" id="submit-plant-spacing" class="form-input" placeholder="10-30" min="1" max="100">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Light Requirements</label>
                                    <select id="submit-light-requirements" class="form-input">
                                        <option value="">Select...</option>
                                        <option value="low">Low (100-200 Œºmol/m¬≤/s)</option>
                                        <option value="medium">Medium (200-400 Œºmol/m¬≤/s)</option>
                                        <option value="high">High (400+ Œºmol/m¬≤/s)</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h4 class="heading-4">pH & EC Ranges</h4>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">pH Min</label>
                                    <input type="number" id="submit-ph-min" class="form-input" step="0.1" min="4" max="8" placeholder="5.5">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">pH Max</label>
                                    <input type="number" id="submit-ph-max" class="form-input" step="0.1" min="4" max="8" placeholder="7.0">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">EC Min (mS/cm)</label>
                                    <input type="number" id="submit-ec-min" class="form-input" step="0.1" min="0.5" max="5" placeholder="1.2">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">EC Max (mS/cm)</label>
                                    <input type="number" id="submit-ec-max" class="form-input" step="0.1" min="0.5" max="5" placeholder="2.0">
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h4 class="heading-4">Growing Notes & Experience</h4>
                            <div class="form-group">
                                <label class="form-label">Growing Notes</label>
                                <textarea id="submit-growing-notes" class="form-input" rows="4" placeholder="Share your experience growing this crop: best practices, challenges, tips for success..."></textarea>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Research Source (Optional)</label>
                                <input type="text" id="submit-research-source" class="form-input" placeholder="Books, papers, or online resources you used">
                            </div>
                        </div>

                        <div class="form-section">
                            <h4 class="heading-4">Current Nutrient Targets (from your custom crop)</h4>
                            <div class="nutrient-preview" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; border: 1px solid #e9ecef;">
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem;">
                                    <div><strong>N:</strong> ${customCrop.target_n || 0} ppm</div>
                                    <div><strong>P:</strong> ${customCrop.target_p || 0} ppm</div>
                                    <div><strong>K:</strong> ${customCrop.target_k || 0} ppm</div>
                                    <div><strong>Ca:</strong> ${customCrop.target_ca || 0} ppm</div>
                                    <div><strong>Mg:</strong> ${customCrop.target_mg || 0} ppm</div>
                                    <div><strong>Fe:</strong> ${customCrop.target_fe || 0} ppm</div>
                                </div>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #6c757d;">These nutrient targets will be included with your submission.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                    <button type="button" class="btn-success" onclick="app.submitCropToGlobalDatabase(${customCrop.id})">
                        <img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Submit" class="btn-icon-svg"> Submit to Global Database
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }

    async submitCropToGlobalDatabase(customCropId) {
        try {
            // Get the custom crop data
            const customCrops = await this.makeApiCall('/plants/custom-crops');
            const customCrop = customCrops.find(crop => crop.id === customCropId);
            
            if (!customCrop) {
                throw new Error('Custom crop not found');
            }

            // Collect form data
            const formData = {
                name: document.getElementById('submit-crop-name').value.trim(),
                code: document.getElementById('submit-crop-name').value.toLowerCase().trim().replace(/[^a-z0-9]/g, '_'),
                scientific_name: document.getElementById('submit-scientific-name').value.trim() || null,
                category_code: document.getElementById('submit-category').value,
                days_to_harvest: parseInt(document.getElementById('submit-days-harvest').value) || null,
                plant_spacing_cm: parseInt(document.getElementById('submit-plant-spacing').value) || null,
                light_requirements: document.getElementById('submit-light-requirements').value || null,
                default_ph_min: parseFloat(document.getElementById('submit-ph-min').value) || null,
                default_ph_max: parseFloat(document.getElementById('submit-ph-max').value) || null,
                default_ec_min: parseFloat(document.getElementById('submit-ec-min').value) || null,
                default_ec_max: parseFloat(document.getElementById('submit-ec-max').value) || null,
                growing_notes: document.getElementById('submit-growing-notes').value.trim() || null,
                research_source: document.getElementById('submit-research-source').value.trim() || null
            };

            // Validate required fields
            if (!formData.name || !formData.category_code) {
                this.showMessage('Please fill in the crop name and category', 'error');
                return;
            }

            // Create the crop in the admin system
            const response = await fetch('/api/crop-knowledge/admin/crops', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.token}`
                },
                body: JSON.stringify(formData)
            });

            const result = await response.json();
            
            if (!response.ok) {
                throw new Error(result.error || 'Failed to submit crop to global database');
            }

            // Now add the nutrient targets from the custom crop
            const nutrientTargets = [
                { nutrient_code: 'nitrogen', target_value: customCrop.target_n, growth_stage: 'general' },
                { nutrient_code: 'phosphorus', target_value: customCrop.target_p, growth_stage: 'general' },
                { nutrient_code: 'potassium', target_value: customCrop.target_k, growth_stage: 'general' },
                { nutrient_code: 'calcium', target_value: customCrop.target_ca, growth_stage: 'general' },
                { nutrient_code: 'magnesium', target_value: customCrop.target_mg, growth_stage: 'general' },
                { nutrient_code: 'iron', target_value: customCrop.target_fe, growth_stage: 'general' }
            ];

            // Add each nutrient target that has a value > 0
            for (const target of nutrientTargets) {
                if (target.target_value > 0) {
                    try {
                        await fetch(`/api/crop-knowledge/admin/crops/${formData.code}/targets`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.token}`
                            },
                            body: JSON.stringify(target)
                        });
                    } catch (error) {
                        console.warn(`Failed to add ${target.nutrient_code} target:`, error);
                    }
                }
            }

            // Close the submission modal
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                if (modal.innerHTML.includes('Submit to Global Database')) {
                    modal.remove();
                }
            });

            // Show success message with instructions
            this.showNotification(`‚úÖ "${formData.name}" submitted to global database successfully!\n\nüîπ It's now available in the admin crop management system\nüîπ Admin can review and adjust the data\nüîπ Will appear in global crop selections once approved`, 'success');

            // Offer to navigate to admin panel
            setTimeout(() => {
                if (confirm('Would you like to view the crop in the admin panel now?')) {
                    // Switch to admin panel
                    document.querySelector('[data-target="admin-content"]')?.click();
                    setTimeout(() => {
                        document.querySelector('#admin-crops-subtab')?.click();
                    }, 100);
                }
            }, 2000);

        } catch (error) {
            console.error('Error submitting crop to global database:', error);
            this.showMessage(`Failed to submit crop to global database: ${error.message}`, 'error');
        }
    }

    // Date formatting utility
    formatDateDDMMYYYY(date) {
        if (!date) return '';
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    }

    // Helper function to parse numeric values, returning null only for empty/invalid inputs
    parseNumericValue(value) {
        // If the input is empty or whitespace-only, return null
        if (value === '' || value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
            return null;
        }
        
        // Parse the value and check if it's a valid number
        const parsed = parseFloat(value);
        
        // Return null if parsing resulted in NaN, otherwise return the number (including 0)
        return isNaN(parsed) ? null : parsed;
    }

    // Ensure system has default spray programmes
    async ensureDefaultSprayProgrammes() {
        if (!this.activeSystemId) return;
        
        try {
            // Check if system has any programmes

            const response = await this.makeApiCall(`/spray-programmes?system_id=${this.activeSystemId}`);

            const programmes = response.programmes || [];

            // No auto-creation of default programmes - let users add their own

        } catch (error) {
            console.error('Error ensuring default spray programmes:', error);
            // Don't show error to user - this is a background operation
        }
    }

    // Spray Programmes functionality
    async setupSprayProgrammes() {

        // Check if system has any spray programmes, if not create defaults
        await this.ensureDefaultSprayProgrammes();
        this.setupSprayTabs();
        this.loadSprayApplications();
        
        // Load and display spray programmes
        this.loadSprayProgrammes();
        
        // Ensure calendar is updated after setup
        setTimeout(() => {

            this.updateSprayCalendar();
        }, 1000);
    }

    setupSprayTabs() {
        const sprayTabs = document.querySelectorAll('.spray-tab');
        const sprayContents = document.querySelectorAll('.spray-content');

        sprayTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const category = tab.id.replace('-tab', '');
                
                sprayTabs.forEach(t => t.classList.remove('active'));
                sprayContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const targetContent = document.getElementById(category + '-content');
                if (targetContent) {
                    targetContent.classList.add('active');
                }
                
                this.loadSprayApplications(category);
            });
        });
    }

    async loadSprayApplications(category = 'insecticides') {
        return this.sprayApplicationManager.loadSprayApplications(category);
    }

    // Plant Batch Manager delegation methods
    async updatePlantCropDropdown() {
        return this.plantBatchManager.updatePlantCropDropdown();
    }

    async updateHarvestCropDropdown() {
        return this.plantBatchManager.updateHarvestCropDropdown();
    }

    async updateRemainingPlantsDisplay() {
        return this.plantBatchManager.updateRemainingPlantsDisplay();
    }

    async recordPlanting() {
        return this.plantBatchManager.recordPlanting();
    }

    async recordHarvest() {
        return this.plantBatchManager.recordHarvest();
    }

    generateBatchId(date = new Date()) {
        return this.plantBatchManager.generateBatchId(date);
    }

    getActiveBatchesForBed(plantData, bedId) {
        return this.plantBatchManager.getActiveBatchesForBed(plantData, bedId);
    }

    getCurrentBatchForCrop(plantData, bedId, cropType) {
        return this.plantBatchManager.getCurrentBatchForCrop(plantData, bedId, cropType);
    }

    // Fish Tank Manager delegation methods - OVERRIDE to use main implementation
    async loadFishOverview() {
        // Use the main implementation instead of fishTankManager to get modern interface
        console.log('üì° Loading Fish Overview...');
        const container = document.getElementById('tank-summary-container');
        if (!container) {
            console.warn('‚ùå Tank summary container not found');
            return;
        }

        try {
            // Show loading state
            container.innerHTML = '<div class="loading-message">Loading fish overview...</div>';

            // Ensure system is selected
            if (!this.activeSystemId) {
                console.warn('‚ùå No active system selected');
                container.innerHTML = '<div class="no-data">Please select a system first</div>';
                return;
            }

            // Force fresh data loading with proper sequencing
            console.log('üîÑ Step 1: Loading fresh data records...');
            await this.loadDataRecords();
            
            // Additional delay to ensure all data APIs have completed
            console.log('‚è≥ Step 2: Waiting for data processing...');
            await new Promise(resolve => setTimeout(resolve, 500));

            // Verify data is actually loaded before proceeding
            console.log('üîç Step 3: Verifying data availability...');
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const hasData = this.dataRecords && (
                    this.dataRecords.fishHealth?.length > 0 || 
                    this.dataRecords.fishInventory?.tanks?.length > 0
                );
                
                if (hasData) {
                    console.log('‚úÖ Data verified and ready');
                    break;
                }
                
                console.log(`‚è≥ Attempt ${attempts + 1}: Waiting for data...`);
                await new Promise(resolve => setTimeout(resolve, 200));
                attempts++;
            }

            if (attempts >= maxAttempts) {
                console.warn('‚ö†Ô∏è Proceeding without full data verification');
            }

            // Load tank summary data using main implementation
            console.log('üìä Step 4: Displaying fish tank summary...');
            await this.displayFishTankSummary();
            
            console.log('‚úÖ Fish overview loaded successfully');
        } catch (error) {
            console.error('‚ùå Error loading fish overview:', error);
            container.innerHTML = '<div class="error-message">Failed to load fish overview. Please try again.</div>';
        }
    }

    async loadFishHealthEntry() {
        return this.fishTankManager.loadFishHealthEntry();
    }

    initializeFishCalculator() {
        return this.fishTankManager.initializeFishCalculator();
    }

    // Navigation Manager delegation methods
    setupNavigation() {
        return this.navigationManager.setupNavigation();
    }

    setupDashboardTabs() {
        return this.navigationManager.setupDashboardTabs();
    }

    setupCalculatorTabs() {
        return this.navigationManager.setupCalculatorTabs();
    }

    setupDataEntryTabs() {
        return this.navigationManager.setupDataEntryTabs();
    }

    setupPlantTabs() {
        return this.navigationManager.setupPlantTabs();
    }

    setupPlantManagementTabs() {
        return this.navigationManager.setupPlantManagementTabs();
    }

    setupPlantActionTabs() {
        return this.navigationManager.setupPlantActionTabs();
    }

    setupFishManagementTabs() {
        return this.navigationManager.setupFishManagementTabs();
    }

    setupSettingsTabs() {
        return this.navigationManager.setupSettingsTabs();
    }

    switchToView(viewId) {
        return this.navigationManager.switchToView(viewId);
    }

    switchToTab(tabId, tabType = 'dashboard') {
        return this.navigationManager.switchToTab(tabId, tabType);
    }

    // Water Quality & Sensor Manager delegation methods
    async saveWaterQualityData() {
        return this.waterQualitySensorManager.saveWaterQualityData();
    }

    async fetchSensorData() {
        return this.waterQualitySensorManager.fetchSensorData();
    }

    initializeSensorManagement() {
        return this.waterQualitySensorManager.initializeSensorManagement();
    }

    // System Configuration Manager delegation methods
    async loadSystemConfiguration() {
        return this.systemConfigManager.loadSystemConfiguration();
    }

    async saveSystemConfig() {
        return this.systemConfigManager.saveSystemConfig();
    }

    generateGrowBedConfiguration(bedCount) {
        return this.systemConfigManager.generateGrowBedConfiguration(bedCount);
    }

    async loadGrowBedConfiguration() {
        return this.systemConfigManager.loadGrowBedConfiguration();
    }

    // Crop Allocation Manager delegation methods
    async loadPlantAllocations() {
        return this.cropAllocationManager.loadPlantAllocations();
    }

    async loadCustomCrops() {
        return this.cropAllocationManager.loadCustomCrops();
    }

    async addCustomCrop() {
        return this.cropAllocationManager.addCustomCrop();
    }

    async deleteCustomCrop(cropId) {
        return this.cropAllocationManager.deleteCustomCrop(cropId);
    }

    updateCropDropdowns(customCrops) {
        return this.cropAllocationManager.updateCropDropdowns(customCrops);
    }

    displaySprayApplications(applications, category) {
        const container = document.getElementById(category + '-list');
        if (!container) return;

        if (applications.length === 0) {
            container.innerHTML = `<p style="color: #666; text-align: center;">No ${category} products available.</p>`;
            return;
        }

        // Get active programmes to check which products are in use
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const activeProgrammes = programmes.filter(p => 
            p.systemId === this.activeSystemId && p.status === 'active'
        );
        
        // Get IDs of products that are in active programmes
        const productsInProgrammes = new Set();
        activeProgrammes.forEach(programme => {
            programme.selections.insecticides?.forEach(id => productsInProgrammes.add(parseInt(id)));
            programme.selections.fungicides?.forEach(id => productsInProgrammes.add(parseInt(id)));
            programme.selections.foliarFeeds?.forEach(id => productsInProgrammes.add(parseInt(id)));
        });

        // Separate products based on whether they're in active programmes
        const activeApplications = applications.filter(app => productsInProgrammes.has(app.id));
        const inactiveApplications = applications.filter(app => !productsInProgrammes.has(app.id));
        const inactiveApps = applications.filter(app => app.status === 'inactive');
        if (inactiveApps.length > 0) {

        } else {

        }

        // Specific debugging for Metarhizium 62
        const metarhizium = applications.find(app => app.product_name.includes('Metarhizium'));
        if (metarhizium) {

        }

        let html = '';

        // Active Products Section
        if (activeApplications.length > 0) {
            html += `
                <div class="spray-section">
                    <h4 class="spray-section-title active-section">üü¢ Products in Active Programmes</h4>
                    <div class="spray-applications-grid">
            `;
            activeApplications.forEach(app => {
                html += this.generateSprayApplicationCard(app, true);
            });
            html += `
                    </div>
                </div>
            `;
        }

        // Inactive Products Section
        if (inactiveApplications.length > 0) {
            html += `
                <div class="spray-section">
                    <h4 class="spray-section-title inactive-section">‚ö™ Available Products (Not in Programme)</h4>
                    <div class="spray-applications-grid">
            `;
            inactiveApplications.forEach(app => {
                html += this.generateSprayApplicationCard(app, false);
            });
            html += `
                    </div>
                </div>
            `;
        }

        container.innerHTML = html;
    }

    generateSprayApplicationCard(app, isInProgramme = false) {
        // Only show next application if product is in an active programme
        const nextApplication = isInProgramme ? this.calculateNextApplication(app) : null;
        
        return `
            <div class="spray-application-card">
                <div class="spray-header">
                    <h5>${app.product_name}</h5>
                    <div class="spray-actions">
                        <button onclick="app.recordSprayApplication(${app.id})" class="record-btn" title="Record Application">${SVGIcons.getIcon('add', 'btn-icon-svg')}</button>
                        <button onclick="app.editSprayProgramme(${app.id})" class="edit-btn" title="Edit Programme">${SVGIcons.getIcon('edit', 'btn-icon-svg')}</button>
                        <button onclick="app.deleteSprayApplication(${app.id})" class="delete-btn" title="Delete">${SVGIcons.getIcon('delete', 'btn-icon-svg')}</button>
                    </div>
                </div>
                <div class="spray-details">
                    ${app.active_ingredient ? `
                        <div class="detail-item">
                            <strong>Active Ingredient:</strong> ${app.active_ingredient}
                        </div>
                    ` : ''}
                    <div class="detail-item">
                        <strong>Target:</strong> ${app.target_pest || app.target_disease || app.nutrient_type || 'General'}
                    </div>
                    <div class="detail-item">
                        <strong>Rate:</strong> ${app.application_rate} ${app.rate_unit}
                    </div>
                    <div class="detail-item">
                        <strong>Last Applied:</strong> ${app.last_application ? this.formatDateDDMMYYYY(new Date(app.last_application)) : 'Never'}
                    </div>
                    <div class="detail-item">
                        <strong>Frequency:</strong> Every ${app.frequency_days || app.frequency || 7} days
                    </div>
                    ${isInProgramme && nextApplication ? `
                        <div class="detail-item next-application">
                            <strong>Next Due:</strong> ${this.formatDateDDMMYYYY(nextApplication)}
                            ${nextApplication < new Date() ? '<span class="overdue">‚ö†Ô∏è Overdue</span>' : ''}
                        </div>
                    ` : ''}
                    ${!isInProgramme ? `
                        <div class="detail-item inactive-status">
                            <strong>Status:</strong> <span style="color: #999;">Available - Not in Programme</span>
                        </div>
                    ` : `
                        <div class="detail-item active-status">
                            <strong>Status:</strong> <span style="color: var(--color-bio-green);">In Active Programme</span>
                        </div>
                    `}
                </div>
                <div class="spray-notes">
                    ${app.notes || ''}
                </div>
                <div class="spray-programme-controls">
                    ${this.generateProgrammeControlButton(app, isInProgramme)}
                </div>
                <div class="spray-history">
                    <button onclick="app.toggleApplicationHistory(${app.id})" class="history-toggle-btn">
                        üìã View Application History
                    </button>
                    <div id="history-${app.id}" class="application-history" style="display: none;">
                        <!-- History will be loaded here -->
                    </div>
                </div>
            </div>
        `;
    }

    generateProgrammeControlButton(sprayApp, isInProgramme) {
        if (isInProgramme) {
            // Item is in an active programme - show edit/remove options
            return `
                <div class="programme-control-group">
                    <button onclick="window.app.editSprayProgramme(${sprayApp.id})" class="programme-edit-btn" title="Edit Programme">
                        üîß Edit Programme
                    </button>
                    <button onclick="window.app.removeFromProgramme(${sprayApp.id})" class="programme-remove-btn" title="Remove from Programme">
                        ‚ùå Remove from Programme
                    </button>
                </div>
            `;
        } else {
            // Item is not in a programme - show add option
            return `
                <button onclick="window.app.addToProgramme(${sprayApp.id})" class="programme-add-btn" title="Add to Spray Programme">
                    ‚ûï Add to Programme
                </button>
            `;
        }
    }

    parseFrequencyDays(frequency) {
        // Extract number of days from frequency string like "Every 7 days"
        if (typeof frequency === 'number') return frequency;
        if (!frequency || typeof frequency !== 'string') return 7; // default to weekly
        
        const match = frequency.match(/(\d+)/);
        return match ? parseInt(match[1]) : 7;
    }

    calculateNextApplication(application) {

        let baseDate;
        
        if (application.last_application) {
            // If there's a last application, calculate next from that date
            baseDate = new Date(application.last_application);

        } else {
            // For new programmes without applications, use start date or today
            if (application.start_date) {
                baseDate = new Date(application.start_date);

            } else {
                // For programmes without start date, start from today
                baseDate = new Date();

            }
        }
        
        const nextDate = new Date(baseDate);
        
        // Get frequency in days from either frequency_days or frequency string
        const frequencyDays = application.frequency_days || this.parseFrequencyDays(application.frequency);

        // If we're using last application date, add frequency to get next date
        if (application.last_application) {
            nextDate.setDate(baseDate.getDate() + frequencyDays);
        } else {
            // For new programmes, if start date is in the future, use start date
            // Otherwise, schedule for frequency days from now
            if (application.start_date && new Date(application.start_date) > new Date()) {

                return new Date(application.start_date);
            } else {
                nextDate.setDate(baseDate.getDate() + frequencyDays);

            }
        }

        return nextDate;
    }

    async updateSprayCalendar() {
        if (!this.activeSystemId) return;
        
        // Use the programme-based calendar that works correctly
        this.updateSprayCalendarMock();
    }

    displaySprayCalendar(applications) {
        const container = document.getElementById('spray-calendar-container');
        if (!container) {
            console.error('spray-calendar-container not found');
            return;
        }

        if (!applications || !Array.isArray(applications)) {
            console.error('Invalid applications data:', applications);
            container.innerHTML = '<p style="color: #666; text-align: center;">Error loading applications.</p>';
            return;
        }

        const upcoming = applications
            .filter(app => {
                // Only include active programmes in upcoming applications
                const isActive = !app.status || app.status === 'active';

                return isActive;
            })
            .map(app => {
                const nextDate = this.calculateNextApplication(app);

                return {
                    ...app,
                    nextDate: nextDate
                };
            })
            .filter(app => {
                const hasDate = app.nextDate !== null && app.nextDate !== undefined;

                return hasDate;
            })
            .sort((a, b) => a.nextDate - b.nextDate)
            .slice(0, 5);

        if (upcoming.length === 0) {
            container.innerHTML = '<p style="color: #666; text-align: center;">No upcoming spray applications scheduled.</p>';
            return;
        }

        let html = '<div class="upcoming-sprays">';
        upcoming.forEach(app => {
            const daysUntil = Math.ceil((app.nextDate - new Date()) / (1000 * 60 * 60 * 24));
            const isOverdue = daysUntil < 0;
            const urgency = isOverdue ? 'overdue' : daysUntil <= 3 ? 'urgent' : 'normal';
            
            html += `
                <div class="upcoming-spray ${urgency}">
                    <div class="spray-date">
                        ${this.formatDateDDMMYYYY(app.nextDate)}
                        ${isOverdue ? '<span class="overdue-badge">Overdue</span>' : 
                          daysUntil === 0 ? '<span class="today-badge">Today</span>' :
                          daysUntil === 1 ? '<span class="tomorrow-badge">Tomorrow</span>' :
                          `<span class="days-badge">${daysUntil} days</span>`}
                    </div>
                    <div class="spray-info">
                        <div class="spray-details">
                            <strong>${app.product_name}</strong>
                            <span class="spray-category">${app.category}</span>
                        </div>
                        <div class="spray-actions">
                            <button onclick="app.recordSprayApplication(${app.id})" class="quick-record-btn" title="Record Application">
                                ${SVGIcons.getIcon('add', 'btn-icon-svg')}
                            </button>
                            <button onclick="app.editSprayProgramme(${app.id})" class="quick-edit-btn" title="Edit Programme">
                                ${SVGIcons.getIcon('edit', 'btn-icon-svg')}
                            </button>
                            <button onclick="app.removeFromProgramme(${app.id})" class="quick-remove-btn" title="Remove from Programme">
                                ${SVGIcons.getIcon('delete', 'btn-icon-svg')}
                            </button>
                        </div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        container.innerHTML = html;
    }

    showAddSprayModal(category) {
        const modal = document.getElementById('add-spray-modal');
        const categorySelect = document.getElementById('add-spray-category');
        const title = document.getElementById('add-spray-title');
        
        // Set category and update title
        categorySelect.value = category;
        title.textContent = `üåø Add New Product`;
        
        // Clear form
        this.clearAddSprayForm();
        
        // Update form based on category
        this.updateAddSprayForm();
        
        // Show modal
        modal.classList.add('show');
    }

    closeAddSprayModal() {
        const modal = document.getElementById('add-spray-modal');
        modal.classList.remove('show');
        
        // Clear editing state
        delete modal.dataset.editingId;
        
        this.clearAddSprayForm();
    }

    clearAddSprayForm() {
        const form = document.getElementById('add-spray-form');
        const modal = document.getElementById('add-spray-modal');
        
        // Reset form values
        form.reset();
        
        // Ensure all fields are enabled and editable
        const formFields = form.querySelectorAll('input, select, textarea');
        formFields.forEach(field => {
            field.removeAttribute('readonly');
            field.removeAttribute('disabled');
            field.style.backgroundColor = '';
            field.style.cursor = '';
        });
        
        // Hide target field
        const targetField = document.getElementById('target-field');
        targetField.style.display = 'none';
        
        // Remove category class
        modal.className = 'modal-overlay';
    }

    updateAddSprayForm() {
        const category = document.getElementById('add-spray-category').value;
        const targetField = document.getElementById('target-field');
        const targetInput = document.getElementById('add-spray-target');
        const modal = document.getElementById('add-spray-modal');
        
        // Remove existing category classes
        modal.className = 'modal-overlay';
        
        if (category) {
            // Add category class for styling
            modal.classList.add(`category-${category}`);
            
            // Show and configure target field based on category
            targetField.style.display = 'block';
            
            switch (category) {
                case 'insecticides':
                    targetInput.placeholder = 'e.g., Aphids, Bollworm, Two-Spotted Mite';
                    break;
                case 'fungicides':
                    targetInput.placeholder = 'e.g., Downy Mildew, Powdery Mildew, Pythium';
                    break;
                case 'foliar-feeds':
                    targetInput.placeholder = 'e.g., NPK, Calcium, Iron deficiency';
                    break;
                default:
                    targetField.style.display = 'none';
            }
        } else {
            targetField.style.display = 'none';
        }
    }

    async saveNewSprayProgramme() {
        const modal = document.getElementById('add-spray-modal');
        const isEditing = modal.dataset.editingId;
        
        const formData = {
            category: document.getElementById('add-spray-category').value,
            product_name: document.getElementById('add-spray-product').value,
            active_ingredient: document.getElementById('add-spray-ingredient').value,
            target: document.getElementById('add-spray-target').value,
            application_rate: document.getElementById('add-spray-rate').value,
            rate_unit: document.getElementById('add-spray-rate-unit').value,
            frequency_days: parseInt(document.getElementById('add-spray-frequency').value),
            notes: document.getElementById('add-spray-notes').value
        };

        // Validate required fields with specific error messages
        const missingFields = [];
        if (!formData.category) missingFields.push('Category');
        if (!formData.product_name) missingFields.push('Product Name');
        if (!formData.application_rate) missingFields.push('Application Rate');
        if (!formData.frequency_days || isNaN(formData.frequency_days)) missingFields.push('Application Frequency');
        
        if (missingFields.length > 0) {
            this.showNotification(`‚ùå Please fill in: ${missingFields.join(', ')}`, 'error');
            return;
        }


        try {
            // For new products, add to shared product database (mock data)
            if (!isEditing) {
                await this.addToSharedProductDatabase(formData);
                this.showNotification('‚úÖ Product added to shared database! Available across all systems.', 'success');
            } else {
                // Update existing programme
                const apiData = {
                    category: formData.category,
                    product_name: formData.product_name,
                    active_ingredient: formData.active_ingredient,
                    application_rate: `${formData.application_rate} ${formData.rate_unit}`,
                    frequency_days: formData.frequency_days,
                    notes: formData.notes
                };

                // Set target field based on category
                if (formData.category === 'insecticides') {
                    apiData.target_pest = formData.target;
                } else if (formData.category === 'fungicides') {
                    apiData.target_disease = formData.target;
                } else if (formData.category === 'foliar-feeds') {
                    apiData.nutrient_type = formData.target;
                }

                await this.updateSprayApplication(isEditing, apiData);
                this.showNotification('‚úÖ Product updated successfully!', 'success');
            }
            
            this.closeAddSprayModal();
            
        } catch (error) {
            console.error('Failed to save product:', error);
            this.showNotification('‚ùå Failed to save product. Please try again.', 'error');
        }
    }

    async addToSharedProductDatabase(formData) {
        // Generate new ID for the product
        const allProducts = [];
        ['insecticides', 'fungicides', 'foliar-feeds'].forEach(category => {
            allProducts.push(...this.getMockSprayApplications(category));
        });
        const maxId = Math.max(...allProducts.map(p => p.id), 0);
        const newId = maxId + 1;

        // Create the new product object
        const newProduct = {
            id: newId,
            product_name: formData.product_name,
            active_ingredient: formData.active_ingredient,
            application_rate: formData.application_rate,
            rate_unit: formData.rate_unit,
            frequency_days: formData.frequency_days,
            notes: formData.notes,
            // Add last_application as null since it's a new product
            last_application: null
        };

        // Set target field based on category
        if (formData.category === 'insecticides') {
            newProduct.target_pest = formData.target;
        } else if (formData.category === 'fungicides') {
            newProduct.target_disease = formData.target;
        } else if (formData.category === 'foliar-feeds') {
            newProduct.nutrient_type = formData.target;
        }

        // For now, store in localStorage until proper backend is implemented
        const storageKey = `custom_products_${formData.category}`;
        const existingCustomProducts = JSON.parse(localStorage.getItem(storageKey) || '[]');
        existingCustomProducts.push(newProduct);
        localStorage.setItem(storageKey, JSON.stringify(existingCustomProducts));

        // Refresh the current category to show the new product
        this.loadSprayApplications(formData.category);
        
        return Promise.resolve(newProduct);
    }

    async addToProgramme(applicationId) {
        // Find the application details
        const application = await this.findSprayApplication(applicationId);
        if (!application) {
            this.showNotification('‚ùå Application not found', 'error');
            return;
        }

        // Get active programmes
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const activeProgrammes = programmes.filter(p => 
            p.systemId === this.activeSystemId && p.status === 'active'
        );

        if (activeProgrammes.length === 0) {
            this.showNotification('‚ùå No active programmes found. Create a programme first.', 'error');
            return;
        }

        // Store the application ID for later use
        this.selectedApplicationId = applicationId;

        // Show the Add to Programme modal
        const modal = document.getElementById('add-to-programme-modal');
        const productNameSpan = document.getElementById('add-to-programme-product-name');
        const programmeSelect = document.getElementById('add-to-programme-select');
        const categorySelect = document.getElementById('add-to-programme-category');
        
        // Set product name
        productNameSpan.textContent = application.product_name;
        
        // Populate programme options
        programmeSelect.innerHTML = '<option value="">-- Select Programme --</option>';
        activeProgrammes.forEach(programme => {
            programmeSelect.innerHTML += `<option value="${programme.id}">${programme.name}</option>`;
        });
        
        // Set category if available
        if (application.category) {
            categorySelect.value = application.category;
        }
        
        // Show the modal
        modal.style.display = 'flex';
        
        // Show info alert
        document.getElementById('add-to-programme-info').style.display = 'block';
    }

    closeAddToProgrammeModal() {
        const modal = document.getElementById('add-to-programme-modal');
        modal.style.display = 'none';
        
        // Clear form
        document.getElementById('add-to-programme-select').value = '';
        document.getElementById('add-to-programme-category').value = '';
        document.getElementById('add-to-programme-info').style.display = 'none';
        this.selectedApplicationId = null;
    }

    async confirmAddToProgramme() {
        const programmeId = document.getElementById('add-to-programme-select').value;
        const category = document.getElementById('add-to-programme-category').value;
        
        if (!programmeId) {
            this.showNotification('‚ùå Please select a programme', 'error');
            return;
        }
        
        if (!category) {
            this.showNotification('‚ùå Please select a product category', 'error');
            return;
        }
        
        try {
            // Get programmes from localStorage
            const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
            const programmeIndex = programmes.findIndex(p => p.id === programmeId);
            
            if (programmeIndex === -1) {
                this.showNotification('‚ùå Programme not found', 'error');
                return;
            }
            
            // Add product to the selected programme category
            if (!programmes[programmeIndex].selections) {
                programmes[programmeIndex].selections = {};
            }
            
            if (!programmes[programmeIndex].selections[category]) {
                programmes[programmeIndex].selections[category] = [];
            }
            
            // Check if product is already in the programme
            if (programmes[programmeIndex].selections[category].includes(this.selectedApplicationId)) {
                this.showNotification('‚ö†Ô∏è Product is already in this programme', 'warning');
                return;
            }
            
            // Add the product ID to the programme
            programmes[programmeIndex].selections[category].push(this.selectedApplicationId);
            
            // Save back to localStorage
            localStorage.setItem('spray_programmes', JSON.stringify(programmes));
            
            // Close modal
            this.closeAddToProgrammeModal();
            
            // Refresh the spray applications display
            this.loadSprayApplications();
            this.loadSprayProgrammes();
            this.updateSprayCalendarMock();
            
            // Get product name for notification
            const application = await this.findSprayApplication(this.selectedApplicationId);
            const programmeName = programmes[programmeIndex].name;
            
            this.showNotification(`‚úÖ ${application.product_name} added to programme "${programmeName}"`, 'success');
            
        } catch (error) {
            console.error('Error adding to programme:', error);
            this.showNotification('‚ùå Failed to add product to programme', 'error');
        }
    }

    async editSprayProgramme(applicationId) {
        // Find the application details
        const application = await this.findSprayApplication(applicationId);
        if (!application) {
            this.showNotification('‚ùå Application not found', 'error');
            return;
        }

        // Open the add spray modal in edit mode with pre-filled data
        const modal = document.getElementById('add-spray-modal');
        const categorySelect = document.getElementById('add-spray-category');
        const title = document.getElementById('add-spray-title');
        
        // Pre-fill all form fields
        categorySelect.value = application.category;
        document.getElementById('add-spray-product').value = application.product_name;
        document.getElementById('add-spray-ingredient').value = application.active_ingredient || '';
        document.getElementById('add-spray-target').value = application.target_pest || application.target_disease || application.nutrient_type || '';
        document.getElementById('add-spray-rate').value = application.application_rate ? application.application_rate.split(' ')[0] : '';
        document.getElementById('add-spray-rate-unit').value = application.application_rate ? application.application_rate.split(' ').slice(1).join(' ') : 'ml per 10L';
        document.getElementById('add-spray-frequency').value = this.parseFrequencyDays(application.frequency) || 7;
        document.getElementById('add-spray-start').value = application.start_date || '';
        document.getElementById('add-spray-end').value = application.end_date || '';
        document.getElementById('add-spray-notes').value = application.notes || '';
        
        title.textContent = `üîß Edit ${application.product_name} Programme`;
        this.updateAddSprayForm();
        
        // Store the ID for updating
        modal.dataset.editingId = applicationId;
        
        modal.classList.add('show');
    }

    async removeFromProgramme(applicationId) {
        // Find the application details
        const application = await this.findSprayApplication(applicationId);
        if (!application) {
            this.showNotification('‚ùå Application not found', 'error');
            return;
        }

        // Confirm removal using custom modal
        const confirmed = await this.modalManager.showCustomConfirm(
            `Remove "${application.product_name}" from programme?`,
            `Are you sure you want to remove "${application.product_name}" from the spray programme?`,
            [
                'Stop all future scheduled applications',
                'Remove it from upcoming applications calendar', 
                'Move it to "Available Products" section',
                'Keep existing application history for records'
            ]
        );
        
        if (confirmed) {
            try {
                await this.makeApiCall(`/spray-programmes/${applicationId}`, {
                    method: 'DELETE'
                });
                
                this.showNotification(`‚úÖ ${application.product_name} removed from programme successfully!`, 'success');
                
                // Force refresh of all views with slight delays to ensure backend update is complete
                setTimeout(() => {
                    // Refresh the current category view
                    this.loadSprayApplications(application.category);
                }, 100);
                
                setTimeout(() => {
                    // Refresh upcoming applications calendar
                    this.updateSprayCalendar();
                }, 300);
                
                setTimeout(() => {
                    // Also refresh other categories if they were loaded
                    ['insecticides', 'fungicides', 'foliar-feeds'].forEach(cat => {
                        if (cat !== application.category) {
                            this.loadSprayApplications(cat);
                        }
                    });
                }, 500);
                
            } catch (error) {
                console.error('Failed to remove from programme:', error);
                this.showNotification('‚ùå Failed to remove from programme. Please try again.', 'error');
            }
        }
    }

    async findSprayApplication(applicationId) {
        // Search through all categories to find the application
        const categories = ['insecticides', 'fungicides', 'foliar-feeds'];
        
        try {
            // Try API data first - call once, search all categories
            const response = await this.makeApiCall(`/spray-programmes?system_id=${this.activeSystemId}`);
            const allApplications = response.programmes || [];
            
            for (const category of categories) {
                const applications = this.filterApplicationsByCategory(allApplications, category);
                const found = applications.find(app => app.id == applicationId);
                if (found) {
                    // Add category to application object
                    found.category = category;
                    return found;
                }
            }
        } catch (error) {
        }
        
        // If not found in API data or API failed, search mock data
        for (const category of categories) {
            const mockApplications = this.getMockSprayApplications(category);
            const found = mockApplications.find(app => app.id == applicationId);
            if (found) {
                // Add category to application object
                found.category = category;
                return found;
            }
        }
        
        return null;
    }

    async updateSprayApplication(applicationId, data) {
        try {
            await this.makeApiCall(`/spray-programmes/${applicationId}`, {
                method: 'PUT',
                body: JSON.stringify(data)
            });
            
            // Refresh the current view
            this.loadSprayApplications(data.category);
            
            // Also refresh the calendar
            setTimeout(() => {
                this.updateSprayCalendar();
            }, 500);
            
        } catch (error) {

            this.showNotification('‚ùå Update failed - API not available', 'error');
            throw error;
        }
    }

    async addSprayApplication(data) {
        if (!this.activeSystemId) {
            this.showNotification('üèóÔ∏è Please select a system first.', 'warning');
            return;
        }
        
        try {
            await this.makeApiCall('/spray-programmes', {
                method: 'POST',
                body: JSON.stringify({
                    ...data,
                    system_id: this.activeSystemId
                })
            });
            this.showNotification('Spray programme added successfully!', 'success');
            
            // Refresh the current category and update calendar
            this.loadSprayApplications(data.category);
            
            // Also refresh the calendar to show upcoming applications
            setTimeout(() => {
                this.updateSprayCalendar();
            }, 500);
        } catch (error) {

            this.showNotification('Spray application added to demo data!', 'success');
            // Refresh the current category to show mock data
            this.loadSprayApplications(data.category);
        }
    }

    toggleDilutionInput() {
        const dilutionType = document.getElementById('record-dilution-type').value;
        const ratioInput = document.getElementById('ratio-input');
        const volumeInput = document.getElementById('volume-input');
        const concentrationInput = document.getElementById('concentration-input');
        
        // Hide all options first
        ratioInput.style.display = 'none';
        volumeInput.style.display = 'none';
        concentrationInput.style.display = 'none';
        
        // Show the selected option
        switch (dilutionType) {
            case 'ratio':
                ratioInput.style.display = 'block';
                break;
            case 'volume':
                volumeInput.style.display = 'block';
                break;
            case 'concentration':
                concentrationInput.style.display = 'block';
                break;
        }
    }

    recordSprayApplication(applicationId) {

        // Find the application data
        const allCategories = ['insecticides', 'fungicides', 'foliar-feeds'];
        let application = null;
        
        for (const category of allCategories) {
            const apps = this.getMockSprayApplications(category);
            application = apps.find(app => app.id === applicationId);
            if (application) break;
        }
        
        if (!application) {
            this.showNotification('‚ùå Application not found', 'error');
            return;
        }
        
        // Store current application for the modal
        this.currentSprayApplication = application;
        
        // Pre-fill the modal with application data
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('record-date').value = today;
        document.getElementById('record-product').value = application.product_name;
        
        // Initialize dilution display to default (ratio)
        document.getElementById('record-dilution-type').value = 'ratio';
        this.toggleDilutionInput();
        
        // Show the modal
        document.getElementById('record-spray-modal').classList.add('show');
    }

    closeRecordSprayModal() {
        document.getElementById('record-spray-modal').classList.remove('show');
        this.currentSprayApplication = null;
        
        // Clear form
        document.getElementById('record-spray-form').reset();
        
        // Reset dilution display to default (ratio)
        document.getElementById('record-dilution-type').value = 'ratio';
        this.toggleDilutionInput();
    }

    async saveSprayRecord() {
        if (!this.currentSprayApplication) return;
        
        // Get dilution information based on selected type
        const dilutionType = document.getElementById('record-dilution-type').value;
        let dilutionInfo = '';
        
        switch (dilutionType) {
            case 'ratio':
                const ratio = document.getElementById('record-dilution-ratio').value;
                if (ratio) {
                    dilutionInfo = `1:${ratio}`;
                }
                break;
            case 'volume':
                const volume = document.getElementById('record-water-volume').value;
                const unit = document.getElementById('record-water-unit').value;
                if (volume) {
                    dilutionInfo = `in ${volume}${unit} water`;
                }
                break;
            case 'concentration':
                const concentration = document.getElementById('record-final-concentration').value;
                const concUnit = document.getElementById('record-concentration-unit').value;
                if (concentration) {
                    dilutionInfo = `${concentration}${concUnit} final concentration`;
                }
                break;
        }
        
        const formData = {
            application_id: this.currentSprayApplication.id,
            date: document.getElementById('record-date').value,
            product_used: document.getElementById('record-product').value,
            product_amount: document.getElementById('record-product-amount').value,
            product_unit: document.getElementById('record-product-unit').value,
            dilution_type: dilutionType,
            dilution_info: dilutionInfo,
            area_treated: document.getElementById('record-area').value,
            area_unit: document.getElementById('record-area-unit').value,
            conditions: document.getElementById('record-conditions').value,
            notes: document.getElementById('record-notes').value,
            system_id: this.activeSystemId
        };
        
        // Validate required fields
        if (!formData.date || !formData.product_used || !formData.product_amount) {
            this.showNotification('‚ùå Please fill in all required fields', 'error');
            return;
        }
        
        try {
            await this.performSaveWithProgress('spray', async () => {
                // Try API call first
                await this.makeApiCall('/spray-programmes/record', {
                    method: 'POST',
                    body: JSON.stringify(formData)
                });
                
                // Store completed application record in localStorage
                this.recordCompletedSprayApplication(this.currentSprayApplication.id, formData.date);
                
                return { success: true, formData };
            });
            
            // Success actions after modal closes
            this.showNotification('Spray application recorded successfully!', 'success');
            this.closeRecordSprayModal();
            this.setupSprayProgrammes(); // Reload data
            
            // Refresh Actions Required tab if it's open
            if (typeof loadActionsRequired === 'function') {
                setTimeout(() => loadActionsRequired(), 500);
            }
            
        } catch (error) {

            // Update the last_application date in mock data
            this.updateMockSprayLastApplication(this.currentSprayApplication.id, formData.date);
            
            // Store completed application record in localStorage for Actions Required tracking
            this.recordCompletedSprayApplication(this.currentSprayApplication.id, formData.date);
            
            this.showNotification('Spray application recorded (demo mode)!', 'success');
            this.closeRecordSprayModal();
            this.setupSprayProgrammes(); // Reload data
            
            // Refresh Actions Required tab if it's open
            if (typeof loadActionsRequired === 'function') {
                setTimeout(() => loadActionsRequired(), 500);
            }
        }
    }

    updateMockSprayLastApplication(applicationId, newDate) {
        // This would update the mock data to reflect the new last application date
        // In a real implementation, this would be handled by the API

    }

    recordCompletedSprayApplication(applicationId, date) {
        // Store completed spray application records for Actions Required tracking
        const today = new Date().toDateString(); // Get today's date string
        const recordDate = new Date(date).toDateString(); // Get record date string
        
        // Only track if recorded for today
        if (recordDate === today) {
            const storageKey = `completed_spray_applications_${this.activeSystemId}`;
            const completedApplications = JSON.parse(localStorage.getItem(storageKey) || '{}');
            
            // Use today's date as the key to store completed application IDs
            if (!completedApplications[today]) {
                completedApplications[today] = [];
            }
            
            // Add this application ID if not already recorded
            if (!completedApplications[today].includes(applicationId)) {
                completedApplications[today].push(applicationId);
            }
            
            // Clean up old records (keep only last 7 days)
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            
            Object.keys(completedApplications).forEach(dateKey => {
                if (new Date(dateKey) < weekAgo) {
                    delete completedApplications[dateKey];
                }
            });
            
            localStorage.setItem(storageKey, JSON.stringify(completedApplications));
        }
    }

    async toggleApplicationHistory(applicationId) {
        const historyDiv = document.getElementById(`history-${applicationId}`);
        const toggleBtn = historyDiv.previousElementSibling;
        
        if (historyDiv.style.display === 'none') {
            // Load and show history
            await this.loadApplicationHistory(applicationId);
            historyDiv.style.display = 'block';
            toggleBtn.textContent = 'üìã Hide Application History';
        } else {
            // Hide history
            historyDiv.style.display = 'none';
            toggleBtn.textContent = 'üìã View Application History';
        }
    }

    async loadApplicationHistory(applicationId) {
        const historyDiv = document.getElementById(`history-${applicationId}`);
        
        try {
            // Try API call first
            const history = await this.makeApiCall(`/spray-programmes/${applicationId}/history`);
            this.displayApplicationHistory(history, historyDiv);
        } catch (error) {

            // Show mock history data
            const mockHistory = this.getMockApplicationHistory(applicationId);
            this.displayApplicationHistory(mockHistory, historyDiv);
        }
    }

    getMockApplicationHistory(applicationId) {
        // Mock history data - in real implementation this would come from API
        return [
            {
                id: 1,
                date: '2025-07-25',
                product_used: 'Bioneem',
                amount_used: '100',
                rate_unit: 'ml per 10L',
                area_treated: '15',
                area_unit: 'm¬≤',
                conditions: 'early morning',
                notes: 'Applied preventatively, good coverage achieved'
            },
            {
                id: 2,
                date: '2025-07-18',
                product_used: 'Bioneem',
                amount_used: '120',
                rate_unit: 'ml per 10L',
                area_treated: '15',
                area_unit: 'm¬≤',
                conditions: 'cloudy',
                notes: 'Increased rate due to aphid pressure'
            },
            {
                id: 3,
                date: '2025-07-11',
                product_used: 'Bioneem',
                amount_used: '100',
                rate_unit: 'ml per 10L',
                area_treated: '12',
                area_unit: 'm¬≤',
                conditions: 'calm',
                notes: 'Regular preventative application'
            }
        ];
    }

    displayApplicationHistory(history, container) {
        if (!history || history.length === 0) {
            container.innerHTML = '<p style="color: #666; text-align: center; padding: 1rem;">No application history recorded yet.</p>';
            return;
        }

        let html = '<div class="history-entries">';
        history.forEach(entry => {
            html += `
                <div class="history-entry">
                    <div class="history-header">
                        <span class="history-date">${this.formatDateDDMMYYYY(new Date(entry.date))}</span>
                        <span class="history-product">${entry.product_used}</span>
                    </div>
                    <div class="history-details">
                        <div class="history-detail">
                            <strong>Amount:</strong> ${entry.amount_used} ${entry.rate_unit}
                        </div>
                        ${entry.area_treated ? `
                            <div class="history-detail">
                                <strong>Area:</strong> ${entry.area_treated} ${entry.area_unit}
                            </div>
                        ` : ''}
                        ${entry.conditions ? `
                            <div class="history-detail">
                                <strong>Conditions:</strong> ${entry.conditions}
                            </div>
                        ` : ''}
                        ${entry.notes ? `
                            <div class="history-notes">
                                <strong>Notes:</strong> ${entry.notes}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });
        html += '</div>';
        container.innerHTML = html;
    }

    async editSprayApplication(applicationId) {
        // This would show an edit modal
        // For now, we'll implement basic edit functionality

        this.showNotification('Edit functionality coming soon!', 'info');
    }

    async deleteSprayApplication(applicationId) {
        // Find the application details for better confirmation message
        const application = await this.findSprayApplication(applicationId);
        const productName = application ? application.product_name : 'this spray application';
        
        const confirmed = await this.modalManager.showCustomConfirm(
            `Remove "${productName}" from programme?`,
            `Are you sure you want to remove "${productName}" from the spray programme?`,
            [
                'Stop all future scheduled applications',
                'Remove it from upcoming applications calendar',
                'Move it to "Available Products" section', 
                'Keep existing application history for records'
            ]
        );
        
        if (!confirmed) {
            return;
        }
        
        try {
            await this.makeApiCall(`/spray-programmes/${applicationId}`, {
                method: 'DELETE'
            });
            this.showNotification(`‚úÖ ${productName} removed from programme successfully!`, 'success');
            
            // Use the same enhanced refresh logic as removeFromProgramme
            const category = application ? application.category : 'insecticides';
            
            // Force refresh of all views with slight delays to ensure backend update is complete
            setTimeout(() => {
                // Refresh the current category view
                this.loadSprayApplications(category);
            }, 100);
            
            setTimeout(() => {
                // Refresh upcoming applications calendar
                this.updateSprayCalendar();
            }, 300);
            
            setTimeout(() => {
                // Also refresh other categories if they were loaded
                ['insecticides', 'fungicides', 'foliar-feeds'].forEach(cat => {
                    if (cat !== category) {
                        this.loadSprayApplications(cat);
                    }
                });
            }, 500);
        } catch (error) {

            this.showNotification('Delete operation simulated (demo mode)', 'info');
            // In demo mode, we don't actually delete from mock data
        }
    }

    filterApplicationsByCategory(applications, category) {

        // Log each application to see the data structure
        applications.forEach((app, index) => {

        });
        
        // Map backend programme data to frontend categories
        // Use the category field from the database directly
        return applications.filter(app => {
            // First try direct category match

            if (app.category === category) {

                return true;
            }
            
            // Fallback to text-based filtering for backwards compatibility
            const programme = app.programme?.toLowerCase() || '';
            const products = app.products?.toLowerCase() || '';
            const productName = app.product_name?.toLowerCase() || '';
            
            switch (category) {
                case 'insecticides':
                    return programme.includes('pest') || 
                           products.includes('neem') || 
                           products.includes('pyrethrin') ||
                           products.includes('spinosad') ||
                           products.includes('metarhizium') ||
                           productName.includes('bioneem') ||
                           productName.includes('pyrol') ||
                           productName.includes('metarhizium') ||
                           productName.includes('eco insect');
                case 'fungicides':
                    return programme.includes('fungal') || 
                           programme.includes('disease') ||
                           products.includes('fungicide') ||
                           products.includes('copper') ||
                           productName.includes('copper') ||
                           productName.includes('bacillus') ||
                           productName.includes('amylox') ||
                           productName.includes('lime sulphur') ||
                           productName.includes('trichoderma') ||
                           productName.includes('milk');
                case 'foliar-feeds':
                    return programme.includes('foliar') || 
                           programme.includes('nutrient') ||
                           products.includes('calmag') ||
                           products.includes('kelp') ||
                           products.includes('fish') ||
                           productName.includes('nitrosol') ||
                           productName.includes('eckosil') ||
                           productName.includes('seabrix') ||
                           productName.includes('oceanfert') ||
                           productName.includes('fulvic') ||
                           productName.includes('iron') ||
                           productName.includes('potassium') ||
                           productName.includes('calcium') ||
                           productName.includes('magnesium') ||
                           productName.includes('calsure') ||
                           productName.includes('organofert') ||
                           productName.includes('shiman');
                case 'soil-drenches':
                    return programme.includes('root') || 
                           programme.includes('drench') ||
                           products.includes('bacteria') ||
                           products.includes('enzyme');
                default:
                    return false;
            }
        });
    }

    // BCF Spray Plan Data (from BCF Spray Plan Feb2019.xlsx)
    getMockSprayApplications(category) {
        const bcfSprayData = {
            'insecticides': [
                {
                    id: 1,
                    product_name: 'Bioneem',
                    active_ingredient: 'Azadirachtin',
                    target_pest: 'Bollworm, Snout Beetle, Aphids, Two-Spotted Mite, European Red Mite, Codling Moth, Fruit Fly',
                    application_rate: '100',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Preventative Foliar - Combine with Foliar feeds'
                },
                {
                    id: 2,
                    product_name: 'Pyrol',
                    active_ingredient: 'Pyrethrin',
                    target_pest: 'Bollworm, Snout Beetle, Aphids, Two-Spotted Mite, European Red Mite, Codling Moth, Fruit Fly',
                    application_rate: '100',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive Foliar - Combine with Foliar feeds'
                },
                {
                    id: 3,
                    product_name: 'Metarhizium 62',
                    active_ingredient: 'Metarhizium anisopliae',
                    target_pest: 'Thrips, Whitefly, Snout Beetle',
                    application_rate: '5',
                    rate_unit: 'ml per 10L',
                    frequency_days: 10,
                    last_application: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Always Foliar - Combine with Foliar feeds'
                },
                {
                    id: 4,
                    product_name: 'Eco Insect Control',
                    active_ingredient: 'Spinosad',
                    target_pest: 'Thrips, Bollworm, Lawn Caterpillar',
                    application_rate: '7',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive Foliar - Combine with Foliar feeds'
                }
            ],
            'fungicides': [
                {
                    id: 5,
                    product_name: 'Copper Soap',
                    active_ingredient: 'Copper Octanoate',
                    target_disease: 'Downy Mildew, Powdery Mildew',
                    application_rate: '150',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Preventative Foliar - Combine with Foliar feeds'
                },
                {
                    id: 6,
                    product_name: 'Bacillus',
                    active_ingredient: 'Bacillus Subtilis',
                    target_disease: 'Downy Mildew, Powdery Mildew',
                    application_rate: '10',
                    rate_unit: 'ml per 10L',
                    frequency_days: 10,
                    last_application: new Date(Date.now() - 9 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Preventative Foliar - Combine with ORGANIC Foliar feeds'
                },
                {
                    id: 7,
                    product_name: 'AmyloX',
                    active_ingredient: 'Bacillus Amyloliquefaciens',
                    target_disease: 'Downy Mildew, Powdery Mildew',
                    application_rate: '20',
                    rate_unit: 'g per 10L',
                    frequency_days: 10,
                    last_application: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive - Combine with ORGANIC Foliar feeds'
                },
                {
                    id: 8,
                    product_name: 'Lime Sulphur',
                    active_ingredient: 'Polysulphide Sulphur',
                    target_disease: 'Downy Mildew, Powdery Mildew',
                    application_rate: '250',
                    rate_unit: 'ml per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 11 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive - Combine with ORGANIC Foliar feeds'
                },
                {
                    id: 9,
                    product_name: 'Full Cream Milk',
                    active_ingredient: 'Milk Protein',
                    target_disease: 'Powdery Mildew',
                    application_rate: '1 part milk to 2-3 parts water',
                    rate_unit: 'ratio',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive - Combine with ORGANIC Foliar feeds'
                },
                {
                    id: 10,
                    product_name: 'Trichoderma',
                    active_ingredient: 'Trichoderma asperellum oil',
                    target_disease: 'Pythium',
                    application_rate: '30',
                    rate_unit: 'ml per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 12 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Reactive - Combine with ORGANIC Foliar feeds'
                }
            ],
            'foliar-feeds': [
                {
                    id: 11,
                    product_name: 'Nitrosol',
                    nutrient_type: 'NPK, Magnesium, Calcium, Sulphur, Micronutrients, Growth hormone',
                    application_rate: '50',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Complete nutrient solution'
                },
                {
                    id: 12,
                    product_name: 'Eckosil',
                    nutrient_type: 'Silicium, Iron EDTA, Molybdenum, Zinc',
                    application_rate: '3',
                    rate_unit: 'ml per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Silicon and micronutrients'
                },
                {
                    id: 13,
                    product_name: 'Seabrix/Oceanfert/Seaboost/Seagrow',
                    nutrient_type: 'N, P, K, Ca, Mg + Micronutrients',
                    application_rate: '30',
                    rate_unit: 'ml per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Seaweed extract with complete nutrition'
                },
                {
                    id: 14,
                    product_name: 'Fulvic Acid',
                    nutrient_type: 'Fulvic Acid, Humic Acid',
                    application_rate: '7.5',
                    rate_unit: 'g per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Nutrient uptake enhancer'
                },
                {
                    id: 15,
                    product_name: 'Iron Chelate',
                    nutrient_type: 'Iron DPTA Chelate 11%',
                    application_rate: '25-50',
                    rate_unit: 'g per 10L',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Iron deficiency correction'
                },
                {
                    id: 16,
                    product_name: 'Potassium Nitrate',
                    nutrient_type: '38.7% Potassium, 61.3% Nitrate',
                    application_rate: '100',
                    rate_unit: 'g/0.5% per 10L with Nitrosol/Seaweed extract',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Potassium and nitrogen boost'
                },
                {
                    id: 17,
                    product_name: 'Calcium Nitrate',
                    nutrient_type: '24.4% Calcium, 77.6% Nitrate',
                    application_rate: '100',
                    rate_unit: 'g/0.5% per 10L with Nitrosol/Seaweed extract',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Calcium deficiency prevention'
                },
                {
                    id: 18,
                    product_name: 'Magnesium Sulphate (Epsom Salt)',
                    nutrient_type: '20.2% Magnesium, 79.8% Sulphate',
                    application_rate: '100',
                    rate_unit: 'g/0.5% per 10L with Nitrosol/Seaweed extract',
                    frequency_days: 10,
                    last_application: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - Promotes green growth, spray on leafy plants'
                },
                {
                    id: 19,
                    product_name: 'Calsure',
                    nutrient_type: 'Calcium Chelate',
                    application_rate: '200',
                    rate_unit: 'ml/1% per 10L with Fulvic acid',
                    frequency_days: 7,
                    last_application: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Use when Calcium Deficiency detected'
                },
                {
                    id: 20,
                    product_name: 'Organofert',
                    nutrient_type: 'Humic and Fulvic Acids, Earthworm extracts, Micro-Organisms and Fish Emulsion',
                    application_rate: '200',
                    rate_unit: 'ml per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 11 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Foliar Feed leaves - 10-14 day interval'
                },
                {
                    id: 21,
                    product_name: 'Shiman 2-1-2',
                    nutrient_type: 'Full spectrum of minerals',
                    application_rate: '20',
                    rate_unit: 'g per 10L',
                    frequency_days: 14,
                    last_application: new Date(Date.now() - 9 * 24 * 60 * 60 * 1000).toISOString(),
                    notes: 'Do not use with Lime Sulphur, Bordeaux mixture or Copper containing products'
                }
            ]
        };

        // Get base products from bcfSprayData
        const baseProducts = bcfSprayData[category] || [];
        
        // Get custom products from localStorage
        const storageKey = `custom_products_${category}`;
        const customProducts = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Combine base and custom products
        return [...baseProducts, ...customProducts];
    }

    // ========== CREATE SPRAY PROGRAMME FUNCTIONS ==========
    
    showCreateProgrammeModal() {
        const modal = document.getElementById('create-programme-modal');
        
        // Check for existing programmes
        this.checkExistingProgrammes();
        
        // Populate product dropdowns
        this.populateProgrammeDropdowns();
        
        // Set default start date to today
        const startDateInput = document.getElementById('programme-start-date');
        if (startDateInput) startDateInput.value = new Date().toISOString().split('T')[0];
        
        // Clear form
        const createProgrammeForm = document.getElementById('create-programme-form');
        const schedulePreview = document.getElementById('schedule-preview');
        
        if (createProgrammeForm) createProgrammeForm.reset();
        if (schedulePreview) schedulePreview.innerHTML = '<p class="text-muted">Select products to see schedule preview...</p>';
        
        // Add event listeners for live preview
        this.attachProgrammeEventListeners();
        
        // Show modal
        modal.classList.add('show');
        
        // Replace icon placeholders in the modal
        SVGIcons.replaceIconPlaceholders();
    }
    
    closeCreateProgrammeModal() {
        const modal = document.getElementById('create-programme-modal');
        modal.classList.remove('show');
        modal.style.display = 'none';
        
        // Reset modal title to original
        const title = modal.querySelector('.modal-header h3');
        title.innerHTML = `
            <img src="icons/new-icons/Afraponix Go Icons_time.svg" alt="Schedule" class="heading-icon"> 
            Create New Spray Programme
        `;
        
        // Reset save button to original state
        const saveButton = modal.querySelector('.modal-actions .btn-primary');
        saveButton.textContent = 'Create Programme';
        saveButton.onclick = () => this.createSprayProgramme();
        
        // Clear form
        document.getElementById('create-programme-form').reset();
        
        // Reset editing state
        this.editingProgrammeId = null;
    }
    
    checkExistingProgrammes() {
        // Get existing programmes from localStorage
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const activeProgrammes = programmes.filter(p => p.status === 'active');
        
        const notification = document.getElementById('existing-programme-notification');
        const countSpan = document.getElementById('programme-count');
        const listContainer = document.getElementById('existing-programmes-items');
        
        if (activeProgrammes.length > 0) {
            notification.style.display = 'block';
            countSpan.textContent = activeProgrammes.length;
            
            // List existing programmes
            listContainer.innerHTML = activeProgrammes.map(p => 
                `<li>${p.name} (Started: ${new Date(p.startDate).toLocaleDateString()})</li>`
            ).join('');
        } else {
            notification.style.display = 'none';
        }
    }
    
    populateProgrammeDropdowns() {
        // Get all available products
        const insecticides = this.getMockSprayApplications('insecticides');
        const fungicides = this.getMockSprayApplications('fungicides');
        const foliarFeeds = this.getMockSprayApplications('foliar-feeds');
        
        // Populate insecticide dropdowns
        const insecticideOptions = '<option value="">Select Insecticide</option>' + 
            insecticides.map(p => `<option value="${p.id}">${p.product_name}</option>`).join('');
        
        const insecticide1 = document.getElementById('insecticide-1');
        const insecticide2 = document.getElementById('insecticide-2');
        if (insecticide1) insecticide1.innerHTML = insecticideOptions;
        if (insecticide2) insecticide2.innerHTML = insecticideOptions;
        
        // Populate fungicide dropdowns
        const fungicideOptions = '<option value="">Select Fungicide</option>' + 
            fungicides.map(p => `<option value="${p.id}">${p.product_name}</option>`).join('');
        
        const fungicide1 = document.getElementById('fungicide-1');
        const fungicide2 = document.getElementById('fungicide-2');
        if (fungicide1) fungicide1.innerHTML = fungicideOptions;
        if (fungicide2) fungicide2.innerHTML = fungicideOptions;
        
        // Populate foliar feed dropdowns
        const foliarOptions = '<option value="">Select Foliar Feed</option>' + 
            foliarFeeds.map(p => `<option value="${p.id}">${p.product_name}</option>`).join('');
        
        const foliar1 = document.getElementById('foliar-1');
        const foliar2 = document.getElementById('foliar-2');
        if (foliar1) foliar1.innerHTML = foliarOptions;
        if (foliar2) foliar2.innerHTML = foliarOptions;
    }
    
    attachProgrammeEventListeners() {
        // Add change listeners to all product selects for live preview
        const selects = [
            'insecticide-1', 'insecticide-2',
            'fungicide-1', 'fungicide-2',
            'foliar-1', 'foliar-2'
        ];
        
        selects.forEach(id => {
            const element = document.getElementById(id);
            element.removeEventListener('change', this.updateSchedulePreview);
            element.addEventListener('change', () => this.updateSchedulePreview());
        });
        
        // Add listener for start date
        const startDate = document.getElementById('programme-start-date');
        startDate.removeEventListener('change', this.updateSchedulePreview);
        startDate.addEventListener('change', () => this.updateSchedulePreview());
    }
    
    updateSchedulePreview() {
        const preview = document.getElementById('schedule-preview');
        
        // Get selected products
        const selections = {
            insecticides: [
                document.getElementById('insecticide-1').value,
                document.getElementById('insecticide-2').value
            ].filter(v => v),
            fungicides: [
                document.getElementById('fungicide-1').value,
                document.getElementById('fungicide-2').value
            ].filter(v => v),
            foliarFeeds: [
                document.getElementById('foliar-1').value,
                document.getElementById('foliar-2').value
            ].filter(v => v)
        };
        
        // Check if at least one product is selected
        if (!selections.insecticides.length && !selections.fungicides.length && !selections.foliarFeeds.length) {
            preview.innerHTML = '<p class="text-muted">Select products to see schedule preview...</p>';
            return;
        }
        
        // Generate 4-week preview
        const startDate = new Date(document.getElementById('programme-start-date').value || new Date());
        const schedule = this.generateProgrammeSchedule(selections, startDate, 4);
        
        // Display preview
        let html = '';
        schedule.forEach((week, index) => {
            html += `
                <div class="schedule-week">
                    <h5>Week ${index + 1} (${week.startDate.toLocaleDateString()} - ${week.endDate.toLocaleDateString()})</h5>
            `;
            
            if (week.monday.length > 0) {
                html += `
                    <div class="schedule-day">
                        <strong>Monday:</strong>
                        <div class="schedule-products">
                            ${week.monday.map(p => `<span class="product-combo">${p}</span>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (week.wednesday.length > 0) {
                html += `
                    <div class="schedule-day">
                        <strong>Wednesday:</strong>
                        <div class="schedule-products">
                            ${week.wednesday.map(p => `<span class="product-combo">${p}</span>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
        });
        
        preview.innerHTML = html;
        
        // Check for conflicts
        this.checkScheduleConflicts(selections);
    }
    
    generateProgrammeSchedule(selections, startDate, weeks = 4) {
        const schedule = [];
        const allProducts = {
            insecticides: this.getMockSprayApplications('insecticides'),
            fungicides: this.getMockSprayApplications('fungicides'),
            foliarFeeds: this.getMockSprayApplications('foliar-feeds')
        };
        
        // Helper to get product name by ID
        const getProductName = (id, category) => {
            const product = allProducts[category].find(p => p.id == id);
            return product ? product.product_name : '';
        };
        
        for (let weekNum = 0; weekNum < weeks; weekNum++) {
            const weekStart = new Date(startDate);
            weekStart.setDate(startDate.getDate() + (weekNum * 7));
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            const week = {
                startDate: weekStart,
                endDate: weekEnd,
                monday: [],
                wednesday: []
            };
            
            // Monday: Insecticides + Foliar
            if (selections.insecticides.length > 0) {
                // Rotate insecticides
                const insecticideIndex = weekNum % Math.max(selections.insecticides.length, 1);
                const insecticideId = selections.insecticides[insecticideIndex];
                if (insecticideId) {
                    week.monday.push(getProductName(insecticideId, 'insecticides'));
                }
            }
            
            if (selections.foliarFeeds.length > 0) {
                // Rotate foliar feeds for Monday
                const foliarIndex = weekNum % Math.max(selections.foliarFeeds.length, 1);
                const foliarId = selections.foliarFeeds[foliarIndex];
                if (foliarId) {
                    week.monday.push(getProductName(foliarId, 'foliarFeeds'));
                }
            }
            
            // Wednesday: Fungicides + Foliar
            if (selections.fungicides.length > 0) {
                // Rotate fungicides
                const fungicideIndex = weekNum % Math.max(selections.fungicides.length, 1);
                const fungicideId = selections.fungicides[fungicideIndex];
                if (fungicideId) {
                    week.wednesday.push(getProductName(fungicideId, 'fungicides'));
                }
            }
            
            if (selections.foliarFeeds.length > 0) {
                // Rotate foliar feeds for Wednesday
                const foliarIndex = weekNum % Math.max(selections.foliarFeeds.length, 1);
                const foliarId = selections.foliarFeeds[foliarIndex];
                if (foliarId) {
                    week.wednesday.push(getProductName(foliarId, 'foliarFeeds'));
                }
            }
            
            schedule.push(week);
        }
        
        return schedule;
    }
    
    checkScheduleConflicts(selections) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const activeProgrammes = programmes.filter(p => p.status === 'active');
        
        const conflictWarning = document.getElementById('conflict-warnings');
        const conflictList = document.getElementById('conflict-list');
        
        const conflicts = [];
        
        activeProgrammes.forEach(programme => {
            const hasMonday = (selections.insecticides.length > 0 && programme.schedule.monday);
            const hasWednesday = (selections.fungicides.length > 0 && programme.schedule.wednesday);
            
            if (hasMonday || hasWednesday) {
                const days = [];
                if (hasMonday) days.push('Monday');
                if (hasWednesday) days.push('Wednesday');
                
                conflicts.push(`Programme "${programme.name}" also applies products on ${days.join(' and ')}`);
            }
        });
        
        if (conflicts.length > 0) {
            conflictWarning.style.display = 'block';
            conflictList.innerHTML = conflicts.map(c => `<li>${c}</li>`).join('');
        } else {
            conflictWarning.style.display = 'none';
        }
    }
    
    async createSprayProgramme() {
        // Validate form
        const programmeName = document.getElementById('programme-name').value.trim();
        const startDate = document.getElementById('programme-start-date').value;
        
        if (!programmeName) {
            this.showNotification('‚ùå Please enter a programme name', 'error');
            return;
        }
        
        if (!startDate) {
            this.showNotification('‚ùå Please select a start date', 'error');
            return;
        }
        
        // Get selections
        const selections = {
            insecticides: [
                document.getElementById('insecticide-1').value,
                document.getElementById('insecticide-2').value
            ].filter(v => v),
            fungicides: [
                document.getElementById('fungicide-1').value,
                document.getElementById('fungicide-2').value
            ].filter(v => v),
            foliarFeeds: [
                document.getElementById('foliar-1').value,
                document.getElementById('foliar-2').value
            ].filter(v => v)
        };
        
        // Validate at least one foliar spray
        if (selections.foliarFeeds.length === 0) {
            this.showNotification('‚ùå At least one foliar feed is required', 'error');
            return;
        }
        
        // Validate at least one pesticide
        if (selections.insecticides.length === 0 && selections.fungicides.length === 0) {
            this.showNotification('‚ùå Select at least one insecticide or fungicide', 'error');
            return;
        }
        
        // Check for duplicate programme name
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        if (programmes.some(p => p.name === programmeName)) {
            this.showNotification('‚ùå A programme with this name already exists', 'error');
            return;
        }
        
        // Create programme object
        const newProgramme = {
            id: Date.now(),
            name: programmeName,
            startDate: startDate,
            selections: selections,
            schedule: {
                monday: selections.insecticides.length > 0,
                wednesday: selections.fungicides.length > 0
            },
            currentWeek: 0,
            status: 'active',
            createdAt: new Date().toISOString(),
            systemId: this.activeSystemId
        };
        
        // Save programme
        programmes.push(newProgramme);
        localStorage.setItem('spray_programmes', JSON.stringify(programmes));
        
        this.showNotification('‚úÖ Spray programme created successfully!', 'success');
        this.closeCreateProgrammeModal();
        
        // Refresh spray programme display
        this.loadSprayProgrammes();
    }
    
    loadSprayProgrammes() {
        // Load and display all programmes for current system
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const systemProgrammes = programmes.filter(p => p.systemId === this.activeSystemId);
        
        const container = document.getElementById('active-programmes-container');
        
        if (systemProgrammes.length === 0) {
            container.innerHTML = `
                <div class="no-programmes-message" style="text-align: center; padding: 40px; grid-column: 1/-1;">
                    <p class="text-muted">No active spray programmes</p>
                    <p class="text-small text-muted">Create a programme to automate your spray schedule</p>
                </div>
            `;
            return;
        }
        
        // Display programme cards
        container.innerHTML = systemProgrammes.map(programme => this.createProgrammeCard(programme)).join('');
    }
    
    createProgrammeCard(programme) {
        // Get product names for display
        const allProducts = {
            insecticides: this.getMockSprayApplications('insecticides'),
            fungicides: this.getMockSprayApplications('fungicides'),
            foliarFeeds: this.getMockSprayApplications('foliar-feeds')
        };
        
        const getProductNames = (ids, category) => {
            return ids.map(id => {
                const product = allProducts[category].find(p => p.id == id);
                return product ? product.product_name : '';
            }).filter(name => name).join(', ');
        };
        
        // Calculate next application date
        const nextApplication = this.getNextApplicationDate(programme);
        
        // Build schedule display
        let scheduleHtml = '<div class="programme-schedule">';
        if (programme.schedule.monday) {
            const insecticides = getProductNames(programme.selections.insecticides, 'insecticides');
            const foliar = getProductNames(programme.selections.foliarFeeds, 'foliarFeeds');
            scheduleHtml += `
                <div class="programme-schedule-item">
                    <span class="programme-schedule-day">Monday:</span>
                    <span class="programme-products">${insecticides} + ${foliar}</span>
                </div>
            `;
        }
        if (programme.schedule.wednesday) {
            const fungicides = getProductNames(programme.selections.fungicides, 'fungicides');
            const foliar = getProductNames(programme.selections.foliarFeeds, 'foliarFeeds');
            scheduleHtml += `
                <div class="programme-schedule-item">
                    <span class="programme-schedule-day">Wednesday:</span>
                    <span class="programme-products">${fungicides} + ${foliar}</span>
                </div>
            `;
        }
        scheduleHtml += '</div>';
        
        return `
            <div class="programme-card" data-programme-id="${programme.id}">
                <div class="programme-card-header">
                    <div class="programme-title-section">
                        <h5 class="programme-name">${programme.name}</h5>
                        <button class="programme-edit-btn" onclick="app.editProgramme(${programme.id})" title="Edit Programme">
                            ${SVGIcons.getIcon('edit', 'btn-icon-svg')}
                        </button>
                    </div>
                    <span class="programme-status ${programme.status}">${programme.status}</span>
                </div>
                
                ${scheduleHtml}
                
                <div class="programme-next-application">
                    <strong>Next Application:</strong> ${nextApplication}
                </div>
                
                <div class="programme-actions">
                    ${programme.status === 'active' ? 
                        `<button class="btn btn-sm btn-secondary" onclick="app.pauseProgramme(${programme.id})">Pause</button>` :
                        `<button class="btn btn-sm btn-primary" onclick="app.resumeProgramme(${programme.id})">Resume</button>`
                    }
                    <button class="btn btn-sm btn-secondary" onclick="app.viewProgrammeDetails(${programme.id})">Details</button>
                    <button class="btn btn-sm btn-danger" onclick="app.deleteProgramme(${programme.id})">Delete</button>
                </div>
            </div>
        `;
    }
    
    getNextApplicationDate(programme) {
        if (programme.status !== 'active') {
            return 'Programme paused';
        }
        
        const today = new Date();
        const startDate = new Date(programme.startDate);
        
        // Calculate weeks since start
        const weeksSinceStart = Math.floor((today - startDate) / (7 * 24 * 60 * 60 * 1000));
        
        // Find next Monday or Wednesday
        const daysOfWeek = [];
        if (programme.schedule.monday) daysOfWeek.push(1); // Monday
        if (programme.schedule.wednesday) daysOfWeek.push(3); // Wednesday
        
        let nextDate = new Date(today);
        for (let i = 0; i < 7; i++) {
            const checkDate = new Date(today);
            checkDate.setDate(today.getDate() + i);
            const dayOfWeek = checkDate.getDay();
            
            if (daysOfWeek.includes(dayOfWeek)) {
                nextDate = checkDate;
                break;
            }
        }
        
        // Determine which products will be applied
        const weekNum = Math.floor((nextDate - startDate) / (7 * 24 * 60 * 60 * 1000));
        const dayName = nextDate.getDay() === 1 ? 'Monday' : 'Wednesday';
        
        return `${dayName}, ${nextDate.toLocaleDateString()}`;
    }
    
    pauseProgramme(programmeId) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === programmeId);
        
        if (programme) {
            programme.status = 'paused';
            programme.pausedAt = new Date().toISOString();
            localStorage.setItem('spray_programmes', JSON.stringify(programmes));
            
            this.showNotification(`Programme "${programme.name}" paused`, 'info');
            this.loadSprayProgrammes();
        }
    }
    
    resumeProgramme(programmeId) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === programmeId);
        
        if (programme) {
            programme.status = 'active';
            delete programme.pausedAt;
            localStorage.setItem('spray_programmes', JSON.stringify(programmes));
            
            this.showNotification(`Programme "${programme.name}" resumed`, 'success');
            this.loadSprayProgrammes();
        }
    }
    
    deleteProgramme(programmeId) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === programmeId);
        
        if (!programme) {
            this.showNotification('‚ùå Programme not found', 'error');
            return;
        }
        
        // Store the programme ID for confirmation
        this.deletingProgrammeId = programmeId;
        
        // Show delete confirmation modal
        const modal = document.getElementById('delete-programme-modal');
        const programmeNameSpan = document.getElementById('delete-programme-name');
        
        programmeNameSpan.textContent = programme.name;
        modal.style.display = 'flex';
    }
    
    closeDeleteProgrammeModal() {
        const modal = document.getElementById('delete-programme-modal');
        modal.style.display = 'none';
        this.deletingProgrammeId = null;
    }
    
    confirmDeleteProgramme() {
        if (!this.deletingProgrammeId) return;
        
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === this.deletingProgrammeId);
        
        if (programme) {
            const updatedProgrammes = programmes.filter(p => p.id !== this.deletingProgrammeId);
            localStorage.setItem('spray_programmes', JSON.stringify(updatedProgrammes));
            
            // Close modal
            this.closeDeleteProgrammeModal();
            
            // Refresh displays
            this.loadSprayProgrammes();
            this.loadSprayApplications();
            this.updateSprayCalendarMock();
            
            this.showNotification(`‚úÖ Programme "${programme.name}" deleted successfully`, 'success');
        }
    }
    
    viewProgrammeDetails(programmeId) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === programmeId);
        
        if (programme) {
            // Generate 8-week schedule preview
            const startDate = new Date(programme.startDate);
            const schedule = this.generateProgrammeSchedule(programme.selections, startDate, 8);
            
            // Create and show details modal
            this.showProgrammeDetailsModal(programme, schedule);
        }
    }
    
    showProgrammeDetailsModal(programme, schedule) {
        // Create a simple modal to show programme details
        const modalHtml = `
            <div id="programme-details-modal" class="modal-overlay show">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="heading-3">${programme.name} - Details</h3>
                        <button class="modal-close" onclick="document.getElementById('programme-details-modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p><strong>Status:</strong> ${programme.status}</p>
                        <p><strong>Started:</strong> ${new Date(programme.startDate).toLocaleDateString()}</p>
                        <p><strong>Created:</strong> ${new Date(programme.createdAt).toLocaleDateString()}</p>
                        
                        <h4 class="heading-4" style="margin-top: 20px;">8-Week Schedule Preview</h4>
                        <div class="schedule-preview-container">
                            ${schedule.map((week, index) => `
                                <div class="schedule-week">
                                    <h5>Week ${index + 1} (${week.startDate.toLocaleDateString()} - ${week.endDate.toLocaleDateString()})</h5>
                                    ${week.monday.length > 0 ? `
                                        <div class="schedule-day">
                                            <strong>Monday:</strong>
                                            <div class="schedule-products">
                                                ${week.monday.map(p => `<span class="product-combo">${p}</span>`).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                    ${week.wednesday.length > 0 ? `
                                        <div class="schedule-day">
                                            <strong>Wednesday:</strong>
                                            <div class="schedule-products">
                                                ${week.wednesday.map(p => `<span class="product-combo">${p}</span>`).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="modal-actions">
                        <button onclick="document.getElementById('programme-details-modal').remove()" class="btn btn-primary">Close</button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    editProgramme(programmeId) {
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programme = programmes.find(p => p.id === programmeId);
        
        if (!programme) {
            this.showNotification('‚ùå Programme not found', 'error');
            return;
        }
        
        // Store the programme ID for editing
        this.editingProgrammeId = programmeId;
        
        // Open the create programme modal but populate it with existing data
        const modal = document.getElementById('create-programme-modal');
        const title = modal.querySelector('.modal-header h3');
        const nameInput = document.getElementById('programme-name');
        const startDateInput = document.getElementById('programme-start-date');
        
        // Update modal title
        title.innerHTML = `
            <img src="icons/new-icons/Afraponix Go Icons_time.svg" alt="Edit" class="heading-icon"> 
            Edit Programme: ${programme.name}
        `;
        
        // Populate form with existing data
        nameInput.value = programme.name;
        if (programme.startDate) {
            startDateInput.value = programme.startDate;
        }
        
        // Populate product selections
        if (programme.selections) {
            // Clear all dropdown selections first
            document.getElementById('insecticide-1').value = '';
            document.getElementById('insecticide-2').value = '';
            document.getElementById('fungicide-1').value = '';
            document.getElementById('fungicide-2').value = '';
            document.getElementById('foliar-1').value = '';
            document.getElementById('foliar-2').value = '';
            
            // Populate insecticides
            if (programme.selections.insecticides && programme.selections.insecticides.length > 0) {
                document.getElementById('insecticide-1').value = programme.selections.insecticides[0] || '';
                if (programme.selections.insecticides.length > 1) {
                    document.getElementById('insecticide-2').value = programme.selections.insecticides[1] || '';
                }
            }
            
            // Populate fungicides
            if (programme.selections.fungicides && programme.selections.fungicides.length > 0) {
                document.getElementById('fungicide-1').value = programme.selections.fungicides[0] || '';
                if (programme.selections.fungicides.length > 1) {
                    document.getElementById('fungicide-2').value = programme.selections.fungicides[1] || '';
                }
            }
            
            // Populate foliar feeds
            if (programme.selections.foliarFeeds && programme.selections.foliarFeeds.length > 0) {
                document.getElementById('foliar-1').value = programme.selections.foliarFeeds[0] || '';
                if (programme.selections.foliarFeeds.length > 1) {
                    document.getElementById('foliar-2').value = programme.selections.foliarFeeds[1] || '';
                }
            }
        }
        
        // Update the save button to say "Update Programme"
        const saveButton = modal.querySelector('.modal-actions .btn-primary');
        saveButton.textContent = 'Update Programme';
        saveButton.onclick = () => this.updateExistingProgramme();
        
        // Show the modal
        modal.style.display = 'flex';
    }
    
    updateExistingProgramme() {
        if (!this.editingProgrammeId) return;
        
        const programmeName = document.getElementById('programme-name').value.trim();
        const startDate = document.getElementById('programme-start-date').value;
        
        if (!programmeName) {
            this.showNotification('‚ùå Programme name is required', 'error');
            return;
        }
        
        // Get product selections from dropdowns
        const selections = {
            insecticides: [
                document.getElementById('insecticide-1').value,
                document.getElementById('insecticide-2').value
            ].filter(v => v),
            fungicides: [
                document.getElementById('fungicide-1').value,
                document.getElementById('fungicide-2').value
            ].filter(v => v),
            foliarFeeds: [
                document.getElementById('foliar-1').value,
                document.getElementById('foliar-2').value
            ].filter(v => v)
        };
        
        // Validate at least one foliar spray
        if (selections.foliarFeeds.length === 0) {
            this.showNotification('‚ùå At least one foliar feed is required', 'error');
            return;
        }
        
        // Validate at least one pesticide
        if (selections.insecticides.length === 0 && selections.fungicides.length === 0) {
            this.showNotification('‚ùå Select at least one insecticide or fungicide', 'error');
            return;
        }
        
        // Calculate schedule based on product selections
        const schedule = {
            monday: selections.insecticides.length > 0,
            wednesday: selections.fungicides.length > 0
        };
        
        // Validate that at least one product is selected
        const hasProducts = Object.values(selections).some(category => category.length > 0);
        if (!hasProducts) {
            this.showNotification('‚ùå Please select at least one product', 'error');
            return;
        }
        
        // Update the programme
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const programmeIndex = programmes.findIndex(p => p.id === this.editingProgrammeId);
        
        if (programmeIndex === -1) {
            this.showNotification('‚ùå Programme not found', 'error');
            return;
        }
        
        // Check for duplicate name (excluding current programme)
        if (programmes.some(p => p.name === programmeName && p.id !== this.editingProgrammeId)) {
            this.showNotification('‚ùå A programme with this name already exists', 'error');
            return;
        }
        
        // Update the programme data
        programmes[programmeIndex] = {
            ...programmes[programmeIndex],
            name: programmeName,
            startDate: startDate || new Date().toISOString().split('T')[0],
            schedule: schedule,
            selections: selections,
            lastModified: new Date().toISOString()
        };
        
        // Save to localStorage
        localStorage.setItem('spray_programmes', JSON.stringify(programmes));
        
        // Close modal and refresh displays
        this.closeCreateProgrammeModal();
        this.loadSprayProgrammes();
        this.loadSprayApplications();
        this.updateSprayCalendarMock();
        
        // Reset editing state
        this.editingProgrammeId = null;
        
        this.showNotification(`‚úÖ Programme "${programmeName}" updated successfully`, 'success');
    }
    
    updateSprayCalendarMock() {
        // Get active programmes from localStorage
        const programmes = JSON.parse(localStorage.getItem('spray_programmes') || '[]');
        const activeProgrammes = programmes.filter(p => 
            p.systemId === this.activeSystemId && p.status === 'active'
        );
        
        if (activeProgrammes.length > 0) {
            this.displayProgrammeCalendar(activeProgrammes);
        } else {
            // No active programmes, show empty message
            const container = document.getElementById('spray-calendar-container');
            if (container) {
                container.innerHTML = '<p style="color: #666; text-align: center;">No active programmes. Create a programme to see upcoming applications.</p>';
            }
        }
    }
    
    displayProgrammeCalendar(programmes) {
        const container = document.getElementById('spray-calendar-container');
        if (!container) {
            return;
        }
        
        // Get next 14 days of applications
        const today = new Date();
        const upcomingApplications = [];
        
        programmes.forEach((programme) => {
            // Get product names
            const allProducts = {
                insecticides: this.getMockSprayApplications('insecticides'),
                fungicides: this.getMockSprayApplications('fungicides'),
                foliarFeeds: this.getMockSprayApplications('foliar-feeds')
            };
            
            // Check next 14 days
            for (let dayOffset = 0; dayOffset < 14; dayOffset++) {
                const checkDate = new Date(today);
                checkDate.setDate(today.getDate() + dayOffset);
                const dayOfWeek = checkDate.getDay();
                
                // Calculate week number for rotation
                const startDate = new Date(programme.startDate);
                const weeksSinceStart = Math.floor((checkDate - startDate) / (7 * 24 * 60 * 60 * 1000));
                
                
                let products = [];
                
                // Monday applications
                if (dayOfWeek === 1 && programme.schedule.monday) {
                    const insecticideIndex = weeksSinceStart % Math.max(programme.selections.insecticides.length, 1);
                    const foliarIndex = weeksSinceStart % Math.max(programme.selections.foliarFeeds.length, 1);
                    
                    
                    if (programme.selections.insecticides[insecticideIndex]) {
                        const insecticide = allProducts.insecticides.find(p => 
                            p.id == programme.selections.insecticides[insecticideIndex]
                        );
                        if (insecticide) {
                            products.push(insecticide.product_name);
                        }
                    }
                    
                    if (programme.selections.foliarFeeds[foliarIndex]) {
                        const foliar = allProducts.foliarFeeds.find(p => 
                            p.id == programme.selections.foliarFeeds[foliarIndex]
                        );
                        if (foliar) {
                            products.push(foliar.product_name);
                        }
                    }
                }
                
                // Wednesday applications
                if (dayOfWeek === 3 && programme.schedule.wednesday) {
                    const fungicideIndex = weeksSinceStart % Math.max(programme.selections.fungicides.length, 1);
                    const foliarIndex = weeksSinceStart % Math.max(programme.selections.foliarFeeds.length, 1);
                    
                    
                    if (programme.selections.fungicides[fungicideIndex]) {
                        const fungicide = allProducts.fungicides.find(p => 
                            p.id == programme.selections.fungicides[fungicideIndex]
                        );
                        if (fungicide) {
                            products.push(fungicide.product_name);
                        }
                    }
                    
                    if (programme.selections.foliarFeeds[foliarIndex]) {
                        const foliar = allProducts.foliarFeeds.find(p => 
                            p.id == programme.selections.foliarFeeds[foliarIndex]
                        );
                        if (foliar) {
                            products.push(foliar.product_name);
                        }
                    }
                }
                
                if (products.length > 0) {
                    upcomingApplications.push({
                        date: checkDate,
                        programme: programme.name,
                        products: products
                    });
                }
            }
        });
        
        // Sort by date
        upcomingApplications.sort((a, b) => a.date - b.date);
        
        // Display calendar
        if (upcomingApplications.length === 0) {
            container.innerHTML = '<p style="color: #666; text-align: center;">No applications scheduled in the next 14 days.</p>';
            return;
        }
        
        let html = '<div class="upcoming-applications-list">';
        
        upcomingApplications.forEach(app => {
            const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][app.date.getDay()];
            const isToday = app.date.toDateString() === today.toDateString();
            const isTomorrow = app.date.toDateString() === new Date(today.getTime() + 24*60*60*1000).toDateString();
            
            let dateLabel = `${dayName}, ${app.date.toLocaleDateString()}`;
            if (isToday) dateLabel = `Today (${dayName})`;
            if (isTomorrow) dateLabel = `Tomorrow (${dayName})`;
            
            html += `
                <div class="upcoming-application-item ${isToday ? 'today' : ''} ${isTomorrow ? 'tomorrow' : ''}">
                    <div class="application-date">
                        <strong>${dateLabel}</strong>
                        <span class="programme-label">${app.programme}</span>
                    </div>
                    <div class="application-products">
                        ${app.products.map(p => `<span class="product-tag">${p}</span>`).join(' + ')}
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }

    getGeneralSpraySchedule() {
        const today = new Date();
        const schedule = [];

        // Create a general weekly schedule
        const scheduleItems = [
            {
                category: 'Insecticides',
                description: 'Pest Control Application',
                daysFromNow: 2,
                type: 'pesticide',
                icon: 'üêõ'
            },
            {
                category: 'Foliar Feeds',
                description: 'Nutrient Foliar Spray',
                daysFromNow: 3,
                type: 'foliar',
                icon: 'üåø'
            },
            {
                category: 'Fungicides',
                description: 'Disease Prevention Spray',
                daysFromNow: 5,
                type: 'fungicide',
                icon: 'üçÑ'
            },
            {
                category: 'Insecticides',
                description: 'Pest Prevention Check',
                daysFromNow: 9,
                type: 'pesticide',
                icon: 'üêõ'
            },
            {
                category: 'Foliar Feeds',
                description: 'Weekly Nutrient Feed',
                daysFromNow: 10,
                type: 'foliar',
                icon: 'üåø'
            },
            {
                category: 'Fungicides',
                description: 'Preventative Fungicide',
                daysFromNow: 12,
                type: 'fungicide',
                icon: 'üçÑ'
            }
        ];

        scheduleItems.forEach(item => {
            const date = new Date(today);
            date.setDate(today.getDate() + item.daysFromNow);
            
            schedule.push({
                date: date,
                category: item.category,
                description: item.description,
                type: item.type,
                icon: item.icon,
                daysFromNow: item.daysFromNow
            });
        });

        return schedule.sort((a, b) => a.date - b.date);
    }

    displayGeneralSprayCalendar(schedule) {
        const container = document.getElementById('spray-calendar-container');
        if (!container) return;

        if (schedule.length === 0) {
            container.innerHTML = '<p style="color: #666; text-align: center;">No spray schedule available.</p>';
            return;
        }

        let html = '<div class="upcoming-sprays">';
        schedule.slice(0, 6).forEach(item => {
            const isOverdue = item.daysFromNow < 0;
            const isToday = item.daysFromNow === 0;
            const isTomorrow = item.daysFromNow === 1;
            const urgency = isOverdue ? 'overdue' : item.daysFromNow <= 3 ? 'urgent' : 'normal';
            
            let timeText = '';
            if (isOverdue) {
                timeText = '<span class="overdue-badge">Overdue</span>';
            } else if (isToday) {
                timeText = '<span class="today-badge">Today</span>';
            } else if (isTomorrow) {
                timeText = '<span class="tomorrow-badge">Tomorrow</span>';
            } else {
                timeText = `<span class="days-badge">${item.daysFromNow} days</span>`;
            }
            
            html += `
                <div class="upcoming-spray ${urgency}">
                    <div class="spray-date">
                        ${this.formatDateDDMMYYYY(item.date)}
                        ${timeText}
                    </div>
                    <div class="spray-info">
                        <strong>${item.icon} ${item.description}</strong>
                        <span class="spray-category">${item.category}</span>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        container.innerHTML = html;
    }

    // Fish Management Tab Methods
    async loadFishOverview() {
        console.log('üì° Loading Fish Overview...');
        const container = document.getElementById('tank-summary-container');
        if (!container) {
            console.warn('‚ùå Tank summary container not found');
            return;
        }

        try {
            // Show loading state
            container.innerHTML = '<div class="loading-message">Loading fish overview...</div>';

            // Ensure system is selected
            if (!this.activeSystemId) {
                console.warn('‚ùå No active system selected');
                container.innerHTML = '<div class="no-data">Please select a system first</div>';
                return;
            }

            // Force fresh data loading with proper sequencing
            console.log('üîÑ Step 1: Loading fresh data records...');
            await this.loadDataRecords();
            
            // Additional delay to ensure all data APIs have completed
            console.log('‚è≥ Step 2: Waiting for data processing...');
            await new Promise(resolve => setTimeout(resolve, 500));

            // Verify data is actually loaded before proceeding
            console.log('üîç Step 3: Verifying data availability...');
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const hasData = this.dataRecords && (
                    this.dataRecords.fishHealth?.length > 0 || 
                    this.dataRecords.fishInventory?.tanks?.length > 0
                );
                
                if (hasData) {
                    console.log('‚úÖ Data verified and ready');
                    break;
                }
                
                console.log(`‚è≥ Attempt ${attempts + 1}: Waiting for data...`);
                await new Promise(resolve => setTimeout(resolve, 200));
                attempts++;
            }

            if (attempts >= maxAttempts) {
                console.warn('‚ö†Ô∏è Proceeding without full data verification');
            }

            // Load tank summary data
            console.log('üìä Step 4: Displaying fish tank summary...');
            await this.displayFishTankSummary();
            
            console.log('‚úÖ Fish overview loaded successfully');
        } catch (error) {
            console.error('‚ùå Error loading fish overview:', error);
            container.innerHTML = '<div class="error-message">Failed to load fish overview. Please try again.</div>';
        }
    }

    async displayFishTankSummary() {

        const container = document.getElementById('tank-summary-container');
        if (!container) return;

        try {
            // Get system data for tank information
            const systemData = this.getActiveSystem();
            if (!systemData) {
                container.innerHTML = '<p class="no-data">No system data available. Please configure your system in Settings.</p>';
                return;
            }
            

            // Fetch actual fish tank configurations to get real total volume
            let actualTotalVolumeL = systemData.total_fish_volume || 1000;
            try {
                const tankResponse = await this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}`);
                const fishTanks = tankResponse.tanks || [];

                if (fishTanks.length > 0) {
                    actualTotalVolumeL = 0;
                    fishTanks.forEach((tank, index) => {
                        const volumeL = parseFloat(tank.volume_liters) || 0;

                        actualTotalVolumeL += volumeL;
                    });

                } else {

                }
            } catch (error) {

            }

            // Generate fish overview cards similar to plant overview
            await this.displayFishOverviewCards(container, actualTotalVolumeL);

        } catch (error) {
            console.error('Failed to display fish tank summary:', error);
            // Don't show error to user, just log it - the calculator will still work
        }
    }

    async loadFishHealthEntry() {

        const container = document.querySelector('#fish-health-entry-content .data-entry-section');
        if (!container) return;

        // Create new streamlined fish tank monitoring interface
        const formHtml = await this.generateTankMonitoringForm();
        container.innerHTML = formHtml;

        // Load recent tank data
        this.loadTankMonitoringHistory();

        // Auto-populate feed data from most recent entries
        await this.populateDataCaptureFeedingData();

        // Setup form submission handlers
        this.setupTankMonitoringHandlers();
    }

    generateFishHealthForm() {
        const tankOptions = this.generateTankOptions();
        
        return `
            <form id="fish-health-entry-form" class="data-form-element">
                <h3><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px;"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" fill="#0051b1"/></svg> Data Capture</h3>
                
                <div class="form-row">
                    <div class="form-field">
                        <label for="fish-tank">Tank:</label>
                        <select id="fish-tank" required>
                            ${tankOptions}
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="fish-count">Current Fish Count:</label>
                        <input type="number" id="fish-count" min="0" placeholder="Current total" readonly style="background-color: #f5f5f5; cursor: not-allowed;">
                        <small style="color: #666; font-size: 0.8em;">Auto-calculated from additions/mortality</small>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-field">
                        <label for="new-fish-added">New Fish Added:</label>
                        <input type="number" id="new-fish-added" min="0" placeholder="Number of fish added">
                    </div>
                    <div class="form-field">
                        <label for="new-fish-weight">Avg Weight of New Fish (g):</label>
                        <input type="number" id="new-fish-weight" step="0.1" min="0" placeholder="0.0">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-field">
                        <label for="fish-mortality">New Mortalities:</label>
                        <input type="number" id="fish-mortality" min="0" placeholder="Number of deaths">
                    </div>
                    <div class="form-field">
                        <label for="mortality-weight">Avg Weight of Mortalities (g):</label>
                        <input type="number" id="mortality-weight" step="0.1" min="0" placeholder="0.0">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-field">
                        <label for="average-weight">Current Avg Weight (g):</label>
                        <input type="number" id="average-weight" step="0.1" min="0" placeholder="0.0">
                    </div>
                    <div class="form-field">
                        <label for="feed-consumption">Feed Consumption (g):</label>
                        <input type="number" id="feed-consumption" step="0.1" min="0" placeholder="0.0">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-field">
                        <label for="fish-behavior">Behavior:</label>
                        <select id="fish-behavior">
                            <option value="normal">Normal</option>
                            <option value="lethargic">Lethargic</option>
                            <option value="aggressive">Aggressive</option>
                            <option value="stressed">Stressed</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="fish-entry-date">Date & Time:</label>
                        <input type="datetime-local" id="fish-entry-date" value="${new Date().toISOString().slice(0, 16)}">
                    </div>
                </div>
                
                <div class="form-field">
                    <label for="fish-notes">Notes:</label>
                    <textarea id="fish-notes" rows="3" placeholder="Additional observations..."></textarea>
                </div>
                
                <button type="submit" class="form-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 4px;">
                        <path d="M17 3H5C3.89 3 3 3.89 3 5V19C3 20.1 3.89 21 5 21H19C20.1 21 21 20.1 21 19V7L17 3M19 19H5V5H16.17L19 7.83V19M12 12C13.66 12 15 13.34 15 15S13.66 18 12 18 9 16.66 9 15 10.34 12 12 12M6 6H15V10H6V6Z" fill="#0051b1"/>
                    </svg>
                    Save Data Entry
                </button>
            </form>
        `;
    }

    async generateTankMonitoringForm() {
        return this.tankMonitoringForm.generateTankMonitoringForm();
    }

    setupTankMonitoringHandlers() {
        return this.tankMonitoringForm.setupTankMonitoringHandlers();
    }

    loadTankMonitoringHistory() {
        return this.tankMonitoringForm.loadTankMonitoringHistory();
    }

    async submitBulkTankData() {
        // Prevent double submission
        if (this.isSubmittingBulkData) {
            return;
        }
        
        const monitoringTime = document.getElementById('monitoring-time').value;
        
        if (!monitoringTime) {
            this.showNotification('Please select a time for the entries', 'warning');
            return;
        }

        this.isSubmittingBulkData = true;
        
        try {
            const currentDate = new Date().toISOString().split('T')[0];
            const dateTime = `${currentDate} ${monitoringTime}`;
            
            // Get all tank rows
            const tankRows = document.querySelectorAll('[data-tank-id]');
            const entries = [];
            let totalEntries = 0;

            // Collect data from each tank row
            tankRows.forEach(row => {
                const tankId = row.getAttribute('data-tank-id');
                const feedAmount = document.getElementById(`feed-amount-${tankId}`)?.value;
                const feedType = document.getElementById(`feed-type-${tankId}`)?.value;
                const behavior = document.getElementById(`behavior-${tankId}`)?.value;
                const mortality = document.getElementById(`mortality-${tankId}`)?.value;
                const notes = document.getElementById(`notes-${tankId}`)?.value;

                // Only create entries if there's actual meaningful data to record
                if ((feedAmount && feedAmount.trim() !== '') || 
                    (feedType && feedType.trim() !== '') || 
                    (behavior && behavior.trim() !== '') || 
                    (mortality && mortality.trim() !== '' && mortality !== '0') || 
                    (notes && notes.trim() !== '')) {
                    const entry = {
                        tankId: parseInt(tankId),
                        date: dateTime,
                        feedConsumption: feedAmount ? parseFloat(feedAmount) : null,
                        feedType: feedType || null,
                        behavior: null,
                        mortality: mortality ? parseInt(mortality) : null,
                        notes: notes || null
                    };

                    // Handle behavior and feeding together
                    if (behavior && feedAmount && feedType) {
                        entry.behavior = `${behavior.replace(/_/g, ' ').replace(/^./, str => str.toUpperCase())} - Fed: ${feedType}`;
                    } else if (behavior) {
                        entry.behavior = behavior.replace(/_/g, ' ').replace(/^./, str => str.toUpperCase());
                    } else if (feedAmount && feedType) {
                        entry.behavior = `Fed: ${feedType}`;
                    } else if (feedAmount) {
                        entry.behavior = 'Feeding recorded';
                    } else if (mortality && mortality > 0) {
                        entry.behavior = 'Mortality event';
                    } else if (notes) {
                        entry.behavior = 'General observation';
                    }

                    entries.push(entry);
                    totalEntries++;
                }
            });

            if (entries.length === 0) {
                this.showNotification('No data entered to record', 'warning');
                return;
            }

            // Show progress
            const submitBtn = document.querySelector('#bulk-tank-monitoring-form button[type="submit"]');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<span>Recording...</span>';
            submitBtn.disabled = true;

            // Submit all entries
            const promises = entries.map(entry => 
                this.makeApiCall('/data/entries/fish-health', {
                    method: 'POST',
                    body: JSON.stringify({
                        system_id: this.activeSystemId,
                        fish_tank_id: entry.tankId,
                        date: entry.date,
                        feed_consumption: entry.feedConsumption,
                        feed_type: entry.feedType,
                        behavior: entry.behavior,
                        mortality: entry.mortality,
                        notes: entry.notes
                    })
                })
            );

            await Promise.all(promises);

            // Show success
            this.showNotification(`üìä Successfully recorded ${totalEntries} tank monitoring entries`, 'success');
            
            // Clear form and refresh
            this.clearAllTankInputs();
            this.loadTodaysTankEntries();
            
            // Reset button
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
            
            // Reset submission flag
            this.isSubmittingBulkData = false;

        } catch (error) {
            console.error('Failed to record tank data:', error);
            this.showNotification('‚ùå Failed to record some entries. Please try again.', 'error');
            
            // Reset button
            const submitBtn = document.querySelector('#bulk-tank-monitoring-form button[type="submit"]');
            submitBtn.innerHTML = submitBtn.innerHTML.replace('Recording...', 'Record All Data');
            submitBtn.disabled = false;
            
            // Reset submission flag
            this.isSubmittingBulkData = false;
        }
    }

    clearAllTankInputs() {
        // Clear all input fields in the tank monitoring table
        const tankRows = document.querySelectorAll('[data-tank-id]');
        
        tankRows.forEach(row => {
            const tankId = row.getAttribute('data-tank-id');
            const feedAmountInput = document.getElementById(`feed-amount-${tankId}`);
            const feedTypeInput = document.getElementById(`feed-type-${tankId}`);
            const behaviorSelect = document.getElementById(`behavior-${tankId}`);
            const mortalityInput = document.getElementById(`mortality-${tankId}`);
            const notesTextarea = document.getElementById(`notes-${tankId}`);
            
            if (feedAmountInput) feedAmountInput.value = '';
            if (feedTypeInput) feedTypeInput.value = '';
            if (behaviorSelect) behaviorSelect.value = '';
            if (mortalityInput) mortalityInput.value = '';
            if (notesTextarea) notesTextarea.value = '';
        });

        this.showNotification('All inputs cleared', 'info');
    }

    async loadTodaysTankEntries() {
        if (!this.activeSystemId) return;

        try {
            const today = new Date().toISOString().split('T')[0];
            const entries = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}`);
            
            // Filter for today's entries
            const todaysEntries = entries.filter(entry => 
                entry.date && entry.date.includes(today)
            ).sort((a, b) => new Date(b.date) - new Date(a.date));

            const entriesList = document.getElementById('today-entries-list');
            if (!entriesList) return;

            if (todaysEntries.length === 0) {
                entriesList.innerHTML = '<p style="color: #666; text-align: center; padding: 1rem;">No entries recorded today</p>';
                return;
            }

            let html = '';
            todaysEntries.forEach(entry => {
                const time = entry.date ? new Date(entry.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : 'Unknown';
                // Use tank_number if available, otherwise fallback to fish_tank_id
                const tankNumber = entry.tank_number || entry.fish_tank_id || entry.tankId || 'Unknown';
                
                let entryType = 'üìù';
                let description = 'General entry';
                
                if (entry.feed_consumption && entry.feed_consumption > 0) {
                    entryType = 'üçΩÔ∏è';
                    description = `Fed ${entry.feed_consumption}g`;
                    if (entry.feed_type) {
                        description += ` (${entry.feed_type})`;
                    }
                } else if (entry.mortality && entry.mortality > 0) {
                    entryType = 'üíÄ';
                    description = `${entry.mortality} mortality`;
                } else if (entry.behavior && entry.behavior !== 'Mortality event') {
                    entryType = 'üêü';
                    description = entry.behavior;
                }

                html += `
                    <div class="entry-item" data-entry-id="${entry.id}">
                        <span class="entry-icon">${entryType}</span>
                        <div class="entry-details">
                            <div class="entry-main">Tank ${tankNumber} - ${description}</div>
                            <div class="entry-time">${time}</div>
                        </div>
                        <div class="entry-actions">
                            <button class="entry-action-btn edit-btn" onclick="app.editFishEntry(${entry.id})" title="Edit">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="entry-action-btn delete-btn" onclick="app.deleteFishEntry(${entry.id})" title="Delete">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
            });

            entriesList.innerHTML = html;

        } catch (error) {
            console.error('Failed to load today\'s entries:', error);
            const entriesList = document.getElementById('today-entries-list');
            if (entriesList) {
                entriesList.innerHTML = '<p style="color: #ef4444; text-align: center; padding: 1rem;">Failed to load entries</p>';
            }
        }
    }

    async deleteFishEntry(entryId) {
        if (!confirm('Are you sure you want to delete this entry?')) {
            return;
        }

        try {
            const response = await fetch(`/api/data/fish-health/entry/${entryId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to delete entry');
            }

            this.showNotification('Entry deleted successfully', 'success');
            
            // Reload the entries list
            this.loadTodaysTankEntries();
            
            // Also refresh the dashboard if we're on it
            if (this.activeTab === 'dashboard') {
                this.updateDashboard();
            }
        } catch (error) {
            console.error('Failed to delete entry:', error);
            this.showNotification('Failed to delete entry', 'error');
        }
    }

    async editFishEntry(entryId) {
        try {
            // Fetch the current entry data
            const entries = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}`);
            const entry = entries.find(e => e.id === entryId);
            
            if (!entry) {
                this.showNotification('Entry not found', 'error');
                return;
            }

            // Create and show edit modal
            this.showEditFishEntryModal(entry);
        } catch (error) {
            console.error('Failed to load entry for editing:', error);
            this.showNotification('Failed to load entry', 'error');
        }
    }

    showEditFishEntryModal(entry) {
        // Create modal HTML
        const modalHtml = `
            <div id="edit-fish-entry-modal" class="modal show">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Edit Fish Entry</h3>
                        <button class="close-btn" onclick="app.closeEditFishEntryModal()">√ó</button>
                    </div>
                    <form id="edit-fish-entry-form" onsubmit="app.handleEditFishEntry(event, ${entry.id})">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Tank</label>
                                <input type="text" value="Tank ${entry.tank_number || entry.fish_tank_id}" disabled class="form-input">
                            </div>
                            <div class="form-group">
                                <label>Date/Time</label>
                                <input type="text" value="${new Date(entry.date).toLocaleString()}" disabled class="form-input">
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="edit-feed-amount">Feed Amount (g)</label>
                                <input type="number" id="edit-feed-amount" step="0.1" value="${entry.feed_consumption || ''}" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="edit-feed-type">Feed Type</label>
                                <select id="edit-feed-type" class="form-input">
                                    <option value="">Select feed type...</option>
                                    <option value="Powder" ${entry.feed_type === 'Powder' ? 'selected' : ''}>Powder</option>
                                    <option value="Crumble" ${entry.feed_type === 'Crumble' ? 'selected' : ''}>Crumble</option>
                                    <option value="2mm" ${entry.feed_type === '2mm' ? 'selected' : ''}>2mm</option>
                                    <option value="3mm" ${entry.feed_type === '3mm' ? 'selected' : ''}>3mm</option>
                                    <option value="4mm" ${entry.feed_type === '4mm' ? 'selected' : ''}>4mm</option>
                                    <option value="5mm" ${entry.feed_type === '5mm' ? 'selected' : ''}>5mm</option>
                                    <option value="6mm" ${entry.feed_type === '6mm' ? 'selected' : ''}>6mm</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="edit-mortality">Mortality</label>
                                <input type="number" id="edit-mortality" min="0" value="${entry.mortality || 0}" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="edit-behavior">Behavior</label>
                                <input type="text" id="edit-behavior" value="${entry.behavior || ''}" class="form-input">
                            </div>
                        </div>
                        
                        <div class="form-group full-width">
                            <label for="edit-notes">Notes</label>
                            <textarea id="edit-notes" rows="3" class="form-input">${entry.notes || ''}</textarea>
                        </div>
                        
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="app.closeEditFishEntryModal()">Cancel</button>
                            <button type="submit" class="btn btn-primary">Save Changes</button>
                        </div>
                    </form>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }

    closeEditFishEntryModal() {
        const modal = document.getElementById('edit-fish-entry-modal');
        if (modal) {
            modal.remove();
        }
    }

    async handleEditFishEntry(event, entryId) {
        event.preventDefault();
        
        try {
            const feedAmount = document.getElementById('edit-feed-amount').value;
            const feedType = document.getElementById('edit-feed-type').value;
            const mortality = document.getElementById('edit-mortality').value;
            const behavior = document.getElementById('edit-behavior').value;
            const notes = document.getElementById('edit-notes').value;

            const response = await fetch(`/api/data/fish-health/entry/${entryId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                },
                body: JSON.stringify({
                    feed_consumption: feedAmount ? parseFloat(feedAmount) : null,
                    feed_type: feedType || null,
                    mortality: mortality ? parseInt(mortality) : null,
                    behavior: behavior || null,
                    notes: notes || null
                })
            });

            if (!response.ok) {
                throw new Error('Failed to update entry');
            }

            this.showNotification('Entry updated successfully', 'success');
            this.closeEditFishEntryModal();
            
            // Reload the entries list
            this.loadTodaysTankEntries();
            
            // Also refresh the dashboard if we're on it
            if (this.activeTab === 'dashboard') {
                this.updateDashboard();
            }
        } catch (error) {
            console.error('Failed to update entry:', error);
            this.showNotification('Failed to update entry', 'error');
        }
    }

    getFishSvgIcon(fishType) {
        const fishIcons = {
            'tilapia': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" style="width: 24px; height: 24px;"><path d="m54.988 41.94366a70.19837 70.19837 0 0 1 -.81409-8.09222 70.18137 70.18137 0 0 1 .81415-8.09235.82984.82984 0 0 0 -1.13495-.88818l-8.77484 3.69257c-3.42117-3.79948-9.97561-6.22548-16.93307-6.22548-9.77 0-18.39685 4.90967-19.1452 10.6911h2.40961a.82254.82254 0 0 1 -.00006 1.64478h-2.40955c.74835 5.78137 9.37524 10.691 19.1452 10.691 6.95746 0 13.5119-2.426 16.933-6.23371l8.7749 3.70075a.82975.82975 0 0 0 1.1349-.88826zm-37.82168-10.14819a1.2337 1.2337 0 0 1 .00006-2.46716 1.2337 1.2337 0 0 1 -.00006 2.46716zm12.33588 6.34882a3.30529 3.30529 0 0 1 -3.28144 3.28949c-.36651.053-4.22149-.81372-4.67108-.88806a.82114.82114 0 0 1 -1.53784-.3866 27.35956 27.35956 0 0 0 .02454-12.418.82327.82327 0 1 1 1.612-.329 27.93369 27.93369 0 0 1 .65789 8.47882 46.883 46.883 0 0 1 4.334-1.89154c.0965-1.40936-.68182-1.23773-.329-2.17932a2.45171 2.45171 0 0 0 .04944-2.43421.82209.82209 0 0 1 -.04938-.85534 2.4518 2.4518 0 0 0 .04938-2.43421.82142.82142 0 0 1 1.34869-.9375 4.00913 4.00913 0 0 1 .2467 3.74182 4.12593 4.12593 0 0 1 0 3.28956 4.0171 4.0171 0 0 1 .31257 2.0971 2.45534 2.45534 0 0 1 1.23358 2.13825zm3.38824-4.30929a4.12652 4.12652 0 0 1 0 3.28955 4.13961 4.13961 0 0 1 -.19739 3.69251.82046.82046 0 1 1 -1.44744-.773 2.45173 2.45173 0 0 0 .04937-2.43427.822.822 0 0 1 -.04937-.85528 2.45173 2.45173 0 0 0 .04937-2.43427.822.822 0 0 1 -.04937-.85529 2.45168 2.45168 0 0 0 .04937-2.43426.82211.82211 0 0 1 -.04937-.85535 2.45158 2.45158 0 0 0 .04937-2.4342.82062.82062 0 0 1 .20557-1.14313c1.09613-.79718 2.34338 1.5622 1.38989 3.94745a4.1265 4.1265 0 0 1 0 3.28954zm4.73694 3.69251a.82058.82058 0 0 1 -1.44738-.77312 2.45169 2.45169 0 0 0 .04932-2.4342.82187.82187 0 0 1 -.04932-.85529 2.45175 2.45175 0 0 0 .04932-2.43426.82059.82059 0 0 1 .20563-1.14313c1.09332-.79889 2.3446 1.5647 1.38989 3.94745a4.13966 4.13966 0 0 1 -.19746 3.69251zm4.72052-1.64478a.82427.82427 0 0 1 -1.45563-.77307 2.45165 2.45165 0 0 0 .04932-2.4342.82809.82809 0 0 1 .20563-1.14313c1.12921-.84806 2.51056 1.82552 1.20068 4.35036zm8.02655 2.90308a21.66 21.66 0 0 1 -2.24512-.78949.82119.82119 0 0 1 .57563-1.53791l1.95727.73194a.82646.82646 0 0 1 -.28778 1.59542zm0-4.11194h-1.135a.82252.82252 0 0 1 0-1.64478h1.135a.82252.82252 0 0 1 0 1.64474zm.28778-4.4903a21.6413 21.6413 0 0 1 -2.24512.78955.82646.82646 0 0 1 -.28778-1.59546l1.95728-.73193a.82116.82116 0 0 1 .57562 1.5378z" fill="#0051b1"/><path d="m26.68964 35.67712-4.58075 2.12177c-.05756.38647-.11512.76483-.181 1.14313l3.95575.81408a1.65689 1.65689 0 0 0 1.97375-1.61181v-1.71875a.82791.82791 0 0 0 -1.16775-.74842z" fill="#0051b1"/><path d="m39.89722 23.037c-6.78473-5.46887-16.81794-6.35706-17.30316-6.3982a.80749.80749 0 0 0 -.87171.68256l-.72369 4.21887a30.11141 30.11141 0 0 1 7.14654-.847 29.66566 29.66566 0 0 1 11.75202 2.34377z" fill="#0051b1"/><path d="m32 2a30 30 0 1 0 30 30 30.03414 30.03414 0 0 0 -30-30zm0 58.29218a28.29221 28.29221 0 1 1 28.29224-28.29218 28.32516 28.32516 0 0 1 -28.29224 28.29218z" fill="#0051b1"/></svg>',
            'trout': '<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 100 100" viewBox="0 0 100 100" style="width: 24px; height: 24px;"><path d="m54.96191 59.66748c-1.06738-.04834-4.33496-1.97461-6.31445-3.32666-.18408-.12549-.40771-.19287-.62744-.17236-.104.00635-10.49658.65918-16.03027.25049-2.98706-.2193-5.9267-.75238-8.91229-1.34186 1.31549-1.10309 3.2995-3.04572 3.80927-5.08441.56158-2.24603-.85437-4.50629-1.78333-5.69061 4.54456-1.39368 9.70428-2.93896 16.91223-3.05206.26562-.00439.51855-.11426.70361-.30518 3.12451-3.23096 7.41846-6.32471 8.58447-5.59668.02063.01288.04089.02795.06146.04108-1.77484 1.16016-3.79089 3.77069-4.53265 4.77753-.32727-.04553-.52832-.07349-.52832-.07349l-.27539 1.98047s9.58447 1.3335 12.00098 1.66699c.88135.12158 2.35498.24219 3.91504.37012 2.55859.20996 6.06348.49707 6.95947.82764.11132.041.22851.06151.3457.06151.11914 0 .23779-.021.35107-.06348 1.25146-.46924 3.50293-1.25488 4.21729-1.36475.5459-.08398.92041-.59424.83643-1.14014-.08398-.54639-.60156-.91797-1.14014-.83643-.98291.15088-3.39209 1.01709-4.29688 1.3501-1.25488-.32861-3.77881-.55469-7.10986-.82764-1.53174-.12549-2.97852-.24414-3.80469-.3584-.94812-.13086-3.00031-.41559-5.14307-.7132.87207-.92236 1.70776-1.66272 2.14917-1.89429.43439.54028.69775.91125.70532.92194.31641.45215.94141.56104 1.39258.24512.45215-.31689.56201-.93994.24561-1.39209-.1001-.14307-2.48242-3.52051-5.28955-5.2749-2.95898-1.85107-8.68555 3.47217-10.79248 5.60645-7.41016.17139-12.66748 1.78516-17.31641 3.21191-1.92383.59033-3.74072 1.14795-5.55615 1.55371-6.47803 1.44922-10.71924 4.71582-10.89697 4.854-.32764.25537-.46289.68701-.34033 1.08398.12305.39697.47852.67676.89307.70264.81885.05127 4.4209 1.26318 6.71729 2.10742.11377.04199.23047.06201.34521.06201.40723 0 .79004-.25098.93848-.65527.19043-.51855-.0752-1.09326-.59326-1.28369-.6333-.23291-2.94824-1.07471-4.86865-1.65479.78503-.46039 1.80908-1.00098 3.0116-1.53058.16705.64612.74878 1.12561 1.44714 1.12561.82843 0 1.5-.67157 1.5-1.5 0-.24835-.0661-.47913-.17297-.68542.77515-.25067 1.59387-.48102 2.45593-.67377 1.29089-.28894 2.57617-.65668 3.87842-1.04553.34869.37347 2.40753 2.68005 1.93311 4.57678-.4707 1.88428-3.18262 4.1333-4.18799 4.84131-.10693.0752-.19128.16974-.25867.27301-.38226-.06201-.75275-.13361-1.13879-.19391-2.27246-.35547-4.62207-.72266-6.64795-1.52393-.50098-.19775-.92773-.31982-1.30469-.42725-.65039-.18555-1.12012-.31982-1.72217-.77441-.44043-.33398-1.06885-.24512-1.40039.19531-.33301.44043-.24561 1.06738.19531 1.40039.89941.67969 1.65088.89404 2.37793 1.10205.33691.0957.69873.19824 1.11865.36426 2.23291.88232 4.69385 1.26758 7.07422 1.63965 1.00391.15674 1.99902.31201 2.96045.50342 3.28271.65479 6.50439 1.26221 9.83105 1.50635 5.16113.38281 14.07861-.11572 15.96191-.22803 1.30713.87598 5.21729 3.396 7.06592 3.47998.01562.00049.03076.00098.04639.00098.53125 0 .97363-.41846.99805-.95459.02489-.55173-.40187-1.01951-.95363-1.04441zm-4.18762-18.95288c-.58667-.08154-1.14447-.15906-1.66199-.23096 1.43713-1.80725 3.13007-3.53546 3.82471-3.66772.05853-.01117.10486-.04431.15869-.06476.31415.29108.61145.5896.89056.88403-.89031.57502-1.96044 1.60053-3.21197 3.07941z" fill="#0051b1"/></svg>',
            'catfish': '<svg xmlns="http://www.w3.org/2000/svg" id="Layer_2" viewBox="0 0 64 64" style="width: 24px; height: 24px;"><path d="m47.1155295 24.1677246c2.6532764.529534 5.044589 1.4316276 7.1071725 2.6807979.5403006.3273275 1.089329.7242869 1.6183534 1.1759708-.2118264-1.2184634-.5895462-2.4652766-1.2422262-3.1804533-1.813361-1.6640314-26.3839445-6.5062864-29.4265992-6.237697-1.2683462.1151189-1.9344047 1.5526713-2.2573363 2.6267743 5.9503139.0545333 13.8013314.8573712 24.2006359 2.9346073z" fill="#0051b1"/><path d="m33.9545424 31.9742526c-.1123298.5250399-.2545529 1.2942294-.4221916 2.4674375-.1074574.7522017.5920691 1.3611269 1.0176847 1.6561079 1.1030185.7658972 2.3482599.8817827 2.7823035.7711648.304726-1.1298828-.3281664-3.1553755-1.011627-4.604865-.7496996-.2088571-1.539169-.3019605-2.3661695-.2898452z" fill="#0051b1"/><path d="m11.576416 31.2006226c6.5237918 3.6058327 12.8864102 2.7625121 12.8140516-4.8353103 3.0488744-3.5109919 2.2919307 4.4495968-.8329725 7.5376418 3.2568571 2.1349583 7.913564-.7538779 11.4386558-1.2291121 4.4503433 1.2522076 10.0800679-.8130041 13.7398483 1.9389162 4.9116326-7.9367702-16.5277001-3.027739-18.7003735-2.9212553-4.1082576-1.817751 2.8982044-2.0975484 3.7204673-3.2954151 1.0409823-1.3424914-2.6439031-.9227009-3.635791-.5450525-5.5056777-2.1260204 7.9094262-4.4328407 5.7107526 1.0673607 4.588715-1.3431334 11.9827014-1.5430712 15.2460938 1.5915527 5.0143858-12.7196708 3.4850637 13.7859204-16.7236328 11.6218872 1.3293801 1.1420344 1.6478069 2.8973085 1.078125 4.5117188 7.3209905-2.4553212 16.855255-3.2807426 18.803833-7.5292358.0755414.3492258-15.3958173 8.6502329-12.5546226 3.3750429 21.8262046-4.9067795 19.5890925-15.0059387 5.6645264-18.710719-30.0851236-6.0076466-36.8751626-.6155568-38.2037759 1.0587596 7.3892591 6.4491261-6.2090201 1.3941353 2.4348145 6.3632202zm3.8191528-5.0973511c-1.5417271.0226149-1.5417777-2.3995156.0001074-2.3767025 1.5416197-.0226214 1.5416703 2.3995092-.0001074 2.3767025z" fill="#0051b1"/><path d="m45.4893617 33.8510638c-.5898836-.0692623-2.2686868-.3364663-3.7358922-.2695127-1.6119347.0724368-3.2369015.2002914-5.2553191.1914894.0008658.1201989.0113598.523322.0194404.6228865.5760311.1038934 1.5064541.2308742 2.240634.3313045 3.0436433.4171608 5.9693965.8265296 7.8585245 1.8886952.6289879-.4757451 1.2506166-.974722 1.8601245-1.5071756-1.0328734-.6235046-2.14713-1.1599985-2.987512-1.2576871z" fill="#0051b1"/><path d="m14.6230469 39.2182617c-.1254883 0-.2529297-.0239258-.3759766-.0742188-4.4770508-1.8198242-4.7314453-8.3725586-4.7402344-8.6503906-.0170898-.5517578.4155273-1.012207.9672852-1.0297852.5405273-.0214844 1.0126953.4145508 1.0317383.9663086.0019531.0551758.2246094 5.5322266 3.4941406 6.8613281.5117188.2080078.7578125.7910156.5498047 1.3027344-.1577148.3881836-.5317383.6240234-.9267578.6240234z" fill="#0051b1"/><path d="m22.315918 40.6220703c-.0795898 0-.159668-.0092773-.2402344-.0288086-.5361328-.1323242-.8637695-.6743164-.7319336-1.2104492.3754883-1.5244141-2.7802734-5.3032227-3.8393555-5.8193359-.7143555-.3481445-1.1171875-1.0053711-1.340332-1.7016602-.3242188.137207-.7104492.0991211-1.0078125-.1328125-.4350586-.340332-.5117188-.96875-.1713867-1.4038086l1.1489258-1.4682617c.2724609-.3486328.7416992-.4760742 1.1538086-.3144531.4121094.1625977.668457.5761719.6298828 1.0170898-.0722656.8793945.1142578 2.0361328.4628906 2.2060547 1.5092773.7353516 5.5957031 5.293457 4.9057617 8.0957031-.1123047.4560547-.5209961.7607422-.9702148.7607422z" fill="#0051b1"/></svg>',
            'goldfish': '<svg xmlns="http://www.w3.org/2000/svg" id="Capa_1" enable-background="new 0 0 512.248 512.248" height="512" viewBox="0 0 512.248 512.248" width="512" style="width: 24px; height: 24px;"><path d="m460.489 188.173c-14.643-10.65-29.983-19.494-45.785-26.476-16.458-66.72-63.517-106.681-65.925-108.688l-8.078-6.731-97.135 56.663c-25.681 14.98-38.387 44.238-33.495 72.243-9.378 5.949-16.252 11.452-20.536 15.201-23.503-2.036-44.317-16.691-54.014-38.509l-3.416-7.687c-13.378-30.101-43.307-49.551-76.247-49.551h-55.858v83.162c0 35.286 12.647 69.474 35.611 96.266 18.307 21.358 28.389 48.612 28.389 76.742v115.162h15c55.324 0 100.333-45.009 100.333-100.333v-47.773c0-15.186 6.077-29.6 16.612-40.165l15.52 10.548v31.121c0 21.452 8.793 40.883 22.956 54.897-16.018 16.803-25.422 39.402-25.422 63.574v28.132h47.001c46.481 0 86.374-28.722 102.882-69.348 34.123-.298 67.62-11.961 94.462-32.932 27.385-21.394 46.774-51.663 54.598-85.231 2.69-11.543 4.055-28.46 4.057-40.453-2.499-3.08-24.209-29.979-51.51-49.834zm-280.322 63.305c-19.439 16.413-30.833 40.678-30.833 66.386v47.773c0 33.636-23.733 61.833-55.334 68.724v-83.553c0-35.286-12.646-69.474-35.611-96.266-18.307-21.358-28.389-48.613-28.389-76.742v-53.163h25.857c21.097 0 40.265 12.457 48.833 31.735l3.416 7.687c13.214 29.731 40.571 50.363 72.061 55.39zm78.514-122.625 78.321-45.687c5.943 6.112 14.676 16.003 23.312 29.093 7.979 12.094 14.361 24.508 19.171 37.178-17.471-4.496-35.281-6.8-53.152-6.8-35.531 0-64.7 7.748-87.165 17.302 1.029-12.529 7.959-24.346 19.513-31.086zm-2.681 307.117h-16.974c.522-17.505 8.352-33.642 21.119-44.839 8.85 3.539 18.492 5.506 28.59 5.506h36.69c-14.184 23.545-39.992 39.333-69.425 39.333zm222.725-164.319c-6.259 26.855-21.778 51.094-43.701 68.278-35.45-.878-64.024-29.967-64.024-65.625h-30c0 38.056 22.338 70.99 54.589 86.387-12.25 3.89-25.096 5.946-38.049 5.946h-68.805c-26.065 0-47.271-21.205-47.271-47.27v-47.005l-31.101-21.137-.17-39.025c4.878-4.152 13.92-11.102 26.818-17.975 26.879-14.325 56.931-21.588 89.32-21.588 40.684 0 79.615 13.196 115.715 39.222 20.343 14.666 34.059 29.539 39.846 36.32-.321 7.944-1.384 15.818-3.167 23.472z" fill="#0051b1"/><path d="m512 237.97v.036c.32.396.341.419 0-.036z" fill="#0051b1"/><path d="m405.333 243.97h30v30h-30z" fill="#0051b1"/></svg>',
            'carp': '<svg xmlns="http://www.w3.org/2000/svg" height="300" viewBox="-22 0 464 464" width="300" style="width: 24px; height: 24px;"><path d="m0 120c0 22.585938 20.03125 23.953125 24.046875 24l9.089844.105469-1.214844 9.015625c-1.058594 7.527344-1.738281 29.4375 7.621094 40.191406 3.914062 4.496094 9.296875 6.6875 16.457031 6.6875 17.167969 0 22.390625-10.121094 29.503906-26.632812 4.25-9.847657 9.007813-20.792969 18.742188-26.527344-.054688-3.425782-.230469-6.726563-.230469-10.214844-18.503906 2.773438-35.382813 13.902344-35.574219 14.03125l-8.875-13.3125c.960938-.640625 21.738282-14.28125 45.035156-16.878906.039063-.585938.023438-1.234375.070313-1.800782-9.609375-1.734374-30.175781-4.375-46.128906.929688l-5.0625-15.167969c18.847656-6.296875 41.457031-3.722656 52.96875-1.707031.933593-6.34375 2.101562-12.292969 3.4375-17.886719-7.039063-2.097656-19.6875-4.824219-37.871094-4.824219-30.078125-.007812-72.015625 15.214844-72.015625 39.992188zm0 0" fill="#0051b1"/><path d="m120 312c0 17.648438 14.351562 32 32 32 2.304688 0 4.59375-.320312 6.847656-.855469-11.785156-15.609375-21.664062-33.433593-29.65625-53.425781-5.792968 5.898438-9.191406 13.855469-9.191406 22.28125zm0 0" fill="#0051b1"/><path d="m330.527344 104.414062-5.0625 15.171876c-15.953125-5.304688-36.511719-2.664063-46.128906-.929688.039062.574219.03125 1.222656.070312 1.808594 23.296875 2.597656 44.066406 16.238281 45.035156 16.878906l-8.867187 13.320312c-.191407-.128906-17.140625-11.238281-35.574219-14.03125 0 3.542969-.03125 6.984376-.089844 10.3125 9.632813 5.765626 14.378906 16.628907 18.59375 26.421876 7.113282 16.511718 12.335938 26.632812 29.503906 26.632812 7.167969 0 12.558594-2.191406 16.480469-6.710938 9.398438-10.832031 8.671875-32.664062 7.601563-40.160156l-1.304688-9.136718h9.214844c3.96875-.046876 24-1.417969 24-24 0-24.785157-41.9375-40-72-40-18.175781 0-30.832031 2.726562-37.871094 4.824218 1.335938 5.589844 2.496094 11.542969 3.4375 17.886719 11.511719-2 34.128906-4.574219 52.960938 1.710937zm0 0" fill="#0051b1"/><path d="m240 312c0-29.183594 4.910156-47.511719 10.113281-66.921875 2.949219-11.03125 6.078125-22.765625 8.621094-37.605469-15.132813-2.535156-26.734375-15.625-26.734375-31.472656h16c0 7.800781 5.625 14.296875 13.015625 15.695312 1.808594-15.007812 2.984375-32.992187 2.984375-55.695312 0-.070312-.007812-.128906-.007812-.199219-6.703126 5.070313-14.960938 8.199219-23.992188 8.199219-22.054688 0-40-17.945312-40-40h16c0 13.230469 10.769531 24 24 24 10.449219 0 19.265625-6.753906 22.550781-16.089844-3.71875-33.207031-14.382812-55.628906-22-71.324218-1.519531-3.128907-2.839843-5.921876-4.03125-8.585938h-20.519531v-16h16c0-8.824219-7.175781-16-16-16h-48c-8.824219 0-16 7.175781-16 16h16v16h-20.519531c-1.199219 2.664062-2.519531 5.464844-4.03125 8.585938-7.617188 15.6875-18.28125 38.117187-22 71.324218 3.285156 9.335938 12.101562 16.089844 22.550781 16.089844 13.230469 0 24-10.769531 24-24h16c0 22.054688-17.945312 40-40 40-9.039062 0-17.289062-3.128906-23.992188-8.199219 0 .070313-.007812.128907-.007812.199219 0 19.703125.953125 38.207031 2.6875 55.726562 7.535156-1.277343 13.3125-7.824218 13.3125-15.726562h16c0 16.113281-12 29.34375-27.511719 31.542969 13.464844 100.175781 57.671875 162.136719 134.070313 188.074219-7.3125-19.921876-18.558594-55.210938-18.558594-83.617188zm-16-256h16v16h-16zm-64 16h-16v-16h16zm16 88c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32s-32-14.351562-32-32zm16 136c-17.648438 0-32-14.351562-32-32h16c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32zm1.015625-72h-2.03125c-3.550781 13.792969-16.105469 24-30.984375 24-17.648438 0-32-14.351562-32-32h16c0 8.824219 7.175781 16 16 16s16-7.175781 16-16v-8h32v8c0 8.824219 7.175781 16 16 16s16-7.175781 16-16h16c0 17.648438-14.351562 32-32 32-14.878906 0-27.433594-10.207031-30.984375-24zm0 0" fill="#0051b1"/><path d="m256 312c0 1.136719.089844 2.335938.128906 3.503906 9.640625-5.59375 15.871094-15.855468 15.871094-27.503906 0-9.007812-3.910156-17.457031-10.390625-23.414062-3.25 13.605468-5.609375 27.726562-5.609375 47.414062zm0 0" fill="#0051b1"/><path d="m286.425781 425.734375 16.773438-1.695313c.746093-.070312 70.792969-7.589843 116.617187-47.597656-9.089844-6.410156-27.222656-16.441406-51.816406-16.441406-13.183594 0-23.59375 3.902344-34.609375 8.039062-17.039063 6.394532-36.054687 13.503907-65.695313 4.703126 1.625 5.128906 3.234376 9.832031 4.730469 14.042968 9.367188 3.285156 30.894531 8.621094 52-1.9375l7.160157 14.3125c-11.96875 5.984375-23.867188 7.976563-34.410157 7.976563-6.527343 0-12.449219-.800781-17.640625-1.855469l6.265625 14.621094-15.832031-4.167969c-10.039062-2.636719-19.472656-6.015625-28.609375-9.734375 1.976563 8.726562 6.863281 19.199219 19.089844 27.34375l-8.875 13.3125c-16.679688-11.121094-25.765625-27.449219-27.253907-48.488281-8.433593-4.351563-16.488281-9.152344-24.039062-14.542969 1.222656 15.789062 5.878906 40.757812 22.382812 58.535156 13.464844 14.496094 32.761719 21.839844 57.351563 21.839844 21.894531 0 38.457031-5.382812 49.550781-10.792969-10.550781-2.429687-22.65625-7-31.207031-15.550781zm0 0" fill="#0051b1"/></svg>'
        };
        
        return fishIcons[fishType?.toLowerCase()] || fishIcons['tilapia']; // Default to tilapia if type not found
    }

    async updateCurrentFishCount() {
        const tankSelect = document.getElementById('fish-tank');
        const fishCountInput = document.getElementById('fish-count');
        
        if (!tankSelect || !fishCountInput || !this.activeSystemId) return;
        
        const selectedTankId = parseInt(tankSelect.value);
        if (!selectedTankId) {
            fishCountInput.value = '';
            return;
        }

        try {
            // Get fish inventory data from the fish-inventory API
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`);
            const inventoryTanks = fishInventoryData.tanks || [];
            
            // Find the tank inventory data for the selected tank
            const tankInventory = inventoryTanks.find(tank => tank.fish_tank_id === selectedTankId);
            const currentCount = tankInventory ? parseInt(tankInventory.current_count) || 0 : 0;
            
            fishCountInput.value = currentCount;

        } catch (error) {
            console.error('Error fetching current fish count:', error);
            fishCountInput.value = 0;
        }
    }

    generateTankOptions() {
        const systemData = this.getActiveSystem();
        
        if (!systemData?.fish_tanks) {
            // Generate options based on system configuration
            const tankCount = systemData?.fish_tank_count || 1;
            const tankVolume = systemData?.total_fish_volume || 1000;
            const volumePerTank = Math.floor(tankVolume / tankCount);
            
            let options = '';
            for (let i = 1; i <= tankCount; i++) {
                options += `<option value="${i}">Tank ${i} (${(volumePerTank / 1000).toFixed(1)}m¬≥)</option>`;
            }
            return options || '<option value="1">Tank 1 (1.0m¬≥)</option>';
        }

        return systemData.fish_tanks.map(tank => 
            `<option value="${tank.id}">Tank ${tank.tank_number} (${(tank.volume_liters / 1000).toFixed(1)}m¬≥)</option>`
        ).join('');
    }

    async loadFishHealthHistory() {
        try {
            const response = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}`);
            const entries = response || [];
            
            const container = document.getElementById('fish-health-history');
            if (!container) return;

            if (entries.length === 0) {
                container.innerHTML = '<p class="no-data">No fish health data recorded yet.</p>';
                return;
            }

            const html = entries.slice(0, 10).map(entry => `
                <div class="data-entry-item">
                    <div class="entry-header">
                        <span class="entry-date">${this.formatDateDDMMYYYY(entry.entry_date)}</span>
                        <span class="entry-tank">Tank ${entry.tank_number || 'N/A'}</span>
                    </div>
                    <div class="entry-details">
                        <div class="detail-row">
                            <span><strong>Count:</strong> ${entry.count || 'N/A'}</span>
                            <span><strong>Mortality:</strong> ${entry.mortality || '0'}</span>
                        </div>
                        <div class="detail-row">
                            <span><strong>Avg Weight:</strong> ${entry.average_weight || 'N/A'}g</span>
                            <span><strong>Behavior:</strong> ${entry.behavior || 'Normal'}</span>
                        </div>
                        ${entry.notes ? `<div class="entry-notes">${entry.notes}</div>` : ''}
                    </div>
                </div>
            `).join('');

            container.innerHTML = html;
        } catch (error) {
            console.error('Failed to load fish health history:', error);
            const container = document.getElementById('fish-health-history');
            if (container) {
                container.innerHTML = '<p class="no-data">Fish health history will show here once you start recording data. API endpoint not yet available.</p>';
            }
        }
    }

    loadTankInformation() {

        const container = document.querySelector('#tank-information-content .tank-info-grid');
        if (!container) return;

        // Generate tank cards with detailed information
        this.displayTankCards(container);
    }

    // Fish Management Modal Functions
    showAddFishModal(preselectedTank = null) {
        // Force close all Quick Actions menus IMMEDIATELY
        this.hideAllQuickActions();
        
        this.populateTankSelects();
        document.getElementById('add-fish-date').value = new Date().toISOString().split('T')[0];
        
        // Setup tank selection event handler for capacity display
        const tankSelect = document.getElementById('add-fish-tank');
        if (tankSelect) {
            tankSelect.onchange = () => this.updateTankCapacityDisplay();
        }
        
        // Pre-select tank if specified
        if (preselectedTank) {
            if (tankSelect) {
                tankSelect.value = preselectedTank;
                // Trigger capacity display update
                this.updateTankCapacityDisplay();
            }
        }
        
        document.getElementById('add-fish-modal').classList.add('show');
        
        // Setup form submission
        const form = document.getElementById('add-fish-form');
        form.onsubmit = (e) => this.handleAddFish(e);
    }

    async updateTankCapacityDisplay() {
        const tankSelect = document.getElementById('add-fish-tank');
        const capacityInfo = document.getElementById('tank-capacity-info');
        const currentFishElement = document.getElementById('current-fish-count');
        const maxCapacityElement = document.getElementById('max-fish-capacity');
        
        if (!tankSelect || !capacityInfo || !currentFishElement || !maxCapacityElement) {
            return;
        }
        
        const selectedTankNumber = tankSelect.value;
        if (!selectedTankNumber) {
            capacityInfo.style.display = 'none';
            return;
        }
        
        try {
            // Get system configuration and fish inventory data
            const systemData = this.getActiveSystem();
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`);
            
            if (!systemData || !fishInventoryData?.tanks) {
                capacityInfo.style.display = 'none';
                return;
            }
            
            // Find the selected tank in system configuration
            const systemTank = systemData.fish_tanks?.find(tank => tank.tank_number == selectedTankNumber);
            // Find the selected tank in inventory data
            const inventoryTank = fishInventoryData.tanks.find(tank => tank.tank_number == selectedTankNumber);
            
            if (!systemTank) {
                capacityInfo.style.display = 'none';
                return;
            }
            
            // Calculate current fish count
            const currentCount = inventoryTank?.current_count || 0;
            
            // Calculate maximum capacity using formula: Max Fish = (Stocking Density √ó Tank Volume) √∑ Harvest Weight
            const tankVolumeM3 = systemTank.volume_liters / 1000; // Convert liters to m¬≥
            
            // Use tank-specific stocking density if available, otherwise fall back to global fish type density
            const stockingDensity = systemTank.max_stocking_density || this.getRecommendedStockingDensity(systemData.fish_type || 'tilapia'); // kg/m¬≥
            const harvestWeight = this.getFinalHarvestWeight(systemData.fish_type || 'tilapia'); // grams
            const harvestWeightKg = harvestWeight / 1000; // Convert to kg
            
            const maxCapacity = Math.floor((stockingDensity * tankVolumeM3) / harvestWeightKg);
            
            // Update display
            currentFishElement.textContent = `${currentCount} fish`;
            maxCapacityElement.textContent = `${maxCapacity} fish`;
            
            // Show the capacity info
            capacityInfo.style.display = 'block';
            
        } catch (error) {
            console.error('Error updating tank capacity display:', error);
            capacityInfo.style.display = 'none';
        }
    }

    showMortalityModal(preselectedTank = null) {
        // Force close all Quick Actions menus IMMEDIATELY
        this.hideAllQuickActions();
        
        this.populateTankSelects();
        document.getElementById('mortality-date').value = new Date().toISOString().split('T')[0];
        
        // Pre-select tank if specified
        if (preselectedTank) {
            const tankSelect = document.getElementById('mortality-tank');
            if (tankSelect) {
                tankSelect.value = preselectedTank;
            }
        }
        
        document.getElementById('mortality-modal').classList.add('show');
        
        // Setup form submission
        const form = document.getElementById('mortality-form');
        form.onsubmit = (e) => this.handleMortality(e);
    }

    async showFeedingModal(preselectedTank = null) {
        // Force close all Quick Actions menus IMMEDIATELY
        this.hideAllQuickActions();
        
        this.populateTankSelects();
        document.getElementById('feeding-date').value = new Date().toISOString().split('T')[0];
        document.getElementById('feeding-time').value = new Date().toTimeString().slice(0, 5);
        
        // Pre-select tank if specified
        if (preselectedTank) {
            const tankSelect = document.getElementById('feeding-tank');
            if (tankSelect) {
                tankSelect.value = preselectedTank;
            }
        }
        
        // Auto-populate feed amount and type from most recent entry
        await this.populateRecentFeedingData(preselectedTank);
        
        document.getElementById('feeding-modal').classList.add('show');
        
        // Setup form submission
        const form = document.getElementById('feeding-form');
        form.onsubmit = (e) => this.handleFeeding(e);
    }

    async populateRecentFeedingData(targetTankId = null) {
        try {
            if (!this.activeSystemId) {
                return;
            }
            
            // Fetch recent fish health data for the system
            const response = await fetch(`/api/data/fish-health/${this.activeSystemId}`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
            });
            
            if (!response.ok) {
                return;
            }
            
            const fishHealthData = await response.json();
            let mostRecentFeeding = null;
            
            if (targetTankId) {
                // Find most recent feeding entry for specific tank (using tank_number, not fish_tank_id)
                const tankEntries = fishHealthData.filter(entry => entry.tank_number == targetTankId);
                
                mostRecentFeeding = fishHealthData.find(entry => 
                    entry.tank_number == targetTankId && 
                    entry.feed_consumption > 0 &&
                    entry.feed_type
                );
            } else {
                // Find most recent feeding entry for any tank
                mostRecentFeeding = fishHealthData.find(entry => 
                    entry.feed_consumption > 0 &&
                    entry.feed_type
                );
            }
            
            if (mostRecentFeeding) {
                
                // Wait a bit to ensure DOM is ready
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Auto-populate feed amount
                const feedAmountInput = document.getElementById('feeding-amount');
                if (feedAmountInput && mostRecentFeeding.feed_consumption) {
                    feedAmountInput.value = mostRecentFeeding.feed_consumption;
                }
                
                // Pre-select feed type
                const feedTypeSelect = document.getElementById('feeding-type');
                if (feedTypeSelect && mostRecentFeeding.feed_type) {
                    feedTypeSelect.value = mostRecentFeeding.feed_type;
                }
            }
        } catch (error) {
            console.error('Error populating recent feeding data:', error);
        }
    }

    async populateDataCaptureFeedingData() {
        try {
            if (!this.activeSystemId) return;
            
            // Fetch recent fish health data for the system
            const response = await fetch(`/api/data/fish-health/${this.activeSystemId}`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
            });
            
            if (!response.ok) return;
            
            const fishHealthData = await response.json();
            
            // Auto-populate feeding data for each tank
            const tankRows = document.querySelectorAll('[data-tank-id]');
            tankRows.forEach(row => {
                const tankId = parseInt(row.getAttribute('data-tank-id'));
                
                // Find most recent feeding entry for this specific tank
                const tankFeeding = fishHealthData.find(entry => 
                    entry.fish_tank_id === tankId && 
                    entry.feed_consumption > 0 &&
                    entry.feed_type
                );
                
                if (tankFeeding) {
                    // Auto-populate feed amount
                    const feedAmountInput = document.getElementById(`feed-amount-${tankId}`);
                    if (feedAmountInput && tankFeeding.feed_consumption) {
                        feedAmountInput.value = tankFeeding.feed_consumption;
                    }
                    
                    // Pre-select feed type
                    const feedTypeSelect = document.getElementById(`feed-type-${tankId}`);
                    if (feedTypeSelect && tankFeeding.feed_type) {
                        feedTypeSelect.value = tankFeeding.feed_type;
                    }
                }
            });
        } catch (error) {
            console.error('Error populating data capture feeding data:', error);
        }
    }

    showFishSizeModal(preselectedTank = null) {
        // Force close all Quick Actions menus IMMEDIATELY
        this.hideAllQuickActions();
        
        this.populateTankSelects();
        document.getElementById('fish-size-date').value = new Date().toISOString().split('T')[0];
        
        // Pre-select tank if specified
        if (preselectedTank) {
            const tankSelect = document.getElementById('fish-size-tank');
            if (tankSelect) {
                tankSelect.value = preselectedTank;
            }
        }
        
        document.getElementById('fish-size-modal').classList.add('show');
        
        // Setup form submission
        const form = document.getElementById('fish-size-form');
        form.onsubmit = (e) => this.handleFishSize(e);
    }

    populateTankSelects() {
        const systemData = this.getActiveSystem();
        if (!systemData || !systemData.fish_tanks) return;
        
        const tankSelects = ['add-fish-tank', 'mortality-tank', 'fish-size-tank'];
        tankSelects.forEach(selectId => {
            const select = document.getElementById(selectId);
            if (select) {
                select.innerHTML = systemData.fish_tanks.map(tank => 
                    `<option value="${tank.tank_number}">Tank ${tank.tank_number} (${(tank.volume_liters/1000).toFixed(1)}m¬≥)</option>`
                ).join('');
            }
        });
        
        // Special handling for feeding select (includes "All Tanks" option)
        const feedingSelect = document.getElementById('feeding-tank');
        if (feedingSelect) {
            feedingSelect.innerHTML = '<option value="all">All Tanks</option>' + 
                systemData.fish_tanks.map(tank => 
                    `<option value="${tank.tank_number}">Tank ${tank.tank_number} (${(tank.volume_liters/1000).toFixed(1)}m¬≥)</option>`
                ).join('');
        }
    }

    async handleAddFish(e) {
        e.preventDefault();
        
        const formData = {
            system_id: this.activeSystemId,
            fish_tank_id: parseInt(document.getElementById('add-fish-tank').value),
            count: parseInt(document.getElementById('add-fish-count').value),
            average_weight: parseFloat(document.getElementById('add-fish-avg-weight').value) || null,
            notes: document.getElementById('add-fish-notes').value || ''
        };
        
        try {
            await this.makeApiCall('/fish-inventory/add-fish', {
                method: 'POST',
                body: JSON.stringify(formData)
            });
            
            this.showNotification('‚úÖ Fish added successfully!', 'success');
            this.closeModal('add-fish-modal');
            
            // Reload tank display with new inventory data
            this.loadTankInformation();
            
            // Also refresh fish overview cards to show updated counts
            await this.loadFishOverview();
            
        } catch (error) {
            console.error('Error adding fish:', error);
            this.showNotification('‚ùå Failed to add fish', 'error');
        }
    }

    async handleMortality(e) {
        e.preventDefault();
        
        const formData = {
            system_id: this.activeSystemId,
            fish_tank_id: parseInt(document.getElementById('mortality-tank').value),
            count: parseInt(document.getElementById('mortality-count').value),
            cause: document.getElementById('mortality-cause').value || 'Unknown',
            notes: document.getElementById('mortality-notes').value || ''
        };
        
        try {
            await this.makeApiCall('/fish-inventory/mortality', {
                method: 'POST',
                body: JSON.stringify(formData)
            });
            
            this.showNotification(`‚ö†Ô∏è Mortality recorded: ${formData.count} fish removed`, 'warning');
            this.closeModal('mortality-modal');
            
            // Reload tank display with new inventory data
            this.loadTankInformation();
            
            // Also refresh fish overview cards to show updated counts
            await this.loadFishOverview();
            
        } catch (error) {
            console.error('Error recording mortality:', error);
            this.showNotification(`‚ùå Failed to record mortality: ${error.message || 'Unknown error'}`, 'error');
        }
    }

    async handleFishSize(e) {
        e.preventDefault();
        
        const formData = {
            system_id: this.activeSystemId,
            fish_tank_id: parseInt(document.getElementById('fish-size-tank').value),
            average_weight: parseFloat(document.getElementById('fish-size-weight').value),
            notes: document.getElementById('fish-size-notes').value || ''
        };
        
        try {
            await this.makeApiCall('/fish-inventory/update-weight', {
                method: 'POST',
                body: JSON.stringify(formData)
            });
            
            this.showNotification(`üìè Fish size recorded: ${formData.average_weight}g average weight`, 'success');
            this.closeModal('fish-size-modal');
            
            // Reload tank display with new weight data
            this.loadTankInformation();
            
            // Also refresh fish overview cards to show updated data
            await this.loadFishOverview();
            
            // Update all dashboard calculations (density, feed recommendations)
            await this.loadDataRecords();
            await this.updateDashboardFromData();
            
            // Update fish tank summary to recalculate dependent values
            if (typeof this.updateFishTankSummary === 'function') {
                await this.updateFishTankSummary();
            }
            
        } catch (error) {
            console.error('Error recording fish size:', error);
            this.showNotification(`‚ùå Failed to record fish size: ${error.message || 'Unknown error'}`, 'error');
        }
    }

    async handleFeeding(e) {
        e.preventDefault();
        
        const tankValue = document.getElementById('feeding-tank').value;
        const feedAmount = parseFloat(document.getElementById('feeding-amount').value);
        const feedType = document.getElementById('feeding-type').value;
        const feedingDate = document.getElementById('feeding-date').value;
        const feedingTime = document.getElementById('feeding-time').value;
        
        try {
            if (tankValue === 'all') {
                // Record feeding for all tanks
                const systemData = this.getActiveSystem();
                const amountPerTank = feedAmount / systemData.fish_tanks.length;
                
                for (const tank of systemData.fish_tanks) {
                    // Get latest fish data for this tank
                    const currentData = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}&limit=50`);
                    const tankData = currentData.find(entry => entry.fish_tank_id === tank.tank_number) || {};
                    
                    const formData = {
                        system_id: this.activeSystemId,
                        fish_tank_id: tank.tank_number,
                        date: feedingDate,
                        count: tankData.count || 0,
                        average_weight: tankData.average_weight || 0,
                        feed_consumption: amountPerTank,
                        feed_type: feedType,
                        behavior: 'feeding',
                        notes: `Time: ${feedingTime}. ${document.getElementById('feeding-notes').value || ''}`
                    };
                    
                    await this.makeApiCall('/data/entries/fish-health', {
                        method: 'POST',
                        body: JSON.stringify(formData)
                    });
                }
            } else {
                // Record feeding for specific tank
                const tankNumber = parseInt(tankValue);
                const currentData = await this.makeApiCall(`/data/entries/fish-health?system_id=${this.activeSystemId}&limit=50`);
                const tankData = currentData.find(entry => entry.fish_tank_id === tankNumber) || {};
                
                const formData = {
                    system_id: this.activeSystemId,
                    fish_tank_id: tankNumber,
                    date: feedingDate,
                    count: tankData.count || 0,
                    average_weight: tankData.average_weight || 0,
                    feed_consumption: feedAmount,
                    feed_type: feedType,
                    behavior: 'feeding',
                    notes: `Time: ${feedingTime}. ${document.getElementById('feeding-notes').value || ''}`
                };
                
                await this.makeApiCall('/data/entries/fish-health', {
                    method: 'POST',
                    body: JSON.stringify(formData)
                });
            }
            
            this.showNotification(`‚úÖ Feeding recorded: ${feedAmount}g of ${feedType}`, 'success');
            this.closeModal('feeding-modal');
            
            // Reload fish data
            await this.loadDataRecords();
            await this.updateFishTankSummary();
            
            // Also refresh fish overview cards to show updated data
            await this.loadFishOverview();
            
        } catch (error) {
            console.error('Error recording feeding:', error);
            this.showNotification('‚ùå Failed to record feeding', 'error');
        }
    }

    closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('show');
            modal.style.display = 'none';
            // Reset form
            const form = modal.querySelector('form');
            if (form) form.reset();
        }
    }

    async displayTankCards(container) {
        try {
            // Early return if no active system selected
            if (!this.activeSystemId || this.activeSystemId === 'undefined') {
                container.innerHTML = '<p>Please select a system to view tank information.</p>';
                return;
            }
            
            // Get system data and recent fish health entries
            const systemData = this.getActiveSystem();

            // Get fish inventory data from the new API
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`).catch((error) => {

                return { tanks: [] };
            });

            const waterQualityData = await this.makeApiCall(`/data/entries/water-quality?system_id=${this.activeSystemId}&limit=10`).catch((error) => {

                return [];
            });
            
            if (!systemData) {
                container.innerHTML = '<p class="no-data">No system data available. Please configure your system in Settings.</p>';
                return;
            }

            // Try to fetch latest fish tank configuration from API
            let fishTanks = [];
            try {
                const tankResponse = await this.makeApiCall(`/fish-tanks/system/${this.activeSystemId}`);
                fishTanks = tankResponse.tanks || [];

            } catch (error) {

                fishTanks = systemData.fish_tanks || [];
            }

            if (!fishTanks || fishTanks.length === 0) {
                // Create mock tanks based on system configuration
                const tankCount = systemData.fish_tank_count || 1;
                const tankVolume = systemData.total_fish_volume || 1000;
                const volumePerTank = Math.floor(tankVolume / tankCount);
                
                fishTanks = [];
                for (let i = 1; i <= tankCount; i++) {
                    fishTanks.push({
                        id: i,
                        tank_number: i,
                        volume_liters: volumePerTank,  // Use correct property name
                        size_m3: volumePerTank / 1000,  // Add size in m¬≥
                        fish_type: systemData.fish_type || 'tilapia'
                    });
                }

            }

            // Update system data with latest fish tanks
            systemData.fish_tanks = fishTanks;

            const currentTemp = this.getLatestWaterQualityData()?.temperature || 25;

            // Calculate overall system density in kg/m¬≥
            const totalSystemVolume = systemData.total_fish_volume || 1000; // in liters
            const totalSystemVolumeM3 = totalSystemVolume / 1000; // convert to cubic meters
            let totalSystemFishWeight = 0;
            
            // Merge tank configuration with inventory data
            const inventoryTanks = fishInventoryData.tanks || [];
            
            fishTanks = fishTanks.map(tank => {
                // Try to match by tank ID first, then by tank number
                const inventory = inventoryTanks.find(inv => 
                    inv.fish_tank_id === tank.id || inv.fish_tank_id === tank.tank_number
                ) || {};
                return { ...tank, inventory };
            });
            
            // Calculate total fish weight across all tanks using inventory data
            fishTanks.forEach(tank => {
                const inventory = tank.inventory || {};
                const fishCount = inventory.current_count || 0;
                const avgWeight = inventory.average_weight || 0;
                totalSystemFishWeight += (fishCount * avgWeight); // in grams
            });
            
            const totalSystemFishWeightKg = totalSystemFishWeight / 1000; // convert to kg
            const systemDensityKgM3 = totalSystemVolumeM3 > 0 ? (totalSystemFishWeightKg / totalSystemVolumeM3).toFixed(1) : '0.0';

            // Use FishManagement component for tank cards generation
            let tankCards = '';
            if (this.fishManagement && typeof this.fishManagement.generateTankCards === 'function') {
                tankCards = this.fishManagement.generateTankCards(fishTanks, systemData, currentTemp);
            } else {
                // Fallback for backward compatibility
                tankCards = '<div class="loading-message">Loading fish tank information...</div>';
                console.warn('FishManagement component not available, using fallback display');
            }

            container.innerHTML = tankCards;

            // Initialize growth charts with actual fish data
            fishTanks.forEach(tank => {
                const inventory = tank.inventory || {};
                const fishData = {
                    fishCount: parseInt(inventory.current_count) || 0,
                    avgWeight: parseFloat(inventory.average_weight) || 0,
                    fishType: systemData.fish_type || 'tilapia',
                    density: parseFloat(inventory.density_kg_m3) || 0
                };
                this.initializeGrowthChart(tank.id, currentTemp, fishData);
            });

        } catch (error) {
            console.error('Failed to load tank information:', error);
            container.innerHTML = '<p class="no-data">Unable to load tank information.</p>';
        }
    }

    getCurrentWaterTemperature(waterQualityData) {
        const recentEntry = waterQualityData.find(entry => entry.temperature);
        return recentEntry?.temperature || 25; // Default to 25¬∞C
    }

    getTemperatureAdjustedFeedingRate(temperature, fishType) {
        // Base feeding rate is 2.5% of body weight per day
        const baseRate = 0.025;
        
        // Optimal temperature ranges for different fish types
        const optimalTemps = {
            'tilapia': { min: 26, max: 30, optimal: 28 },
            'trout': { min: 12, max: 18, optimal: 15 },
            'catfish': { min: 24, max: 29, optimal: 26 },
            'default': { min: 20, max: 26, optimal: 23 }
        };
        
        const tempRange = optimalTemps[fishType?.toLowerCase()] || optimalTemps.default;
        
        // Temperature adjustment factor
        let tempFactor = 1.0;
        
        if (temperature >= tempRange.min && temperature <= tempRange.max) {
            // Within optimal range - normal to increased feeding
            if (temperature <= tempRange.optimal) {
                // Gradually increase from min to optimal
                tempFactor = 0.8 + (0.4 * (temperature - tempRange.min) / (tempRange.optimal - tempRange.min));
            } else {
                // Gradually decrease from optimal to max
                tempFactor = 1.2 - (0.4 * (temperature - tempRange.optimal) / (tempRange.max - tempRange.optimal));
            }
        } else if (temperature < tempRange.min) {
            // Too cold - significantly reduced feeding
            tempFactor = Math.max(0.3, 0.8 * (temperature / tempRange.min));
        } else {
            // Too hot - reduced feeding due to stress
            const excessTemp = temperature - tempRange.max;
            tempFactor = Math.max(0.4, 0.8 - (0.1 * excessTemp));
        }
        
        return baseRate * tempFactor;
    }

    initializeGrowthChart(tankId, temperature, fishData) {
        const chartElement = document.getElementById(`growth-chart-${tankId}`);
        if (!chartElement) return;

        // Calculate realistic growth projection based on fish data and environmental conditions
        const fishCount = fishData.fishCount || 0;
        const avgWeight = fishData.avgWeight || 0;
        const fishType = fishData.fishType || 'tilapia';
        const density = fishData.density || 0;

        if (fishCount === 0) {
            chartElement.innerHTML = `
                <div style="padding: 20px; text-align: center; color: #7f8c8d;">
                    <p style="margin: 10px 0;">
                        <strong>Expected Weekly Growth:</strong> No fish in tank
                    </p>
                    <p style="font-size: 0.9em;">Add fish to see growth projections</p>
                </div>
            `;
            return;
        }

        // Species-specific growth parameters (grams per week at optimal conditions)
        const speciesGrowthRates = {
            tilapia: { baseRate: 15, optimalTempMin: 26, optimalTempMax: 30, maxTemp: 35 },
            trout: { baseRate: 12, optimalTempMin: 15, optimalTempMax: 18, maxTemp: 22 },
            catfish: { baseRate: 10, optimalTempMin: 24, optimalTempMax: 29, maxTemp: 32 },
            bass: { baseRate: 8, optimalTempMin: 20, optimalTempMax: 25, maxTemp: 30 }
        };
        
        const speciesData = speciesGrowthRates[fishType.toLowerCase()] || speciesGrowthRates.tilapia;

        // Temperature factor based on species-specific optimal ranges
        let tempFactor;
        if (temperature < speciesData.optimalTempMin - 5) {
            tempFactor = 0.3; // Very slow growth in cold water
        } else if (temperature < speciesData.optimalTempMin) {
            tempFactor = 0.6; // Slow growth below optimal
        } else if (temperature <= speciesData.optimalTempMax) {
            tempFactor = 1.0; // Optimal growth rate
        } else if (temperature <= speciesData.maxTemp) {
            tempFactor = 0.7; // Reduced growth in warm water
        } else {
            tempFactor = 0.2; // Stress conditions, very slow growth
        }

        // Size factor - smaller fish grow faster (relative to body weight)
        const sizeFactor = avgWeight < 100 ? 1.2 : avgWeight < 300 ? 1.0 : 0.8;
        
        // Density factor - overcrowding reduces growth
        const densityFactor = density > 50 ? 0.6 : density > 30 ? 0.8 : 1.0;

        // Calculate final growth rate per fish
        const baseGrowthRate = speciesData.baseRate;
        const growthRate = baseGrowthRate * tempFactor * sizeFactor * densityFactor;

        // Temperature impact description
        let tempImpact;
        if (temperature < speciesData.optimalTempMin - 5) {
            tempImpact = 'Too cold - very slow growth';
        } else if (temperature < speciesData.optimalTempMin) {
            tempImpact = 'Below optimal - slow growth';
        } else if (temperature <= speciesData.optimalTempMax) {
            tempImpact = 'Optimal range - good growth';
        } else if (temperature <= speciesData.maxTemp) {
            tempImpact = 'Warm - reduced growth';
        } else {
            tempImpact = 'Too hot - stress conditions';
        }

        chartElement.innerHTML = `
            <div style="padding: 20px; text-align: center;">
                <p style="margin: 10px 0; color: #2c3e50;">
                    <strong>Expected Weekly Growth:</strong> ${growthRate.toFixed(1)}g/week per fish
                </p>
                <p style="margin: 10px 0; color: #7f8c8d; font-size: 0.9em;">
                    Based on ${fishType} at ${Math.round(avgWeight)}g avg weight (${fishCount} fish)
                </p>
                <div style="background: #ecf0f1; border-radius: 4px; padding: 10px; margin-top: 10px;">
                    <strong>Temperature Impact:</strong> ${tempImpact}
                </div>
                ${density > 30 ? `
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 0.9em;">
                    <strong>Density Alert:</strong> High density (${density.toFixed(1)} kg/m¬≥) may reduce growth
                </div>` : ''}
            </div>
        `;
    }

    loadFishHealthMonitoring() {

        const container = document.querySelector('#fish-health-monitoring-content .fish-health-dashboard');
        if (!container) return;

        this.displayFishHealthDashboard(container);
    }

    async displayFishHealthDashboard(container) {
        try {
            const fishInventoryData = await this.makeApiCall(`/fish-inventory/system/${this.activeSystemId}`).catch((error) => {

                return { tanks: [] };
            });
            
            // Convert inventory data to a format similar to health data for compatibility
            const inventoryTanks = fishInventoryData.tanks || [];
            const waterQualityData = await this.makeApiCall(`/data/entries/water-quality?system_id=${this.activeSystemId}&limit=50`).catch((error) => {

                return [];
            });

            // Calculate health metrics from inventory data
            const totalFish = inventoryTanks.reduce((sum, tank) => sum + (tank.current_count || 0), 0);
            
            // Calculate weighted average weight
            let totalWeight = 0;
            let totalCount = 0;
            inventoryTanks.forEach(tank => {
                const count = tank.current_count || 0;
                const weight = tank.average_weight || 0;
                totalWeight += count * weight;
                totalCount += count;
            });
            const avgWeight = totalCount > 0 ? totalWeight / totalCount : 0;
            
            // Mortality rate and behavior are not available in inventory - will be added with events later
            const mortalityRate = 0; // TODO: Calculate from fish events
            const normalBehaviorPercentage = 100; // TODO: Calculate from fish events

            // Get latest water quality using the same method as dashboard
            const latestWaterQuality = this.getLatestWaterQualityData();
            const tempStatus = this.getTemperatureStatus(latestWaterQuality?.temperature);
            const phStatus = this.getPHStatus(latestWaterQuality?.ph);

            const dashboardHtml = `
                <div class="health-overview">
                    <h3>üêü Fish Health Overview</h3>
                    <div class="health-metrics">
                        <div class="health-metric">
                            <div class="health-metric-label">Total Fish</div>
                            <div class="health-metric-value good">${totalFish}</div>
                            <div class="health-metric-status good">Active</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-label">Mortality Rate</div>
                            <div class="health-metric-value ${mortalityRate > 5 ? 'danger' : mortalityRate > 2 ? 'warning' : 'good'}">${mortalityRate}%</div>
                            <div class="health-metric-status ${mortalityRate > 5 ? 'danger' : mortalityRate > 2 ? 'warning' : 'good'}">
                                ${mortalityRate > 5 ? 'High' : mortalityRate > 2 ? 'Moderate' : 'Low'}
                            </div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-label">Avg Weight</div>
                            <div class="health-metric-value good">${avgWeight.toFixed(1)}g</div>
                            <div class="health-metric-status good">Growing</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-label">Normal Behavior</div>
                            <div class="health-metric-value ${normalBehaviorPercentage > 80 ? 'good' : normalBehaviorPercentage > 60 ? 'warning' : 'danger'}">${normalBehaviorPercentage}%</div>
                            <div class="health-metric-status ${normalBehaviorPercentage > 80 ? 'good' : normalBehaviorPercentage > 60 ? 'warning' : 'danger'}">
                                ${normalBehaviorPercentage > 80 ? 'Excellent' : normalBehaviorPercentage > 60 ? 'Good' : 'Concerning'}
                            </div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-label">Water Temp</div>
                            <div class="health-metric-value ${tempStatus.class}">${latestWaterQuality?.temperature || 'N/A'}¬∞C</div>
                            <div class="health-metric-status ${tempStatus.class}">${tempStatus.status}</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-label">pH Level</div>
                            <div class="health-metric-value ${phStatus.class}">${latestWaterQuality?.ph || 'N/A'}</div>
                            <div class="health-metric-status ${phStatus.class}">${phStatus.status}</div>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = dashboardHtml;

        } catch (error) {
            console.error('Failed to load fish health dashboard:', error);
            container.innerHTML = '<p class="no-data">Unable to load fish health data.</p>';
        }
    }

    getTemperatureStatus(temperature) {
        if (!temperature) return { class: 'warning', status: 'No Data' };
        if (temperature < 18) return { class: 'danger', status: 'Too Cold' };
        if (temperature > 32) return { class: 'danger', status: 'Too Hot' };
        if (temperature < 22 || temperature > 28) return { class: 'warning', status: 'Suboptimal' };
        return { class: 'good', status: 'Optimal' };
    }

    getPHStatus(ph) {
        if (!ph) return { class: 'warning', status: 'No Data' };
        if (ph < 6.0 || ph > 8.5) return { class: 'danger', status: 'Critical' };
        if (ph < 6.5 || ph > 8.0) return { class: 'warning', status: 'Suboptimal' };
        return { class: 'good', status: 'Optimal' };
    }

    async submitFishHealthData() {
        if (!this.activeSystemId) {
            this.showNotification('‚ùå No active system selected', 'error');
            return;
        }

        // Get current values and calculate new fish count
        const newFishAdded = parseInt(document.getElementById('new-fish-added').value) || 0;
        const newMortalities = parseInt(document.getElementById('fish-mortality').value) || 0;
        const currentCount = parseInt(document.getElementById('fish-count').value) || 0;
        
        // Calculate updated fish count (current + new additions - mortalities)
        const updatedCount = Math.max(0, currentCount + newFishAdded - newMortalities);

        const formData = {
            system_id: this.activeSystemId,
            fish_tank_id: parseInt(document.getElementById('fish-tank').value),
            count: updatedCount,
            mortality: newMortalities,
            average_weight: parseFloat(document.getElementById('average-weight').value) || null,
            feed_consumption: parseFloat(document.getElementById('feed-consumption').value) || null,
            behavior: document.getElementById('fish-behavior').value,
            notes: document.getElementById('fish-notes').value.trim() || null,
            date: document.getElementById('fish-entry-date').value
        };

        try {
            await this.makeApiCall('/data/entries/fish-health', {
                method: 'POST',
                body: JSON.stringify(formData)
            });

            this.showNotification('‚úÖ Fish health data recorded successfully!', 'success');
            
            // Reset form but keep the tank selection
            const selectedTank = document.getElementById('fish-tank').value;
            document.getElementById('fish-health-entry-form').reset();
            document.getElementById('fish-entry-date').value = new Date().toISOString().slice(0, 16);
            document.getElementById('fish-tank').value = selectedTank;
            
            // Update the current fish count to reflect the new total
            setTimeout(() => {
                this.updateCurrentFishCount();
            }, 100);
            
            // Reload fish health history
            this.loadFishHealthHistory();
            
            // Refresh tank information if that tab is active
            const tankInfoContent = document.getElementById('tank-information-content');
            if (tankInfoContent && tankInfoContent.classList.contains('active')) {
                this.loadTankInformation();
            }
            
            // Refresh fish health monitoring if that tab is active
            const healthMonitoringContent = document.getElementById('fish-health-monitoring-content');
            if (healthMonitoringContent && healthMonitoringContent.classList.contains('active')) {
                this.loadFishHealthMonitoring();
            }
            
            // Refresh data records to include the new fish health entry
            await this.loadDataRecords();
            
            // Refresh fish overview cards to update "Last Fed" information
            const fishOverviewContent = document.getElementById('fish-overview-content');
            if (fishOverviewContent && fishOverviewContent.classList.contains('active')) {
                await this.loadFishOverview();
            }

        } catch (error) {
            console.error('Failed to submit fish health data:', error);
            this.showNotification('‚ùå Failed to record fish health data. Please try again.', 'error');
        }
    }

    // System Sharing Methods
    loadSystemSharing() {

        this.setupSystemSharingEventListeners();
        this.loadSharedUsers();
        this.loadPendingInvitations();
        this.loadPublicAccessSettings();
    }

    setupSystemSharingEventListeners() {
        // Invite user form
        const inviteForm = document.getElementById('invite-user-form');
        if (inviteForm) {
            inviteForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.sendInvitation();
            });
        }

        // Public access toggle
        const publicViewToggle = document.getElementById('allow-public-view');
        if (publicViewToggle) {
            publicViewToggle.addEventListener('change', (e) => {
                this.togglePublicAccess(e.target.checked);
            });
        }

        // Copy public link
        const copyLinkBtn = document.getElementById('copy-public-link');
        if (copyLinkBtn) {
            copyLinkBtn.addEventListener('click', () => {
                this.copyPublicLink();
            });
        }
    }

    async sendInvitation() {
        const email = document.getElementById('invite-email').value.trim();
        const permission = document.getElementById('invite-permission').value;
        const message = document.getElementById('invite-message').value.trim();

        if (!email || !permission) {
            this.showNotification('‚ùå Please fill in all required fields', 'error');
            return;
        }

        if (!this.activeSystemId) {
            this.showNotification('‚ùå No active system selected', 'error');
            return;
        }

        try {
            const invitationData = {
                system_id: this.activeSystemId,
                email: email,
                permission_level: permission,
                message: message || null,
                invited_by: this.user?.email || 'Unknown'
            };

            await this.makeApiCall('/system-sharing/invite', {
                method: 'POST',
                body: JSON.stringify(invitationData)
            });

            this.showNotification('‚úÖ Invitation sent successfully!', 'success');
            
            // Clear form
            document.getElementById('invite-user-form').reset();
            
            // Reload pending invitations
            this.loadPendingInvitations();

        } catch (error) {
            console.error('Failed to send invitation:', error);
            if (error.message.includes('already has access')) {
                this.showNotification('‚ö†Ô∏è User already has access to this system', 'warning');
            } else {
                this.showNotification('‚ùå Failed to send invitation. Please try again.', 'error');
            }
        }
    }

    async loadSharedUsers() {
        try {
            const response = await this.makeApiCall(`/system-sharing/users?system_id=${this.activeSystemId}`).catch(() => ({ shares: [] }));
            const sharedUsers = response.shares || response || []; // Handle both response formats
            
            const container = document.getElementById('shared-users-list');
            if (!container) return;

            if (sharedUsers.length === 0) {
                container.innerHTML = '<div class="no-data-message">No users currently have access to this system.</div>';
                return;
            }

            const html = sharedUsers.map(user => {
                const userName = user.first_name && user.last_name ? `${user.first_name} ${user.last_name}` : user.username;
                const initials = this.getUserInitials(userName || user.email);
                const isCurrentUser = user.email === this.user?.email;
                
                return `
                    <div class="user-item">
                        <div class="user-info">
                            <div class="user-avatar">${initials}</div>
                            <div class="user-details">
                                <div class="user-name">${userName || 'Unknown User'} ${isCurrentUser ? '(You)' : ''}</div>
                                <div class="user-email">${user.email}</div>
                            </div>
                            <span class="user-role ${user.permission_level}">${user.permission_level}</span>
                        </div>
                        <div class="user-actions">
                            ${!isCurrentUser ? `
                                <button class="action-btn edit-btn" onclick="app.editUserPermission('${user.id}', '${user.permission_level}')">
                                    Edit
                                </button>
                                <button class="action-btn remove-btn" onclick="app.removeUserAccess('${user.id}', '${user.email}')">
                                    Remove
                                </button>
                            ` : '<span style="color: #666; font-size: 0.9rem;">System Owner</span>'}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;

        } catch (error) {
            console.error('Failed to load shared users:', error);
            const container = document.getElementById('shared-users-list');
            if (container) {
                container.innerHTML = '<div class="no-data-message">Unable to load shared users.</div>';
            }
        }
    }

    async loadPendingInvitations() {
        try {
            const response = await this.makeApiCall(`/system-sharing/invitations?system_id=${this.activeSystemId}`).catch(() => ({ invitations: [] }));
            const pendingInvitations = response.invitations || response || []; // Handle both response formats
            
            const container = document.getElementById('pending-invitations-list');
            if (!container) return;

            if (pendingInvitations.length === 0) {
                container.innerHTML = '<div class="no-data-message">No pending invitations.</div>';
                return;
            }

            const html = pendingInvitations.map(invitation => {
                const initials = this.getUserInitials(invitation.email);
                const sentDate = this.formatDateDDMMYYYY(new Date(invitation.created_at));
                
                return `
                    <div class="invitation-item">
                        <div class="invitation-info">
                            <div class="user-avatar">${initials}</div>
                            <div class="invitation-details">
                                <div class="invitation-email">${invitation.email}</div>
                                <div style="color: #666; font-size: 0.8rem;">Sent on ${sentDate}</div>
                            </div>
                            <span class="invitation-role ${invitation.permission_level}">${invitation.permission_level}</span>
                        </div>
                        <div class="invitation-actions">
                            <button class="action-btn resend-btn" onclick="app.resendInvitation('${invitation.id}')">
                                Resend
                            </button>
                            <button class="action-btn cancel-btn" onclick="app.cancelInvitation('${invitation.id}')">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;

        } catch (error) {
            console.error('Failed to load pending invitations:', error);
            const container = document.getElementById('pending-invitations-list');
            if (container) {
                container.innerHTML = '<div class="no-data-message">Unable to load pending invitations.</div>';
            }
        }
    }

    async loadPublicAccessSettings() {
        try {
            const settings = await this.makeApiCall(`/system-sharing/public-settings?system_id=${this.activeSystemId}`).catch(() => ({ public_access: false, public_link: null }));
            
            const publicToggle = document.getElementById('allow-public-view');
            const publicLinkSection = document.getElementById('public-link-section');
            const publicLinkInput = document.getElementById('public-link');

            if (publicToggle) {
                publicToggle.checked = settings.public_access || false;
            }

            if (publicLinkSection && publicLinkInput) {
                if (settings.public_access && settings.public_link) {
                    publicLinkSection.style.display = 'block';
                    publicLinkInput.value = settings.public_link;
                } else {
                    publicLinkSection.style.display = 'none';
                }
            }

        } catch (error) {
            console.error('Failed to load public access settings:', error);
        }
    }

    async togglePublicAccess(enabled) {
        try {
            const result = await this.makeApiCall('/system-sharing/public-access', {
                method: 'PUT',
                body: JSON.stringify({
                    system_id: this.activeSystemId,
                    public_access: enabled
                })
            });

            const publicLinkSection = document.getElementById('public-link-section');
            const publicLinkInput = document.getElementById('public-link');

            if (enabled && result.public_link) {
                publicLinkSection.style.display = 'block';
                publicLinkInput.value = result.public_link;
                this.showNotification('‚úÖ Public access enabled! Link generated.', 'success');
            } else {
                publicLinkSection.style.display = 'none';
                this.showNotification('‚úÖ Public access disabled.', 'success');
            }

        } catch (error) {
            console.error('Failed to toggle public access:', error);
            this.showNotification('‚ùå Failed to update public access settings.', 'error');
            
            // Revert checkbox state
            const publicToggle = document.getElementById('allow-public-view');
            if (publicToggle) {
                publicToggle.checked = !enabled;
            }
        }
    }

    copyPublicLink() {
        const publicLinkInput = document.getElementById('public-link');
        if (publicLinkInput && publicLinkInput.value) {
            navigator.clipboard.writeText(publicLinkInput.value).then(() => {
                this.showNotification('üìã Public link copied to clipboard!', 'success');
            }).catch(() => {
                // Fallback for older browsers
                publicLinkInput.select();
                document.execCommand('copy');
                this.showNotification('üìã Public link copied to clipboard!', 'success');
            });
        }
    }

    async editUserPermission(userId, currentPermission) {
        const newPermission = prompt(`Change permission level for this user:\n\nCurrent: ${currentPermission}\n\nEnter new permission (viewer/collaborator/admin):`, currentPermission);
        
        if (!newPermission || newPermission === currentPermission) {
            return;
        }

        if (!['viewer', 'collaborator', 'admin'].includes(newPermission.toLowerCase())) {
            this.showNotification('‚ùå Invalid permission level. Use: viewer, collaborator, or admin', 'error');
            return;
        }

        try {
            await this.makeApiCall('/system-sharing/permission', {
                method: 'PUT',
                body: JSON.stringify({
                    user_id: userId,
                    system_id: this.activeSystemId,
                    permission_level: newPermission.toLowerCase()
                })
            });

            this.showNotification('‚úÖ User permission updated successfully!', 'success');
            this.loadSharedUsers();

        } catch (error) {
            console.error('Failed to update user permission:', error);
            this.showNotification('‚ùå Failed to update user permission.', 'error');
        }
    }

    async removeUserAccess(shareId, userEmail) {
        if (!confirm(`Are you sure you want to remove access for ${userEmail}?\n\nThey will no longer be able to view or edit this system.`)) {
            return;
        }

        try {
            await this.makeApiCall(`/system-sharing/access/${shareId}`, {
                method: 'DELETE'
            });

            this.showNotification('‚úÖ User access removed successfully!', 'success');
            this.loadSharedUsers();

        } catch (error) {
            console.error('Failed to remove user access:', error);
            this.showNotification('‚ùå Failed to remove user access.', 'error');
        }
    }

    async resendInvitation(invitationId) {
        try {
            await this.makeApiCall(`/system-sharing/invitation/${invitationId}/resend`, {
                method: 'POST'
            });

            this.showNotification('‚úÖ Invitation resent successfully!', 'success');
            this.loadPendingInvitations();

        } catch (error) {
            console.error('Failed to resend invitation:', error);
            this.showNotification('‚ùå Failed to resend invitation.', 'error');
        }
    }

    async cancelInvitation(invitationId) {
        if (!confirm('Are you sure you want to cancel this invitation?')) {
            return;
        }

        try {
            await this.makeApiCall(`/system-sharing/invitation/${invitationId}`, {
                method: 'DELETE'
            });

            this.showNotification('‚úÖ Invitation cancelled successfully!', 'success');
            this.loadPendingInvitations();

        } catch (error) {
            console.error('Failed to cancel invitation:', error);
            this.showNotification('‚ùå Failed to cancel invitation.', 'error');
        }
    }

    getUserInitials(name) {
        if (!name) return '?';
        
        const words = name.split(' ');
        if (words.length >= 2) {
            return (words[0][0] + words[1][0]).toUpperCase();
        } else {
            return name.substring(0, 2).toUpperCase();
        }
    }

    // Sensor Configuration Methods
    async loadSensorConfiguration() {
        // Check if credentials exist first
        await this.checkThingsBoardCredentials();
        this.setupSensorEventListeners();
        await this.loadSensorsList();
        // Load available devices and telemetry keys if credentials are valid
        if (this.tbCredentialsValid) {
            await this.loadThingsBoardDevices();
        }
    }
    
    async checkThingsBoardCredentials() {
        try {
            const response = await this.makeApiCall(`/credentials/thingsboard/status/${this.activeSystemId}`);
            this.tbCredentialsValid = response.configured && response.connected;
            
            // Update status indicator
            const statusIndicator = document.getElementById('tb-credential-status');
            if (statusIndicator) {
                statusIndicator.innerHTML = `
                    <div class="credential-status ${response.connected ? 'connected' : 'disconnected'}">
                        <span class="status-icon">${response.connected ? '‚úÖ' : '‚ùå'}</span>
                        <span class="status-text">${response.message}</span>
                    </div>
                `;
            }
            
            if (!this.tbCredentialsValid) {
                const sensorFormContainer = document.querySelector('.sensor-form-container');
                if (sensorFormContainer) {
                    sensorFormContainer.innerHTML = `
                        <div class="alert alert-warning">
                            <h4>‚ö†Ô∏è ThingsBoard Credentials Required</h4>
                            <p>${response.message}</p>
                            <button class="btn btn-primary" onclick="document.getElementById('credentials-tab').click()">
                                Configure Credentials
                            </button>
                        </div>
                    `;
                }
            } else {
                // Restore sensor form if credentials are valid
                this.restoreSensorForm();
            }
            return this.tbCredentialsValid;
        } catch (error) {
            console.error('Error checking ThingsBoard credentials:', error);
            this.tbCredentialsValid = false;
            return false;
        }
    }
    
    async loadThingsBoardDevices() {
        try {
            // Fetch available devices from ThingsBoard
            const response = await this.makeApiCall(`/credentials/thingsboard/devices/${this.activeSystemId}`);
            const devices = response.devices || [];
            
            const deviceSelect = document.getElementById('device-id');
            if (deviceSelect && devices.length > 0) {
                // Convert to dropdown if it's an input
                let selectElement = deviceSelect;
                if (deviceSelect.tagName === 'INPUT') {
                    const newSelect = document.createElement('select');
                    newSelect.id = 'device-id';
                    newSelect.name = 'device_id';
                    newSelect.required = true;
                    newSelect.className = deviceSelect.className;
                    
                    // Replace input with select
                    deviceSelect.parentNode.replaceChild(newSelect, deviceSelect);
                    selectElement = newSelect;
                }
                
                // Add options
                selectElement.innerHTML = '<option value="">Select a device...</option>';
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = `${device.name} (${device.type})`;
                    option.dataset.deviceName = device.name;
                    option.dataset.deviceType = device.type;
                    selectElement.appendChild(option);
                });
                
                // Add change listener to load telemetry keys
                selectElement.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await this.loadTelemetryKeys(e.target.value);
                    } else {
                        // Clear telemetry keys if no device selected
                        const telemetrySelect = document.getElementById('telemetry-key');
                        if (telemetrySelect) {
                            telemetrySelect.innerHTML = '<option value="">Select device first...</option>';
                            telemetrySelect.disabled = true;
                        }
                    }
                });
            }
        } catch (error) {
            console.error('Error loading ThingsBoard devices:', error);
            this.showNotification('Failed to load devices. Please check your credentials.', 'error');
        }
    }
    
    async loadTelemetryKeys(deviceId) {
        try {
            // Fetch available telemetry keys for the selected device
            const response = await this.makeApiCall(`/credentials/thingsboard/devices/${this.activeSystemId}/${deviceId}/telemetry-keys`);
            const telemetryKeys = response.telemetryKeys || [];
            
            const telemetrySelect = document.getElementById('telemetry-key');
            if (telemetrySelect) {
                // Convert to dropdown if it's still an input
                let selectElement = telemetrySelect;
                if (telemetrySelect.tagName === 'INPUT') {
                    const newSelect = document.createElement('select');
                    newSelect.id = 'telemetry-key';
                    newSelect.name = 'telemetry_key';
                    newSelect.required = true;
                    newSelect.className = telemetrySelect.className;
                    
                    telemetrySelect.parentNode.replaceChild(newSelect, telemetrySelect);
                    selectElement = newSelect;
                }
                
                selectElement.innerHTML = '<option value="">Select telemetry key...</option>';
                
                if (telemetryKeys.length > 0) {
                    telemetryKeys.forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        selectElement.appendChild(option);
                    });
                    selectElement.disabled = false;
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No telemetry keys found';
                    selectElement.appendChild(option);
                    selectElement.disabled = true;
                }
            }
        } catch (error) {
            console.error('Error loading telemetry keys:', error);
            const telemetrySelect = document.getElementById('telemetry-key');
            if (telemetrySelect) {
                telemetrySelect.innerHTML = '<option value="">Error loading keys</option>';
                telemetrySelect.disabled = true;
            }
        }
    }

    restoreSensorForm() {
        const sensorFormContainer = document.querySelector('.sensor-form-container');
        if (sensorFormContainer && sensorFormContainer.innerHTML.includes('ThingsBoard Credentials Required')) {
            // Reload the entire sensor configuration to restore the form
            this.loadSensorConfiguration();
        }
    }

    setupSensorEventListeners() {
        // Add sensor form submission
        const addSensorForm = document.getElementById('add-sensor-form');
        if (addSensorForm) {
            addSensorForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.saveSensorConfiguration();
            });
        }

        // Test sensor connection button
        const testConnectionBtn = document.getElementById('test-sensor-connection-new');
        if (testConnectionBtn) {
            testConnectionBtn.addEventListener('click', async () => {
                await this.testSensorConnection();
            });
        }

        // Table mapping change handler
        const mappedTableSelect = document.getElementById('mapped-table');
        if (mappedTableSelect) {
            mappedTableSelect.addEventListener('change', (e) => {
                this.updateFieldMappingOptions(e.target.value);
            });
        }

        // Field mapping change handler
        const mappedFieldSelect = document.getElementById('mapped-field');
        if (mappedFieldSelect) {
            mappedFieldSelect.addEventListener('change', () => {
                this.updateMappingPreview();
            });
        }

        // Transform change handler
        const dataTransformSelect = document.getElementById('data-transform');
        if (dataTransformSelect) {
            dataTransformSelect.addEventListener('change', () => {
                this.updateMappingPreview();
            });
        }
    }

    async loadSensorsList() {
        if (!this.activeSystemId) return;

        try {

            const data = await this.makeApiCall(`/sensors/system/${this.activeSystemId}`);

            const sensorsList = document.getElementById('sensors-list');
            if (!sensorsList) {
                console.error('üîß sensors-list element not found!');
                return;
            }

            if (!data.sensors || data.sensors.length === 0) {

                sensorsList.innerHTML = '<div class="empty-sensors">No sensors configured yet. Add your first sensor above.</div>';
                return;
            }

            // Generate sensor HTML with proper escaping and debugging
            const sensorHtml = data.sensors.map(sensor => {
                // Calculate online/offline status based on last reading
                const isOnline = this.isSensorOnline(sensor.last_reading, sensor.update_interval, sensor.sensor_name);
                const lastReadingTime = sensor.last_reading ? new Date(sensor.last_reading) : null;
                const lastReadingDisplay = lastReadingTime ? 
                    `${lastReadingTime.toLocaleDateString()} ${lastReadingTime.toLocaleTimeString()}` : 
                    'Never';
                
                const html = `
                <div class="sensor-item" data-sensor-id="${sensor.id}">
                    <div class="sensor-info">
                        <h5>${sensor.sensor_name || 'Unnamed Sensor'}</h5>
                        <div class="sensor-details">
                            <span><strong>Update Interval:</strong> ${sensor.update_interval || 300}s</span>
                            <span><strong>Last Reading:</strong> ${lastReadingDisplay}</span>
                        </div>
                    </div>
                    <div class="sensor-status">
                        <div class="status-row">
                            <label class="toggle-switch">
                                <input type="checkbox" ${sensor.active ? 'checked' : ''} onchange="window.app.toggleSensorStatus(${sensor.id}, this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                            <span>${sensor.active ? 'Sensor Data' : 'Manual Data'}</span>
                        </div>
                        <div class="status-row">
                            <span class="status-indicator ${isOnline ? 'online' : 'offline'}"></span>
                            <span>${isOnline ? 'Online' : 'Offline'}</span>
                        </div>
                    </div>
                    <div class="sensor-actions">
                        ${!sensor.active ? `
                        <button type="button" class="btn btn-info" onclick="window.app.switchToTab('data-tab')" style="margin-right: 8px;">
                            üìù Enter Data
                        </button>
                        ` : ''}
                        <button type="button" class="btn btn-secondary" onclick="window.app.fetchSensorData(${sensor.id})" style="margin-right: 8px;">
                            View Data
                        </button>
                        <button type="button" class="btn btn-primary" onclick="window.app.editSensor(${sensor.id})" style="margin-right: 8px;">
                            Edit
                        </button>
                        <button type="button" class="btn btn-danger" onclick="window.app.deleteSensor(${sensor.id})">
                            Delete
                        </button>
                    </div>
                </div>`;

                return html;
            }).join('');

            sensorsList.innerHTML = sensorHtml;
            setTimeout(() => {
                const viewButtons = sensorsList.querySelectorAll('button.btn-secondary');
                const deleteButtons = sensorsList.querySelectorAll('button.btn-danger');

                viewButtons.forEach((btn, idx) => {

                });
            }, 100);

        } catch (error) {
            console.error('Error loading sensors:', error);
            this.showNotification('Failed to load sensors', 'error');
        }
    }

    async saveSensorConfiguration() {
        const form = document.getElementById('add-sensor-form');
        const formData = new FormData(form);
        
        const sensorData = {
            system_id: this.activeSystemId,
            sensor_name: formData.get('sensor_name'),
            sensor_type: formData.get('sensor_type'),
            device_id: formData.get('device_id'),
            telemetry_key: formData.get('telemetry_key'),
            update_interval: parseInt(formData.get('update_interval')) || 300,
            api_url: formData.get('api_url'),
            mapped_table: formData.get('mapped_table') || null,
            mapped_field: formData.get('mapped_field') || null,
            data_transform: formData.get('data_transform') || null
        };

        if (!sensorData.sensor_name || !sensorData.sensor_type || !sensorData.device_id) {
            this.showNotification('Please fill in all required fields', 'error');
            return;
        }

        try {
            let data;
            let successMessage;
            
            if (this.editingSensorId) {
                // Update existing sensor
                data = await this.makeApiCall(`/sensors/${this.editingSensorId}`, {
                    method: 'PUT',
                    body: JSON.stringify(sensorData)
                });
                successMessage = 'Sensor configuration updated successfully';
            } else {
                // Create new sensor
                data = await this.makeApiCall('/sensors', {
                    method: 'POST',
                    body: JSON.stringify(sensorData)
                });
                successMessage = 'Sensor configuration saved successfully';
            }
            
            this.showNotification(successMessage, 'success');
            
            // Reset form and edit state
            form.reset();
            this.editingSensorId = null;
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.textContent = 'Add Sensor';
            }
            
            await this.loadSensorsList();

        } catch (error) {
            console.error('Error saving sensor configuration:', error);
            
            // Enhanced error handling with user-friendly messages
            let errorMessage = 'Failed to save sensor configuration';
            let errorType = 'error';
            
            const originalError = error.response?.error || error.message || '';
            
            if (originalError.includes('already exists for this system')) {
                // Try to extract conflicting sensor info from the enhanced error response
                const conflictInfo = error.response?.conflicting_sensor;
                let conflictDetails = '';
                
                if (conflictInfo) {
                    conflictDetails = `\nüìã Existing Sensor: "${conflictInfo.name}" (${conflictInfo.device_id})\n`;
                }
                
                errorMessage = `üîß Sensor Already Configured${conflictDetails}\nThis device ID is already being used for this sensor type in your system. Each sensor type (temperature, pH, etc.) can only be added once per system.\n\nüí° Solutions:\n‚Ä¢ Use a different device ID\n‚Ä¢ Update the existing sensor configuration\n‚Ä¢ Remove the existing sensor first`;
                errorType = 'warning';
            } else if (originalError.includes('Failed to authenticate') || originalError.includes('ThingsBoard')) {
                errorMessage = `üîê Authentication Failed\n\nUnable to connect to the ThingsBoard platform. This usually means:\n\nüí° Next Steps:\n‚Ä¢ Go to Settings ‚Üí Credentials tab\n‚Ä¢ Update your ThingsBoard username/password\n‚Ä¢ Test the connection again\n‚Ä¢ Contact support if the issue persists`;
                errorType = 'warning';
            } else if (originalError.includes('device not found') || originalError.includes('Device ID')) {
                errorMessage = `üîç Device Not Found\n\nThe specified device ID was not found in your ThingsBoard account.\n\nüí° Check:\n‚Ä¢ Device ID spelling and format\n‚Ä¢ Device is properly registered in ThingsBoard\n‚Ä¢ Device is active and accessible`;
                errorType = 'warning';
            } else {
                errorMessage = `‚ùå Sensor Configuration Error\n\n${originalError}\n\nüí° Try:\n‚Ä¢ Check your internet connection\n‚Ä¢ Verify all form fields are correct\n‚Ä¢ Go to Settings ‚Üí Credentials to update authentication`;
            }
            
            this.showNotification(errorMessage, errorType);
        }
    }

    async testSensorConnection() {
        const form = document.getElementById('add-sensor-form');
        const formData = new FormData(form);
        
        const testData = {
            system_id: this.activeSystemId,
            api_url: formData.get('api_url') || 'https://tb.datascapeindustrial.com',
            device_id: formData.get('device_id')
        };

        if (!testData.device_id) {
            this.showNotification('Please enter a device ID to test connection', 'error');
            return;
        }

        const testBtn = document.getElementById('test-sensor-connection-new');
        const originalText = testBtn.textContent;
        testBtn.textContent = 'Testing...';
        testBtn.disabled = true;

        try {
            const result = await this.makeApiCall('/sensors/test', {
                method: 'POST',
                body: JSON.stringify(testData)
            });
            
            if (result.success) {
                this.showNotification('Connection test successful!', 'success');
            } else {
                this.showNotification(`Connection failed: ${result.error}`, 'error');
            }

        } catch (error) {
            console.error('Error testing sensor connection:', error);
            
            // Enhanced error handling for connection test
            let errorMessage = 'Connection test failed';
            let errorType = 'error';
            
            const originalError = error.response?.error || error.message || '';
            
            if (originalError.includes('Failed to authenticate') || originalError.includes('ThingsBoard')) {
                errorMessage = `üîê Authentication Failed\n\nCannot connect to ThingsBoard with current credentials.\n\nüí° Next Steps:\n‚Ä¢ Go to Settings ‚Üí Credentials tab\n‚Ä¢ Enter your ThingsBoard username/password\n‚Ä¢ Try the test again\n\nüìù Note: You need valid ThingsBoard account credentials to connect sensors.`;
                errorType = 'warning';
            } else if (originalError.includes('device not found') || originalError.includes('Device ID')) {
                errorMessage = `üîç Device Not Found\n\nThe device "${testData.device_id}" was not found in your ThingsBoard account.\n\nüí° Check:\n‚Ä¢ Device ID spelling (case-sensitive)\n‚Ä¢ Device exists in your ThingsBoard dashboard\n‚Ä¢ Device is active and accessible\n‚Ä¢ You have permission to access this device`;
                errorType = 'warning';
            } else if (originalError.includes('network') || originalError.includes('timeout')) {
                errorMessage = `üåê Connection Timeout\n\nUnable to reach the ThingsBoard server.\n\nüí° Check:\n‚Ä¢ Your internet connection\n‚Ä¢ ThingsBoard server URL is correct\n‚Ä¢ Firewall/proxy settings\n‚Ä¢ Try again in a few moments`;
                errorType = 'warning';
            } else {
                errorMessage = `‚ö†Ô∏è Connection Test Failed\n\n${originalError}\n\nüí° Troubleshooting:\n‚Ä¢ Verify device ID format\n‚Ä¢ Check ThingsBoard credentials in Settings\n‚Ä¢ Ensure device is online and accessible`;
            }
            
            this.showNotification(errorMessage, errorType);
        } finally {
            testBtn.textContent = originalText;
            testBtn.disabled = false;
        }
    }

    async fetchSensorData(sensorId) {
        try {
            const data = await this.makeApiCall(`/sensors/data/${sensorId}`);
            
            // Show sensor data in a modal or alert for now
            // In a real implementation, you'd create a proper modal or dashboard
            alert(`Latest data for ${data.sensor_name}:\n\n${JSON.stringify(data.data, null, 2)}`);
            
        } catch (error) {
            console.error('Error fetching sensor data:', error);
            const errorMessage = error.response?.error || error.message || 'Failed to fetch sensor data';
            this.showNotification(errorMessage, 'error');
        }
    }

    async toggleSensorStatus(sensorId, isActive) {
        try {
            const response = await this.makeApiCall(`/sensors/${sensorId}/toggle`, {
                method: 'PATCH'
            });

            // Show appropriate notification with guidance
            if (isActive) {
                this.showNotification('Sensor switched to automatic data collection', 'success');
            } else {
                this.showNotification('Sensor switched to manual data entry. Use the Data tab to input readings manually.', 'info');
            }
            
            // Refresh the sensor list to show updated status
            await this.loadSensorsList();

        } catch (error) {
            console.error('Error toggling sensor status:', error);
            const errorMessage = error.response?.error || error.message || 'Failed to toggle sensor status';
            this.showNotification(errorMessage, 'error');
            
            // Refresh the list to revert toggle state on error
            await this.loadSensorsList();
        }
    }

    switchToTab(tabId) {
        const tabElement = document.getElementById(tabId);
        if (tabElement) {
            tabElement.click();
        }
    }

    async deleteSensor(sensorId) {
        if (!confirm('Are you sure you want to delete this sensor configuration?')) {
            return;
        }

        try {
            await this.makeApiCall(`/sensors/${sensorId}`, {
                method: 'DELETE'
            });

            this.showNotification('Sensor deleted successfully', 'success');
            await this.loadSensorsList();

        } catch (error) {
            console.error('Error deleting sensor:', error);
            const errorMessage = error.response?.error || error.message || 'Failed to delete sensor';
            this.showNotification(errorMessage, 'error');
        }
    }

    async editSensor(sensorId) {
        try {
            // Get sensor data from the sensor list
            const sensorsResponse = await this.makeApiCall(`/sensors/system/${this.activeSystemId}`);
            const sensor = sensorsResponse.sensors.find(s => s.id == sensorId);
            
            if (!sensor) {
                this.showNotification('Sensor not found', 'error');
                return;
            }
            
            // Populate the form with sensor data
            const form = document.getElementById('add-sensor-form');
            if (!form) {
                this.showNotification('Edit form not found', 'error');
                return;
            }
            
            // Fill in the form fields
            document.getElementById('sensor-name').value = sensor.sensor_name || '';
            document.getElementById('sensor-type').value = sensor.sensor_type || '';
            document.getElementById('device-id').value = sensor.device_id || '';
            document.getElementById('telemetry-key').value = sensor.telemetry_key || '';
            document.getElementById('update-interval').value = sensor.update_interval || 300;
            document.getElementById('api-url').value = sensor.api_url || '';
            
            // Handle mapping fields
            const mappedTableSelect = document.getElementById('mapped-table');
            const mappedFieldSelect = document.getElementById('mapped-field');
            
            if (sensor.mapped_table) {
                mappedTableSelect.value = sensor.mapped_table;
                this.updateFieldMappingOptions(sensor.mapped_table);
                
                // Wait a moment for field options to populate, then set the field
                setTimeout(() => {
                    if (sensor.mapped_field) {
                        mappedFieldSelect.value = sensor.mapped_field;
                    }
                }, 100);
            }
            
            if (sensor.data_transform) {
                document.getElementById('data-transform').value = sensor.data_transform;
            }
            
            // Change the form to edit mode
            this.editingSensorId = sensorId;
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.textContent = 'Update Sensor';
            }
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth' });
            
            this.showNotification('Editing sensor configuration', 'info');
            
        } catch (error) {
            console.error('Error loading sensor for edit:', error);
            this.showNotification('Failed to load sensor for editing', 'error');
        }
    }

    updateFieldMappingOptions(selectedTable) {
        const fieldSelect = document.getElementById('mapped-field');
        if (!fieldSelect) return;

        // Clear existing options
        fieldSelect.innerHTML = '<option value="">Select field</option>';
        
        if (!selectedTable) {
            fieldSelect.disabled = true;
            return;
        }

        fieldSelect.disabled = false;

        // Define available fields for each table
        const fieldMappings = {
            nutrient_readings: {
                'ph': 'pH Level',
                'ec': 'Electrical Conductivity (mS/cm)',
                'dissolved_oxygen': 'Dissolved Oxygen (mg/L)',
                'temperature': 'Water Temperature (¬∞C)',
                'ammonia': 'Ammonia (mg/L)',
                'nitrite': 'Nitrite (mg/L)',
                'nitrate': 'Nitrate (mg/L)',
                'iron': 'Iron (mg/L)',
                'potassium': 'Potassium (mg/L)',
                'calcium': 'Calcium (mg/L)',
                'phosphorus': 'Phosphorus (mg/L)',
                'magnesium': 'Magnesium (mg/L)',
                'humidity': 'Humidity (%)',
                'salinity': 'Salinity (ppt)'
            },
            fish_health: {
                'count': 'Fish Count',
                'mortality': 'Fish Mortality',
                'average_weight': 'Average Weight (g)',
                'feed_consumption': 'Feed Consumption (g)'
            }
        };

        const fields = fieldMappings[selectedTable];
        if (fields) {
            Object.entries(fields).forEach(([value, label]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = label;
                fieldSelect.appendChild(option);
            });
        }

        this.updateMappingPreview();
    }

    updateMappingPreview() {
        const tableSelect = document.getElementById('mapped-table');
        const fieldSelect = document.getElementById('mapped-field');
        const transformSelect = document.getElementById('data-transform');
        const preview = document.getElementById('mapping-preview');
        const description = document.getElementById('mapping-description');

        if (!tableSelect || !fieldSelect || !transformSelect || !preview || !description) return;

        const table = tableSelect.value;
        const field = fieldSelect.value;
        const transform = transformSelect.value;

        if (!table || !field) {
            preview.style.display = 'none';
            return;
        }

        let text = `Sensor data will be automatically saved to "${tableSelect.options[tableSelect.selectedIndex].text}" ‚Üí "${fieldSelect.options[fieldSelect.selectedIndex].text}"`;
        
        if (transform) {
            const transformLabels = {
                'celsius_to_fahrenheit': '(converted from ¬∞C to ¬∞F)',
                'fahrenheit_to_celsius': '(converted from ¬∞F to ¬∞C)',
                'multiply_100': '(multiplied by 100)',
                'divide_100': '(divided by 100)'
            };
            text += ` ${transformLabels[transform] || `(${transform})`}`;
        }

        description.textContent = text;
        preview.style.display = 'block';
    }

    // Credentials Management Methods
    async loadCredentialsStatus() {
        this.setupCredentialsEventListeners();
        await this.checkCredentialsStatus();
    }

    setupCredentialsEventListeners() {
        // ThingsBoard credentials form submission
        const tbCredentialsForm = document.getElementById('thingsboard-credentials-form');
        if (tbCredentialsForm) {
            tbCredentialsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.saveThingsBoardCredentials();
            });
        }

        // Test credentials button
        const testCredentialsBtn = document.getElementById('test-tb-credentials');
        if (testCredentialsBtn) {
            testCredentialsBtn.addEventListener('click', async () => {
                await this.testThingsBoardCredentials();
            });
        }
    }

    async checkCredentialsStatus() {
        if (!this.activeSystemId) return;

        try {
            const data = await this.makeApiCall(`/credentials/system/${this.activeSystemId}`);
            const tbCredentials = data.credentials.find(cred => cred.service_name === 'thingsboard');
            
            const statusElement = document.getElementById('tb-status');
            const lastUpdatedElement = document.getElementById('tb-last-updated');
            const testBtn = document.getElementById('test-tb-credentials');
            
            if (tbCredentials) {
                statusElement.textContent = 'Configured';
                statusElement.style.color = '#28a745';
                lastUpdatedElement.textContent = new Date(tbCredentials.updated_at || tbCredentials.created_at).toLocaleString();
                
                // Enable test button and update its text
                if (testBtn) {
                    testBtn.disabled = false;
                    testBtn.textContent = 'Test Saved Credentials';
                    testBtn.title = 'Test the credentials that are currently saved in the database';
                }
                
                // Pre-populate the API URL if available
                const apiUrlField = document.getElementById('tb-api-url');
                if (apiUrlField && tbCredentials.api_url) {
                    apiUrlField.value = tbCredentials.api_url;
                }
            } else {
                statusElement.textContent = 'Not configured';
                statusElement.style.color = '#dc3545';
                lastUpdatedElement.textContent = 'Never';
                
                // Disable test button and update its text
                if (testBtn) {
                    testBtn.disabled = true;
                    testBtn.textContent = 'Save Credentials First';
                    testBtn.title = 'You must save credentials before testing them';
                }
            }
            
        } catch (error) {
            console.error('Error checking credentials status:', error);
            const statusElement = document.getElementById('tb-status');
            const testBtn = document.getElementById('test-tb-credentials');
            
            if (statusElement) {
                statusElement.textContent = 'Error loading status';
                statusElement.style.color = '#dc3545';
            }
            
            if (testBtn) {
                testBtn.disabled = true;
                testBtn.textContent = 'Error - Cannot Test';
                testBtn.title = 'Error loading credential status';
            }
        }
    }

    async saveThingsBoardCredentials() {
        const form = document.getElementById('thingsboard-credentials-form');
        const formData = new FormData(form);
        
        const credentialsData = {
            system_id: this.activeSystemId,
            service_name: 'thingsboard',
            api_url: formData.get('api_url'),
            username: formData.get('username'),
            password: formData.get('password')
        };

        if (!credentialsData.username || !credentialsData.password) {
            this.showNotification('Please enter both username and password', 'error');
            return;
        }

        const saveBtn = form.querySelector('button[type="submit"]');
        const originalText = saveBtn.textContent;
        saveBtn.textContent = 'Saving...';
        saveBtn.disabled = true;

        try {
            await this.makeApiCall('/credentials', {
                method: 'POST',
                body: JSON.stringify(credentialsData)
            });
            
            this.showNotification('ThingsBoard credentials saved successfully!', 'success');
            
            // Clear password field for security
            document.getElementById('tb-password').value = '';
            
            // Refresh status
            await this.checkCredentialsStatus();
            
        } catch (error) {
            console.error('Error saving credentials:', error);
            const errorMessage = error.response?.error || error.message || 'Failed to save credentials';
            this.showNotification(errorMessage, 'error');
        } finally {
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
        }
    }

    async testThingsBoardCredentials() {
        const testBtn = document.getElementById('test-tb-credentials');
        const originalText = testBtn.textContent;
        testBtn.textContent = 'Testing...';
        testBtn.disabled = true;

        try {
            // First check if credentials are saved
            const result = await this.makeApiCall(`/credentials/thingsboard/status/${this.activeSystemId}`);
            
            if (!result.configured) {
                this.showNotification('Please save your ThingsBoard credentials before testing', 'warning');
                return;
            }

            // Test the saved credentials
            if (result.connected) {
                this.showNotification(`‚úÖ ThingsBoard connection successful! Connected to: ${result.api_url}`, 'success', 5000);
            } else {
                this.showNotification(`‚ùå ${result.message}`, 'error', 8000);
            }

        } catch (error) {
            console.error('Error testing credentials:', error);
            const errorMessage = error.response?.error || error.message || 'Authentication test failed';
            this.showNotification(`‚ùå ${errorMessage}`, 'error');
        } finally {
            testBtn.textContent = originalText;
            testBtn.disabled = false;
        }
    }

    // Dashboard metrics configuration functions
    openMetricsConfig() {

        const modal = document.getElementById('metrics-config-modal');

        if (modal) {
            modal.style.display = 'block';
            this.loadMetricPreferences();
        } else {
            console.error('Metrics config modal not found in DOM');
        }
    }

    closeMetricsConfig() {
        const modal = document.getElementById('metrics-config-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    loadMetricPreferences() {
        const preferences = this.getMetricPreferences();
        
        // Update checkboxes based on saved preferences
        const checkboxes = document.querySelectorAll('#metrics-config-modal input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            const metric = checkbox.value;
            checkbox.checked = preferences[metric] !== false; // Default to true if not specified
        });
    }

    saveMetricsConfig() {
        const checkboxes = document.querySelectorAll('#metrics-config-modal input[type="checkbox"]');
        const preferences = {};
        
        checkboxes.forEach(checkbox => {
            preferences[checkbox.value] = checkbox.checked;
        });
        
        // Save to localStorage
        localStorage.setItem('dashboardMetricPreferences', JSON.stringify(preferences));
        
        // Apply the preferences immediately
        this.applyMetricPreferences();
        
        // Close the modal
        this.closeMetricsConfig();
        
        // Show success notification
        this.showNotification('Dashboard metrics updated successfully', 'success');
    }

    getMetricPreferences() {
        const saved = localStorage.getItem('dashboardMetricPreferences');
        if (saved) {
            return JSON.parse(saved);
        }
        
        // Default preferences - all available dashboard metrics visible
        return {
            temperature: true,
            ph: true,
            dissolved_oxygen: true,
            ammonia: true,
            ec: true,
            humidity: true,
            salinity: true,
            nitrate: true,
            nitrite: true,
            phosphorus: true,
            potassium: true,
            calcium: true,
            magnesium: true,
            iron: true
        };
    }

    applyMetricPreferences() {
        const preferences = this.getMetricPreferences();

        // Show/hide chart cards based on preferences
        Object.keys(preferences).forEach(metric => {
            const chartCard = document.querySelector(`[data-metric="${metric}"]`);

            if (chartCard) {
                if (preferences[metric]) {
                    chartCard.style.display = '';
                } else {
                    chartCard.style.display = 'none';
                }
            }
        });
    }

    initializeMetricPreferences() {
        // Apply saved preferences on page load
        this.applyMetricPreferences();
    }

    initializeSensorConfigTabs() {
        const sensorTabs = document.querySelectorAll('.sensor-tab');
        const sensorTabContents = document.querySelectorAll('.sensor-tab-content');

        sensorTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = tab.getAttribute('data-target');

                // Remove active class from all tabs and contents
                sensorTabs.forEach(t => t.classList.remove('active'));
                sensorTabContents.forEach(content => content.classList.remove('active'));

                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const targetContent = document.getElementById(targetId);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            });
        });
    }
    
    // Load plants management subtab
    async loadPlantsManagement() {
        const container = document.getElementById('plants-container');
        if (!container) return;
        
        try {
            // Fetch plant data
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            const growBeds = await this.makeApiCall(`/grow-beds/system/${this.activeSystemId}`);
            
            // Process and group plant data
            const plantGroups = this.processPlantData(plantData, growBeds);
            
            // Update summary statistics
            this.updatePlantStatistics(plantGroups);
            
            // Generate and display plant groups
            const plantsHTML = this.generatePlantGroupsHTML(plantGroups);
            container.innerHTML = plantsHTML;
            
            // Initialize plant management features
            this.initializePlantManagementFeatures();
            
        } catch (error) {
            console.error('Error loading plants management:', error);
            container.innerHTML = '<div class="error-message">Failed to load plants data. Please try again.</div>';
        }
    }
    
    // Process plant data into groups - use same logic as generateUnifiedBedOverview for consistency
    processPlantData(plantData, growBeds) {
        // Create batch map first, like generateUnifiedBedOverview does
        const batchMap = new Map();
        
        plantData.forEach(entry => {
            if (entry.batch_id && entry.crop_type) {
                const key = `${entry.grow_bed_id}-${entry.batch_id}`;
                if (!batchMap.has(key)) {
                    batchMap.set(key, {
                        batchId: entry.batch_id,
                        cropType: entry.crop_type,
                        growBedId: entry.grow_bed_id,
                        dateFirst: entry.date,
                        plantCount: 0,
                        harvestedCount: 0,
                        seedVariety: entry.seed_variety || '',
                        daysToHarvest: entry.days_to_harvest || null,
                        entries: []
                    });
                }
                
                const batch = batchMap.get(key);
                batch.entries.push(entry);
                
                // Process plant counts exactly like generateUnifiedBedOverview
                if (entry.new_seedlings > 0) {
                    batch.plantCount += entry.new_seedlings;
                }
                if (entry.plants_harvested > 0) {
                    batch.harvestedCount += entry.plants_harvested;
                }
            }
        });
        
        // Now group batches by crop type for the Plants tab display
        const plantGroups = new Map();
        const bedMap = new Map();
        growBeds.forEach(bed => {
            bedMap.set(bed.id, bed);
        });
        
        batchMap.forEach(batchData => {
            const cropType = batchData.cropType;
            
            if (!plantGroups.has(cropType)) {
                plantGroups.set(cropType, {
                    cropType: cropType,
                    totalQuantity: 0,
                    batches: [],
                    harvestReadyCount: 0,
                    avgDaysToMaturity: 0
                });
            }
            
            const group = plantGroups.get(cropType);
            
            // Calculate remaining plants for this batch
            const remainingPlants = Math.max(0, batchData.plantCount - batchData.harvestedCount);
            
            // Only include batches with remaining plants
            if (remainingPlants > 0) {
                const batch = {
                    batchId: batchData.batchId,
                    batchKey: `${batchData.growBedId}-${batchData.batchId}`,
                    growBedId: batchData.growBedId,
                    plantingDate: batchData.dateFirst,
                    quantity: remainingPlants,
                    growthStage: 'seedling', // Default
                    location: bedMap.get(batchData.growBedId)?.name || bedMap.get(batchData.growBedId)?.bed_name || `Bed ${batchData.growBedId}`,
                    daysToHarvest: batchData.daysToHarvest || 30,
                    seedVariety: batchData.seedVariety || 'Standard',
                    entries: batchData.entries
                };
                
                // Calculate age and harvest ready status
                const plantingDate = new Date(batch.plantingDate);
                const currentDate = new Date();
                const ageInDays = Math.floor((currentDate - plantingDate) / (1000 * 60 * 60 * 24));
                batch.ageInDays = ageInDays;
                
                if (ageInDays >= batch.daysToHarvest) {
                    batch.isHarvestReady = true;
                    group.harvestReadyCount += batch.quantity;
                    batch.growthStage = 'harvest-ready';
                }
                
                // Calculate expected harvest date
                const expectedHarvestDate = new Date(plantingDate);
                expectedHarvestDate.setDate(expectedHarvestDate.getDate() + batch.daysToHarvest);
                batch.expectedHarvestDate = expectedHarvestDate;
                
                group.batches.push(batch);
                group.totalQuantity += batch.quantity;
            }
        });
        
        // Calculate average days to maturity for each group
        plantGroups.forEach(group => {
            if (group.batches.length > 0) {
                const totalDays = group.batches.reduce((sum, batch) => sum + batch.daysToHarvest, 0);
                group.avgDaysToMaturity = Math.round(totalDays / group.batches.length);
                
                // Sort batches by planting date (oldest first)
                group.batches.sort((a, b) => new Date(a.plantingDate) - new Date(b.plantingDate));
            }
        });
        
        // Filter out empty groups
        const activePlantGroups = new Map();
        plantGroups.forEach((group, cropType) => {
            if (group.batches.length > 0) {
                activePlantGroups.set(cropType, group);
            }
        });
        
        return activePlantGroups;
    }
    
    // Update plant statistics in the UI
    updatePlantStatistics(plantGroups) {
        let totalPlants = 0;
        let totalBatches = 0;
        let harvestReady = 0;
        let plantTypes = plantGroups.size;
        
        plantGroups.forEach(group => {
            totalPlants += group.totalQuantity;
            totalBatches += group.batches.length;
            harvestReady += group.harvestReadyCount;
        });
        
        // Update the statistics display
        const totalPlantsEl = document.getElementById('total-plants-count');
        const totalBatchesEl = document.getElementById('total-batches-count');
        const harvestReadyEl = document.getElementById('harvest-ready-count');
        const plantTypesEl = document.getElementById('plant-types-count');
        
        if (totalPlantsEl) totalPlantsEl.textContent = totalPlants;
        if (totalBatchesEl) totalBatchesEl.textContent = totalBatches;
        if (harvestReadyEl) harvestReadyEl.textContent = harvestReady;
        if (plantTypesEl) plantTypesEl.textContent = plantTypes;
    }
    
    // Generate HTML for plant groups
    generatePlantGroupsHTML(plantGroups) {
        if (plantGroups.size === 0) {
            return '<div class="no-plants-message">No plants currently in the system. Click "Quick Plant" to add some!</div>';
        }
        
        let html = '';
        
        plantGroups.forEach((group, cropType) => {
            const icon = this.getPlantIcon(cropType);
            const groupId = cropType.replace(/\s+/g, '_');
            
            html += `
                <div class="plant-group-card" data-crop-type="${cropType}">
                    <div class="plant-group-header" onclick="window.app.togglePlantGroup('${groupId}')">
                        <div class="plant-type-info">
                            <div class="plant-type-icon">${icon}</div>
                            <div class="plant-type-details">
                                <h3>${this.formatCropName(cropType)}</h3>
                                <div class="plant-type-summary">
                                    <div class="summary-item">
                                        <span>Total:</span>
                                        <strong>${group.totalQuantity}</strong>
                                    </div>
                                    <div class="summary-item">
                                        <span>Batches:</span>
                                        <strong>${group.batches.length}</strong>
                                    </div>
                                    ${group.harvestReadyCount > 0 ? `
                                    <div class="summary-item" style="color: #28a745;">
                                        <span>Ready:</span>
                                        <strong>${group.harvestReadyCount}</strong>
                                    </div>` : ''}
                                    <div class="summary-item">
                                        <span>Avg. Days:</span>
                                        <strong>${group.avgDaysToMaturity}</strong>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="plant-group-actions">
                            <button class="plant-harvest-btn" onclick="event.stopPropagation(); window.app.quickHarvestGroup('${cropType}')" title="Harvest ${this.formatCropName(cropType)}">
                                üåæ Harvest
                            </button>
                            ${group.harvestReadyCount > 0 ? `
                            <button class="ready-harvest-btn" onclick="event.stopPropagation(); window.app.quickHarvestGroup('${cropType}')" title="${group.harvestReadyCount} plants ready">
                                üåæ Ready (${group.harvestReadyCount})
                            </button>` : ''}
                            <button class="expand-toggle" id="toggle-${groupId}">
                                ‚ñº
                            </button>
                        </div>
                    </div>
                    <div class="plant-group-content" id="group-${groupId}">
                        <div class="batch-table-container">
                            ${this.generateBatchTable(group.batches)}
                        </div>
                    </div>
                </div>
            `;
        });
        
        return html;
    }
    
    // Generate batch table HTML
    generateBatchTable(batches) {
        if (batches.length === 0) {
            return '<div class="no-batches-message">No batches for this crop type</div>';
        }
        
        return `
            <div class="batch-table">
                <div class="batch-table-header">
                    <div class="batch-col-id">Batch ID</div>
                    <div class="batch-col-variety">Variety</div>
                    <div class="batch-col-location">Location</div>
                    <div class="batch-col-age">Age</div>
                    <div class="batch-col-quantity">Quantity</div>
                    <div class="batch-col-progress">Progress</div>
                    <div class="batch-col-harvest">Expected Harvest</div>
                    <div class="batch-col-actions">Actions</div>
                </div>
                <div class="batch-table-body">
                    ${batches.map(batch => {
                        const growthProgress = Math.min(100, Math.round((batch.ageInDays / batch.daysToHarvest) * 100));
                        const isReady = batch.isHarvestReady;
                        
                        return `
                            <div class="batch-row ${isReady ? 'harvest-ready' : ''}" data-batch-id="${batch.batchId}">
                                <div class="batch-col-id">
                                    <span class="batch-id-label" title="${batch.batchId}">${batch.batchId.length > 8 ? batch.batchId.substring(0, 8) + '...' : batch.batchId}</span>
                                </div>
                                <div class="batch-col-variety">${batch.seedVariety}</div>
                                <div class="batch-col-location">${batch.location}</div>
                                <div class="batch-col-age">${batch.ageInDays} days</div>
                                <div class="batch-col-quantity">${batch.quantity} plants</div>
                                <div class="batch-col-progress">
                                    <div class="progress-container">
                                        <div class="progress-bar-mini">
                                            <div class="progress-fill-mini" style="width: ${growthProgress}%"></div>
                                        </div>
                                        <span class="progress-text">${growthProgress}%</span>
                                    </div>
                                </div>
                                <div class="batch-col-harvest">${this.formatDate(batch.expectedHarvestDate)}</div>
                                <div class="batch-col-actions">
                                    <div class="action-buttons-mini">
                                        ${isReady ? `
                                        <button class="action-btn-mini harvest" onclick="window.app.harvestBatch('${batch.batchId}')" title="Harvest">
                                            üåæ
                                        </button>` : ''}
                                        <button class="action-btn-mini" onclick="window.app.viewBatchDetails('${batch.batchId}')" title="Details">
                                            üìä
                                        </button>
                                        <button class="action-btn-mini" onclick="window.app.editBatch('${batch.batchId}')" title="Edit">
                                            ‚úèÔ∏è
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
    }
    
    // Get plant icon based on crop type
    getPlantIcon(cropType) {
        const icons = {
            'lettuce': 'ü•¨',
            'tomato': 'üçÖ',
            'tomatoes': 'üçÖ',
            'herb': 'üåø',
            'herbs': 'üåø',
            'basil': 'üåø',
            'spinach': 'ü•¨',
            'kale': 'ü•¨',
            'pepper': 'üå∂Ô∏è',
            'peppers': 'üå∂Ô∏è',
            'cucumber': 'ü•í',
            'strawberry': 'üçì',
            'strawberries': 'üçì',
            'carrot': 'ü•ï',
            'carrots': 'ü•ï'
        };
        
        const lowerCrop = cropType.toLowerCase();
        return icons[lowerCrop] || 'üå±';
    }
    
    // Format crop name for display
    formatCropName(cropType) {
        return cropType.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }
    
    // Format date for display
    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric', 
            year: 'numeric' 
        });
    }
    
    // Toggle plant group expansion
    togglePlantGroup(groupId) {
        const content = document.getElementById(`group-${groupId}`);
        const toggle = document.getElementById(`toggle-${groupId}`);
        
        if (content && toggle) {
            content.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
    }
    
    // Initialize plant management features
    initializePlantManagementFeatures() {
        // Search functionality
        const searchInput = document.getElementById('plants-search');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterPlants(e.target.value);
            });
        }
        
        // Filter functionality
        const filterSelect = document.getElementById('plants-filter');
        if (filterSelect) {
            filterSelect.addEventListener('change', (e) => {
                this.filterPlantsByStage(e.target.value);
            });
        }
        
        // Main action buttons
        const newPlantingBtn = document.getElementById('new-planting-btn');
        if (newPlantingBtn) {
            newPlantingBtn.addEventListener('click', () => {
                this.openNewPlantingAction();
            });
        }
        
        const harvestReadyBtn = document.getElementById('harvest-ready-btn');
        if (harvestReadyBtn) {
            harvestReadyBtn.addEventListener('click', () => {
                this.openHarvestReadyAction();
            });
        }
        
        const batchManagementBtn = document.getElementById('batch-management-btn');
        if (batchManagementBtn) {
            batchManagementBtn.addEventListener('click', () => {
                this.openBatchManagementAction();
            });
        }
        
        // Export button
        const exportBtn = document.getElementById('export-plants-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.exportPlantData();
            });
        }
    }
    
    // Filter plants by search text
    filterPlants(searchText) {
        const cards = document.querySelectorAll('.plant-group-card');
        const lowerSearch = searchText.toLowerCase();
        
        cards.forEach(card => {
            const cropType = card.dataset.cropType.toLowerCase();
            const shouldShow = cropType.includes(lowerSearch);
            card.style.display = shouldShow ? 'block' : 'none';
        });
    }
    
    // Filter plants by growth stage
    filterPlantsByStage(stage) {
        const batchRows = document.querySelectorAll('.batch-row');
        const plantGroups = document.querySelectorAll('.plant-group-card');
        
        batchRows.forEach(row => {
            if (stage === 'all') {
                row.style.display = 'grid';
            } else if (stage === 'harvest-ready') {
                row.style.display = row.classList.contains('harvest-ready') ? 'grid' : 'none';
            } else {
                // For other stages, we'd need to check growth stage data
                // Since we removed the stage column, we'll default to showing all for now
                row.style.display = 'grid';
            }
        });
        
        // Show/hide plant groups based on whether they have visible batches
        plantGroups.forEach(group => {
            const visibleBatches = group.querySelectorAll('.batch-row[style*="grid"], .batch-row:not([style*="none"])');
            if (stage === 'all') {
                group.style.display = 'block';
            } else {
                // Show group only if it has visible batches after filtering
                const hasVisibleBatches = Array.from(group.querySelectorAll('.batch-row')).some(row => {
                    return !row.style.display || row.style.display === 'grid';
                });
                group.style.display = hasVisibleBatches ? 'block' : 'none';
            }
        });
    }
    
    // Main action methods
    openNewPlantingAction() {
        // Switch to the Plant & Harvest tab and activate planting
        this.switchPlantTab('planting-harvesting-tab');
        
        // Small delay to ensure tab is loaded, then activate planting tab
        setTimeout(() => {
            const plantingTab = document.getElementById('planting-tab');
            if (plantingTab) {
                plantingTab.click();
            }
        }, 100);
        
        this.showNotification('Switched to planting form - add your new crops!', 'success');
    }
    
    openHarvestReadyAction() {
        // Filter to show only harvest-ready batches
        const filterSelect = document.getElementById('plants-filter');
        if (filterSelect) {
            filterSelect.value = 'harvest-ready';
            filterSelect.dispatchEvent(new Event('change'));
        }
        
        // Count harvest-ready batches
        const harvestReadyCount = document.getElementById('harvest-ready-count');
        const count = harvestReadyCount ? harvestReadyCount.textContent : '0';
        
        if (count === '0') {
            this.showNotification('No crops are ready for harvest yet', 'info');
        } else {
            this.showNotification(`Filtered to show ${count} harvest-ready plants`, 'success');
            
            // Scroll to first harvest-ready batch
            setTimeout(() => {
                const firstHarvestReady = document.querySelector('.batch-row.harvest-ready');
                if (firstHarvestReady) {
                    firstHarvestReady.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 300);
        }
    }
    
    openBatchManagementAction() {
        // Expand all plant groups to show all batches
        document.querySelectorAll('.plant-group-header').forEach(header => {
            const groupId = header.getAttribute('onclick')?.match(/'([^']+)'/)?.[1];
            if (groupId) {
                const content = document.getElementById(`group-${groupId}`);
                const toggle = document.getElementById(`toggle-${groupId}`);
                if (content && !content.classList.contains('expanded')) {
                    content.classList.add('expanded');
                    toggle?.classList.add('expanded');
                }
            }
        });
        
        // Reset filter to show all batches
        const filterSelect = document.getElementById('plants-filter');
        if (filterSelect) {
            filterSelect.value = 'all';
            filterSelect.dispatchEvent(new Event('change'));
        }
        
        this.showNotification('Showing all batches for comprehensive management', 'success');
    }
    
    async exportPlantData() {
        try {
            this.showNotification('üìÑ Preparing plant data export...', 'info');
            
            // Fetch all plant data
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            if (!plantData || plantData.length === 0) {
                this.showNotification('‚ùå No plant data to export', 'error');
                return;
            }
            
            // Define CSV headers - include all important fields
            const headers = [
                'ID',
                'Date',
                'Grow Bed ID', 
                'Batch ID',
                'Crop Type',
                'Seed Variety',
                'New Seedlings',
                'Plants Harvested',
                'Harvest Weight (g)',
                'Growth Stage',
                'Health',
                'Pest Control',
                'Days to Harvest',
                'Batch Created Date',
                'Notes',
                'Created At'
            ];
            
            // Convert data to CSV rows
            const csvRows = [
                headers.join(','), // Header row
                ...plantData.map(entry => [
                    entry.id || '',
                    entry.date || '',
                    entry.grow_bed_id || '',
                    entry.batch_id || '',
                    entry.crop_type || '',
                    entry.seed_variety || '',
                    entry.new_seedlings || 0,
                    entry.plants_harvested || 0,
                    entry.harvest_weight || 0,
                    entry.growth_stage || '',
                    entry.health || '',
                    entry.pest_control || '',
                    entry.days_to_harvest || '',
                    entry.batch_created_date || '',
                    `"${(entry.notes || '').replace(/"/g, '""')}"`, // Escape quotes in notes
                    entry.created_at || ''
                ].join(','))
            ];
            
            // Create CSV content
            const csvContent = csvRows.join('\n');
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            
            // Generate filename with current date
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD format
            const filename = `plant_data_${this.activeSystemId}_${dateStr}.csv`;
            
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            this.showNotification(`‚úÖ Plant data exported successfully! (${plantData.length} records)`, 'success');
            
        } catch (error) {
            console.error('Error exporting plant data:', error);
            this.showNotification('‚ùå Failed to export plant data', 'error');
        }
    }
    
    async quickHarvestGroup(cropType) {
        // Show crop group harvest selection modal instead of switching tabs
        try {
            await this.showCropGroupHarvestModal(cropType);
        } catch (error) {
            console.error('Quick harvest group error:', error);
            this.showNotification('‚ùå Could not open harvest options', 'error');
        }
    }
    
    async showCropGroupHarvestModal(cropType) {
        try {
            // Get plant data to find all batches for this crop type
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            // Find all harvestable batches for this crop type - calculate remaining plants properly
            const batchMap = new Map();
            plantData.forEach(entry => {
                if (entry.batch_id && entry.crop_type === cropType) {
                    const key = entry.batch_id;
                    if (!batchMap.has(key)) {
                        batchMap.set(key, {
                            batchId: entry.batch_id,
                            cropType: entry.crop_type,
                            growBedId: entry.grow_bed_id,
                            plantedCount: 0,
                            harvestedCount: 0,
                            datePlanted: entry.date
                        });
                    }
                    
                    const batch = batchMap.get(key);
                    // Accumulate planted and harvested counts
                    if (entry.new_seedlings > 0) {
                        batch.plantedCount += entry.new_seedlings;
                    }
                    if (entry.plants_harvested > 0) {
                        batch.harvestedCount += entry.plants_harvested;
                    }
                }
            });
            
            // Filter to only batches with remaining plants and calculate remaining
            const availableBatches = [];
            batchMap.forEach(batch => {
                const remainingPlants = Math.max(0, batch.plantedCount - batch.harvestedCount);
                if (remainingPlants > 0) {
                    batch.remainingPlants = remainingPlants;
                    availableBatches.push(batch);
                }
            });
            
            if (availableBatches.length === 0) {
                this.showNotification(`No harvestable batches found for ${this.formatCropName(cropType)}`, 'warning');
                return;
            }
            
            if (availableBatches.length === 1) {
                // Single batch - show harvest modal directly
                const batch = availableBatches[0];
                this.showInlineHarvestModal(batch.batchId, batch.cropType, batch.growBedId, batch.remainingPlants);
            } else {
                // Multiple batches - show selection modal
                this.showBatchSelectionModal(cropType, availableBatches);
            }
        } catch (error) {
            console.error('Error loading crop group batches:', error);
            this.showNotification('‚ùå Could not load harvest options', 'error');
        }
    }
    
    showBatchSelectionModal(cropType, batches) {
        // Hide any existing modals first
        this.hideAllModals();
        
        // Create batch selection modal HTML
        const batchOptions = batches.map(batch => `
            <div class="batch-option" onclick="window.app.selectBatchForHarvest('${batch.batchId}', '${batch.cropType}', ${batch.growBedId}, ${batch.remainingPlants})">
                <div class="batch-info">
                    <strong>Batch ${batch.batchId}</strong> - Grow Bed ${batch.growBedId}
                </div>
                <div class="batch-details">
                    ${batch.remainingPlants} plants available ‚Ä¢ Planted: ${new Date(batch.datePlanted).toLocaleDateString()}
                </div>
            </div>
        `).join('');
        
        const modalHtml = `
            <div class="inline-harvest-modal" id="batch-selection-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üåæ Select Batch to Harvest</h3>
                        <button class="modal-close" onclick="window.app.hideBatchSelectionModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p><strong>Crop:</strong> ${this.formatCropName(cropType)}</p>
                        <p>Select which batch you want to harvest:</p>
                        <div class="batch-options">
                            ${batchOptions}
                        </div>
                        <div class="form-actions" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #ddd;">
                            <button type="button" class="btn-cancel" onclick="window.app.hideBatchSelectionModal()">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = document.getElementById('batch-selection-modal');
        modal.style.display = 'flex';
        
        // Add ESC key support to close modal
        const handleEscKey = (e) => {
            if (e.key === 'Escape') {
                this.hideBatchSelectionModal();
                document.removeEventListener('keydown', handleEscKey);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click-outside-to-close support
        modal.onclick = (e) => {
            if (e.target === modal) {
                this.hideBatchSelectionModal();
            }
        };
    }
    
    selectBatchForHarvest(batchId, cropType, growBedId, remainingPlants) {
        this.hideBatchSelectionModal();
        this.showInlineHarvestModal(batchId, cropType, growBedId, remainingPlants);
    }
    
    hideBatchSelectionModal() {
        const modal = document.getElementById('batch-selection-modal');
        if (modal) {
            modal.remove();
        }
    }
    
    harvestBatch(batchId) {
        // For single parameter calls, we need to get batch details first
        this.showInlineHarvestForBatch(batchId);
    }
    
    async showInlineHarvestForBatch(batchId) {
        try {
            // Get plant data to find batch details
            const plantData = await this.makeApiCall(`/data/plant-growth/${this.activeSystemId}`);
            
            // Calculate batch totals properly
            let batchInfo = null;
            let plantedCount = 0;
            let harvestedCount = 0;
            
            for (const entry of plantData) {
                if (entry.batch_id === batchId) {
                    if (!batchInfo) {
                        batchInfo = {
                            batchId: batchId,
                            cropType: entry.crop_type,
                            growBedId: entry.grow_bed_id
                        };
                    }
                    
                    // Accumulate planted and harvested counts
                    if (entry.new_seedlings > 0) {
                        plantedCount += entry.new_seedlings;
                    }
                    if (entry.plants_harvested > 0) {
                        harvestedCount += entry.plants_harvested;
                    }
                }
            }
            
            if (batchInfo) {
                const remainingPlants = Math.max(0, plantedCount - harvestedCount);
                if (remainingPlants > 0) {
                    this.showInlineHarvestModal(batchInfo.batchId, batchInfo.cropType, batchInfo.growBedId, remainingPlants);
                } else {
                    this.showNotification('‚ùå No plants remaining in this batch to harvest', 'warning');
                }
            } else {
                this.showNotification('‚ùå Could not find batch details', 'error');
            }
        } catch (error) {
            console.error('Error getting batch details:', error);
            this.showNotification('‚ùå Could not load batch details', 'error');
        }
    }
    
    viewBatchDetails(batchId) {
        this.showNotification(`View details for batch ${batchId} - coming soon!`, 'info');
    }
    
    editBatch(batchId) {
        this.showNotification(`Edit batch ${batchId} - coming soon!`, 'info');
    }
    
    // ========== DEFICIENCY IMAGE FILTERING SYSTEM ==========

    // Load all deficiency images (default state)
    async loadAllDeficiencyImages() {
        console.log('üì∏ Loading all deficiency images...');
        
        try {
            const url = `/api/crop-knowledge/admin/deficiency-images?nocache=${Date.now()}`;
            console.log('üåê Fetching deficiency images from:', url);
            
            const response = await fetch(url, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                }
            });
            
            console.log('üåê API response status:', response.status);
            console.log('üåê API response ok:', response.ok);
            
            const data = await response.json();
            console.log('üåê API response data:', data);
            
            if (data.success) {
                // Update header to show all images
                const header = document.getElementById('deficiency-header');
                const grid = document.getElementById('deficiency-images-grid');
                const noSelection = document.getElementById('no-nutrient-selected');
                const title = document.getElementById('selected-nutrient-title');
                
                if (header) header.style.display = 'flex';
                if (grid) grid.style.display = 'grid';
                if (noSelection) noSelection.style.display = 'none';
                if (title) title.textContent = `All Deficiency Images (${data.count})`;
                
                // Store all images for filtering
                this.allDeficiencyImages = data.data || [];
                
                // Display all images
                this.populateDeficiencyImagesGrid(this.allDeficiencyImages);
                
                // Populate filter dropdowns
                await this.populateDeficiencyFilters(this.allDeficiencyImages);
                
            } else {
                this.showNotification('Failed to load deficiency images', 'error');
            }
            
        } catch (error) {
            console.error('Error loading all deficiency images:', error);
            this.showNotification('Error loading deficiency images', 'error');
        }
    }

    // Populate filter dropdowns with available options
    async populateDeficiencyFilters(images) {
        const nutrientFilter = document.getElementById('deficiency-nutrient-filter');
        const plantFilter = document.getElementById('deficiency-plant-filter');
        
        if (!nutrientFilter || !plantFilter) return;
        
        console.log('üîç Debug: All images data:', images);
        console.log('üîç Debug: Sample image structure:', images[0]);
        if (images[0]) {
            console.log('üîç Debug: crop_name field value:', images[0].crop_name);
            console.log('üîç Debug: plant_id field value:', images[0].plant_id);
        }
        
        // Get unique nutrients from images
        const nutrients = [...new Set(images.map(img => ({
            code: img.nutrient_code,
            name: img.nutrient_name
        })).filter(n => n.code))];
        
        // Populate nutrient dropdown
        nutrientFilter.innerHTML = '<option value="">All nutrients</option>';
        nutrients.forEach(nutrient => {
            const option = document.createElement('option');
            option.value = nutrient.code;
            option.textContent = `${nutrient.code} - ${nutrient.name}`;
            nutrientFilter.appendChild(option);
        });
        
        // Load all available plants from crops API (same as modal dropdown)
        try {
            console.log('üå± Loading all crops for plant filter...');
            const response = await fetch('/api/crop-knowledge/crops');
            
            if (response.ok) {
                const cropsData = await response.json();
                
                if (cropsData.success && cropsData.data) {
                    // Populate plant dropdown with all available crops
                    plantFilter.innerHTML = '<option value="">All plants</option>';
                    cropsData.data.forEach(crop => {
                        const option = document.createElement('option');
                        option.value = crop.id;
                        option.textContent = crop.name;
                        plantFilter.appendChild(option);
                    });
                    
                    console.log(`üìä Filter options: ${nutrients.length} nutrients, ${cropsData.data.length} plants`);
                } else {
                    if (window.errorManager) {
                        window.errorManager.warnOnce('no_crops_data', '‚ö†Ô∏è No crops data received from API', this.activeSystemId);
                    } else {
                        console.warn('‚ö†Ô∏è No crops data received from API');
                    }
                    plantFilter.innerHTML = '<option value="">No plants available</option>';
                }
            } else {
                console.warn(`Failed to fetch crops: ${response.status} ${response.statusText}`);
                plantFilter.innerHTML = '<option value="">Error loading plants</option>';
            }
        } catch (error) {
            console.error('Error loading crops for plant filter:', error);
            plantFilter.innerHTML = '<option value="">Error loading plants</option>';
        }
    }

    // Apply filters to deficiency images
    applyDeficiencyFilters() {
        if (!this.allDeficiencyImages) {
            console.log('‚ö†Ô∏è No images loaded yet');
            return;
        }
        
        const nutrientFilter = document.getElementById('deficiency-nutrient-filter');
        const plantFilter = document.getElementById('deficiency-plant-filter');
        
        const selectedNutrient = nutrientFilter?.value || '';
        const selectedPlant = plantFilter?.value || '';
        
        console.log('üîç Applying filters:', { selectedNutrient, selectedPlant });
        console.log('üóÇÔ∏è All images count:', this.allDeficiencyImages?.length || 0);
        console.log('üóÇÔ∏è Sample image data (keys):', Object.keys(this.allDeficiencyImages?.[0] || {}));
        console.log('üóÇÔ∏è All plant_id values:', this.allDeficiencyImages?.map(img => ({ filename: img.image_filename, plant_id: img.plant_id, has_plant_id: 'plant_id' in img })));
        
        let filteredImages = this.allDeficiencyImages;
        
        // Apply nutrient filter
        if (selectedNutrient) {
            const beforeCount = filteredImages.length;
            filteredImages = filteredImages.filter(img => img.nutrient_code === selectedNutrient);
            console.log(`üß™ Nutrient filter '${selectedNutrient}': ${beforeCount} ‚Üí ${filteredImages.length}`);
        }
        
        // Apply plant filter
        if (selectedPlant) {
            const beforeCount = filteredImages.length;
            console.log('üå± Plant filter images before:', filteredImages.map(img => ({ filename: img.image_filename, plant_id: img.plant_id, crop_name: img.crop_name })));
            console.log('üîç Selected plant value:', selectedPlant, 'type:', typeof selectedPlant);
            console.log('üîç Plant IDs in images:', filteredImages.map(img => ({ plant_id: img.plant_id, type: typeof img.plant_id })));
            filteredImages = filteredImages.filter(img => {
                const match = img.plant_id == selectedPlant;
                console.log(`üîç Comparing img.plant_id(${img.plant_id}) == selectedPlant(${selectedPlant}): ${match}`);
                return match;
            });
            console.log(`üå± Plant filter '${selectedPlant}': ${beforeCount} ‚Üí ${filteredImages.length}`);
        }
        
        // Update title to reflect filtering
        const title = document.getElementById('selected-nutrient-title');
        let titleText = 'All Deficiency Images';
        
        if (selectedNutrient && selectedPlant) {
            const nutrientName = nutrientFilter.options[nutrientFilter.selectedIndex].text;
            const plantName = plantFilter.options[plantFilter.selectedIndex].text;
            titleText = `${nutrientName} + ${plantName} (${filteredImages.length})`;
        } else if (selectedNutrient) {
            const nutrientName = nutrientFilter.options[nutrientFilter.selectedIndex].text;
            titleText = `${nutrientName} (${filteredImages.length})`;
        } else if (selectedPlant) {
            const plantName = plantFilter.options[plantFilter.selectedIndex].text;
            titleText = `${plantName} Images (${filteredImages.length})`;
        } else {
            titleText = `All Deficiency Images (${filteredImages.length})`;
        }
        
        if (title) title.textContent = titleText;
        
        // Display filtered images
        this.populateDeficiencyImagesGrid(filteredImages);
        
        console.log(`üîç Filtered to ${filteredImages.length} images (nutrient: ${selectedNutrient || 'all'}, plant: ${selectedPlant || 'all'})`);
    }

    // Clear all filters
    clearDeficiencyFilters() {
        const nutrientFilter = document.getElementById('deficiency-nutrient-filter');
        const plantFilter = document.getElementById('deficiency-plant-filter');
        
        if (nutrientFilter) nutrientFilter.value = '';
        if (plantFilter) plantFilter.value = '';
        
        // Reapply filters (which will show all images)
        this.applyDeficiencyFilters();
        
        console.log('üßπ Filters cleared, showing all images');
    }

    // Lightbox functionality for deficiency images
    openLightbox(imageUrl, caption, nutrientName, cropName) {
        console.log('üñºÔ∏è Opening lightbox for:', imageUrl);
        
        // Get all deficiency images currently displayed for navigation
        const imageElements = document.querySelectorAll('.deficiency-image-preview');
        this.lightboxImages = Array.from(imageElements).map(img => ({
            url: img.src,
            caption: img.alt,
            nutrientName: img.getAttribute('onclick')?.match(/'([^']*)', '[^']*', '([^']*)'/)?.[2] || 'Unknown Nutrient',
            cropName: img.getAttribute('onclick')?.match(/'[^']*', '[^']*', '[^']*', '([^']*)'/)?.[1] || 'No specific crop'
        }));
        
        // Find current image index
        this.currentImageIndex = this.lightboxImages.findIndex(img => img.url === imageUrl);
        if (this.currentImageIndex === -1) this.currentImageIndex = 0;
        
        // Set lightbox content
        const lightbox = document.getElementById('image-lightbox');
        const lightboxImage = document.getElementById('lightbox-image');
        const lightboxTitle = document.getElementById('lightbox-title');
        const lightboxDescription = document.getElementById('lightbox-description');
        
        if (lightbox && lightboxImage && lightboxTitle && lightboxDescription) {
            lightboxImage.src = imageUrl;
            lightboxImage.alt = caption;
            lightboxTitle.textContent = `${nutrientName} Deficiency`;
            lightboxDescription.innerHTML = `
                <div><strong>Description:</strong> ${caption}</div>
                <div><strong>Crop:</strong> ${cropName}</div>
            `;
            
            // Show/hide navigation buttons
            const prevBtn = document.getElementById('lightbox-prev');
            const nextBtn = document.getElementById('lightbox-next');
            
            if (prevBtn && nextBtn) {
                if (this.lightboxImages.length > 1) {
                    prevBtn.style.display = 'block';
                    nextBtn.style.display = 'block';
                    prevBtn.disabled = this.currentImageIndex === 0;
                    nextBtn.disabled = this.currentImageIndex === this.lightboxImages.length - 1;
                } else {
                    prevBtn.style.display = 'none';
                    nextBtn.style.display = 'none';
                }
            }
            
            // Show lightbox with animation
            lightbox.style.display = 'flex';
            setTimeout(() => {
                lightbox.style.opacity = '1';
                lightbox.style.visibility = 'visible';
            }, 10);
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // Add escape key listener
            this.lightboxKeydownHandler = this.handleLightboxKeydown.bind(this);
            document.addEventListener('keydown', this.lightboxKeydownHandler);
        }
    }

    closeLightbox() {
        console.log('‚ùå Closing lightbox');
        
        const lightbox = document.getElementById('image-lightbox');
        if (lightbox) {
            // Hide with animation
            lightbox.style.opacity = '0';
            lightbox.style.visibility = 'hidden';
            
            setTimeout(() => {
                lightbox.style.display = 'none';
            }, 300);
            
            // Restore body scroll
            document.body.style.overflow = 'auto';
            
            // Remove escape key listener
            if (this.lightboxKeydownHandler) {
                document.removeEventListener('keydown', this.lightboxKeydownHandler);
                this.lightboxKeydownHandler = null;
            }
        }
    }

    nextImage() {
        if (this.currentImageIndex < this.lightboxImages.length - 1) {
            this.currentImageIndex++;
            this.updateLightboxImage();
        }
    }

    previousImage() {
        if (this.currentImageIndex > 0) {
            this.currentImageIndex--;
            this.updateLightboxImage();
        }
    }

    updateLightboxImage() {
        const currentImage = this.lightboxImages[this.currentImageIndex];
        if (!currentImage) return;
        
        const lightboxImage = document.getElementById('lightbox-image');
        const lightboxTitle = document.getElementById('lightbox-title');
        const lightboxDescription = document.getElementById('lightbox-description');
        const prevBtn = document.getElementById('lightbox-prev');
        const nextBtn = document.getElementById('lightbox-next');
        
        if (lightboxImage && lightboxTitle && lightboxDescription) {
            lightboxImage.src = currentImage.url;
            lightboxImage.alt = currentImage.caption;
            lightboxTitle.textContent = `${currentImage.nutrientName} Deficiency`;
            lightboxDescription.innerHTML = `
                <div><strong>Description:</strong> ${currentImage.caption}</div>
                <div><strong>Crop:</strong> ${currentImage.cropName}</div>
            `;
            
            // Update navigation buttons
            if (prevBtn && nextBtn) {
                prevBtn.disabled = this.currentImageIndex === 0;
                nextBtn.disabled = this.currentImageIndex === this.lightboxImages.length - 1;
            }
        }
    }

    handleLightboxKeydown(event) {
        switch(event.key) {
            case 'Escape':
                this.closeLightbox();
                break;
            case 'ArrowLeft':
                this.previousImage();
                break;
            case 'ArrowRight':
                this.nextImage();
                break;
        }
    }
}

let app;

// Global functions for metrics configuration (accessible before app initialization)
window.openMetricsConfig = function() {

    if (window.app) {
        window.app.openMetricsConfig();
    } else {
        console.error('App not initialized yet');
    }
};

window.closeMetricsConfig = function() {
    if (window.app) {
        window.app.closeMetricsConfig();
    }
};

window.saveMetricsConfig = function() {
    if (window.app) {
        window.app.saveMetricsConfig();
    }
};

document.addEventListener('DOMContentLoaded', async () => {
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
    
    // Ensure all modals are hidden on page load
    const modals = document.querySelectorAll('.modal-overlay');
    modals.forEach(modal => {
        modal.style.display = 'none';
    });
    
    app = new AquaponicsApp();
    window.app = app;
    
    // Add lightbox click-outside-to-close functionality
    document.addEventListener('click', function(event) {
        const lightbox = document.getElementById('image-lightbox');
        if (lightbox && event.target === lightbox) {
            app.closeLightbox();
        }
    });
    
    // Debug: Check if Quick Action functions exist
    
    // Test function to verify Quick Actions work
    window.testQuickActions = function() {
        if (app.openQuickHarvestDialog) {
            app.openQuickHarvestDialog('166', 'Test Bed');
        } else {
            console.error('‚ùå openQuickHarvestDialog not found');
        }
    };
    
    // Initialize plant tabs
    app.initializePlantTabs();
    
    // Initialize dashboard metric preferences
    app.initializeMetricPreferences();
    
    // Initialize sensor config tabs
    app.initializeSensorConfigTabs();
    
    // Set up add spray programme form event listeners
    const addSprayForm = document.getElementById('add-spray-form');
    if (addSprayForm) {
        addSprayForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            await app.saveNewSprayProgramme();
        });
    }
    
    // Close modal on Escape key for add spray modal
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const addSprayModal = document.getElementById('add-spray-modal');
            if (addSprayModal && addSprayModal.classList.contains('show')) {
                app.closeAddSprayModal();
            }
        }
    });
    
    // Close modal when clicking outside
    const addSprayModal = document.getElementById('add-spray-modal');
    if (addSprayModal) {
        addSprayModal.addEventListener('click', (e) => {
            if (e.target === addSprayModal) {
                app.closeAddSprayModal();
            }
        });
    }
});

// Grow bed management functionality
class GrowBedManager {
    constructor() {
        this.growBedTypes = {
            'dwc': {
                name: 'Deep Water Culture',
                fields: ['length', 'width', 'height'],
                calculation: 'lwh'
            },
            'flood-drain': {
                name: 'Flood & Drain',
                fields: ['length', 'width', 'height'],
                calculation: 'media'
            },
            'media-flow': {
                name: 'Media Flow Through',
                fields: ['length', 'width', 'height'],
                calculation: 'lwh'
            },
            'vertical': {
                name: 'Vertical Growing',
                fields: ['base_length', 'base_width', 'base_height', 'vertical_count', 'plants_per_vertical'],
                calculation: 'vertical'
            },
            'nft': {
                name: 'NFT (Nutrient Film Technique)',
                fields: ['trough_length', 'trough_count', 'plant_spacing', 'reservoir_volume'],
                calculation: 'nft'
            }
        };
    }

    generateGrowBedConfiguration(bedCount) {
        const container = document.getElementById('grow-beds-config-container');
        if (!container) return;

        let html = `
            <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                <p style="margin: 0; color: #666; font-size: 0.9rem;">
                    <strong>‚ö†Ô∏è Important:</strong> Configure and save each grow bed before saving system configuration.
                    <br><strong>Volume (m¬≥):</strong> Reservoir volume for nutrient solution
                    <br><strong>Area (m¬≤):</strong> Equivalent growing area for plant calculations
                </p>
            </div>
        `;

        for (let i = 1; i <= bedCount; i++) {
            html += this.generateGrowBedItem(i);
        }

        container.innerHTML = html;
    }

    generateGrowBedItem(bedNumber) {
        return `
            <div class="grow-bed-item" data-bed="${bedNumber}" style="border: 1px solid #ddd; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; background: white;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="margin: 0; color: #2c3e50;">Grow Bed ${bedNumber}</h5>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" class="form-btn secondary" onclick="window.growBedManager.saveBedConfiguration(${bedNumber})" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">Save Bed Config</button>
                        <button type="button" class="form-btn" onclick="window.growBedManager.deleteBedConfiguration(${bedNumber})" style="font-size: 0.8rem; padding: 0.3rem 0.6rem; background: #dc3545; border-color: #dc3545;">Delete Bed</button>
                    </div>
                </div>
                
                <div class="form-field">
                    <label>Bed Type:</label>
                    <select class="bed-type" onchange="window.growBedManager.updateBedFields(${bedNumber})">
                        <option value="">Select Type</option>
                        <option value="dwc">Deep Water Culture (DWC)</option>
                        <option value="flood-drain">Flood & Drain (F&D)</option>
                        <option value="media-flow">Media Flow Through (MFT)</option>
                        <option value="nft">NFT (Nutrient Film Technique)</option>
                        <option value="vertical">Vertical Growing</option>
                    </select>
                </div>

                <div id="bed-fields-${bedNumber}" class="bed-fields" style="display: none;">
                    <!-- Dynamic fields will be inserted here -->
                </div>

                <div class="calculation-results" style="display: none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div>
                            <strong>Reservoir Volume (m¬≥):</strong>
                            <span class="calculated-volume">0.0</span>
                        </div>
                        <div>
                            <strong>Equivalent Grow Area (m¬≤):</strong>
                            <span class="calculated-area">0.0</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    updateBedFields(bedNumber) {
        const bedItem = document.querySelector(`[data-bed="${bedNumber}"]`);
        if (!bedItem) return;

        const typeSelect = bedItem.querySelector('.bed-type');
        const fieldsContainer = bedItem.querySelector(`#bed-fields-${bedNumber}`);
        const resultsContainer = bedItem.querySelector('.calculation-results');
        
        const bedType = typeSelect.value;
        
        if (!bedType) {
            fieldsContainer.style.display = 'none';
            resultsContainer.style.display = 'none';
            return;
        }

        const typeConfig = this.growBedTypes[bedType];
        let html = '';

        if (bedType === 'dwc') {
            html = `
                <div class="form-grid">
                    <div class="form-field">
                        <label>Length (m):</label>
                        <input type="number" class="bed-length" min="0.1" step="0.1" placeholder="2.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Width (m):</label>
                        <input type="number" class="bed-width" min="0.1" step="0.1" placeholder="1.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Height/Depth (m):</label>
                        <input type="number" class="bed-height" min="0.1" step="0.1" placeholder="0.3" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
                    DWC: Volume = L√óW√óH, Area = L√óW
                </p>
            `;
        } else if (bedType === 'flood-drain') {
            html = `
                <div class="form-grid">
                    <div class="form-field">
                        <label>Length (m):</label>
                        <input type="number" class="bed-length" min="0.1" step="0.1" placeholder="2.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Width (m):</label>
                        <input type="number" class="bed-width" min="0.1" step="0.1" placeholder="1.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Height/Depth (m):</label>
                        <input type="number" class="bed-height" min="0.1" step="0.1" placeholder="0.3" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
                    F&D: Volume = (L√óW√óH)/4 (media takes 75% space), Area = L√óW
                </p>
            `;
        } else if (bedType === 'media-flow') {
            html = `
                <div class="form-grid">
                    <div class="form-field">
                        <label>Length (m):</label>
                        <input type="number" class="bed-length" min="0.1" step="0.1" placeholder="2.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Width (m):</label>
                        <input type="number" class="bed-width" min="0.1" step="0.1" placeholder="1.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Height/Depth (m):</label>
                        <input type="number" class="bed-height" min="0.1" step="0.1" placeholder="0.3" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
                    MFT: Volume = L√óW√óH, Area = L√óW
                </p>
            `;
        } else if (bedType === 'vertical') {
            html = `
                <div class="form-grid">
                    <div class="form-field">
                        <label>Base Length (m):</label>
                        <input type="number" class="base-length" min="0.1" step="0.1" placeholder="1.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Base Width (m):</label>
                        <input type="number" class="base-width" min="0.1" step="0.1" placeholder="1.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Base Height (m):</label>
                        <input type="number" class="base-height" min="0.1" step="0.1" placeholder="0.5" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Number of Verticals:</label>
                        <input type="number" class="vertical-count" min="1" step="1" placeholder="4" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Plants per Vertical:</label>
                        <input type="number" class="plants-per-vertical" min="1" step="1" placeholder="12" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
                    Vertical: Volume = base L√óW√óH, Area = (verticals √ó plants per vertical) √∑ 25
                </p>
            `;
        } else if (bedType === 'nft') {
            html = `
                <div class="form-grid">
                    <div class="form-field">
                        <label>Trough Length (m):</label>
                        <input type="number" class="trough-length" min="0.1" step="0.1" placeholder="3.0" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Number of Troughs:</label>
                        <input type="number" class="trough-count" min="1" step="1" placeholder="4" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Plant Spacing (cm):</label>
                        <input type="number" class="plant-spacing" min="1" step="1" placeholder="15" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                    <div class="form-field">
                        <label>Reservoir Volume (L):</label>
                        <input type="number" class="reservoir-volume" min="1" step="1" placeholder="100" onchange="window.growBedManager.calculateBed(${bedNumber})">
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
                    NFT: Volume = manual reservoir volume, Area = (total plants) √∑ 25<br>
                    Total plants = (trough length √∑ plant spacing) √ó number of troughs
                </p>
            `;
        }

        fieldsContainer.innerHTML = html;
        fieldsContainer.style.display = 'block';
        resultsContainer.style.display = 'block';
        
        this.calculateBed(bedNumber);
    }

    calculateBed(bedNumber) {
        const bedItem = document.querySelector(`[data-bed="${bedNumber}"]`);
        if (!bedItem) return;

        const typeSelect = bedItem.querySelector('.bed-type');
        const volumeSpan = bedItem.querySelector('.calculated-volume');
        const areaSpan = bedItem.querySelector('.calculated-area');
        
        const bedType = typeSelect.value;
        if (!bedType) return;

        let volume = 0;
        let area = 0;

        if (bedType === 'dwc' || bedType === 'media-flow') {
            const length = parseFloat(bedItem.querySelector('.bed-length')?.value) || 0;
            const width = parseFloat(bedItem.querySelector('.bed-width')?.value) || 0;
            const height = parseFloat(bedItem.querySelector('.bed-height')?.value) || 0;
            
            if (length > 0 && width > 0 && height > 0) {
                volume = length * width * height;
                area = length * width;
            }
        } else if (bedType === 'flood-drain') {
            const length = parseFloat(bedItem.querySelector('.bed-length')?.value) || 0;
            const width = parseFloat(bedItem.querySelector('.bed-width')?.value) || 0;
            const height = parseFloat(bedItem.querySelector('.bed-height')?.value) || 0;
            
            if (length > 0 && width > 0 && height > 0) {
                volume = (length * width * height) / 4; // 25% volume for water, 75% for media
                area = length * width;
            }
        } else if (bedType === 'vertical') {
            const baseLength = parseFloat(bedItem.querySelector('.base-length')?.value) || 0;
            const baseWidth = parseFloat(bedItem.querySelector('.base-width')?.value) || 0;
            const baseHeight = parseFloat(bedItem.querySelector('.base-height')?.value) || 0;
            const verticalCount = parseFloat(bedItem.querySelector('.vertical-count')?.value) || 0;
            const plantsPerVertical = parseFloat(bedItem.querySelector('.plants-per-vertical')?.value) || 0;
            
            if (baseLength > 0 && baseWidth > 0 && baseHeight > 0) {
                volume = baseLength * baseWidth * baseHeight;
            }
            
            if (verticalCount > 0 && plantsPerVertical > 0) {
                const totalPlants = verticalCount * plantsPerVertical;
                area = totalPlants / 25; // 25 plants per m¬≤
            }
        } else if (bedType === 'nft') {
            const troughLength = parseFloat(bedItem.querySelector('.trough-length')?.value) || 0;
            const troughCount = parseFloat(bedItem.querySelector('.trough-count')?.value) || 0;
            const plantSpacing = parseFloat(bedItem.querySelector('.plant-spacing')?.value) || 0;
            const reservoirVolume = parseFloat(bedItem.querySelector('.reservoir-volume')?.value) || 0;
            
            if (reservoirVolume > 0) {
                volume = reservoirVolume / 1000; // Convert liters to m¬≥
            }
            
            if (troughLength > 0 && troughCount > 0 && plantSpacing > 0) {
                const plantsPerTrough = Math.floor((troughLength * 100) / plantSpacing); // Convert meters to cm for spacing calculation
                const totalPlants = plantsPerTrough * troughCount;
                area = totalPlants / 25; // 25 plants per m¬≤
            }
        }

        volumeSpan.textContent = `${volume.toFixed(2)} m¬≥`;
        areaSpan.textContent = `${area.toFixed(2)} m¬≤`;
        
        this.updateTotalEquivalentArea();
    }

    updateTotalEquivalentArea() {
        const areaSpans = document.querySelectorAll('.calculated-area');
        let total = 0;

        areaSpans.forEach(span => {
            const value = parseFloat(span.textContent.replace(' m¬≤', '')) || 0;
            total += value;
        });

        const totalInput = document.getElementById('total-grow-area');
        if (totalInput) {
            totalInput.value = total.toFixed(1);
        }
    }

    async saveBedConfiguration(bedNumber) {
        if (!window.app || !window.app.activeSystemId) {
            console.error('window.app not available or no active system');
            alert('‚ùå No active system selected');
            return;
        }

        const bedItem = document.querySelector(`[data-bed="${bedNumber}"]`);
        if (!bedItem) return;

        const bedType = bedItem.querySelector('.bed-type').value;
        if (!bedType) {
            window.app.showNotification('‚ùå Please select a bed type first', 'error');
            return;
        }

        const volume = parseFloat(bedItem.querySelector('.calculated-volume')?.textContent.replace(' m¬≥', '')) || 0;
        const area = parseFloat(bedItem.querySelector('.calculated-area')?.textContent.replace(' m¬≤', '')) || 0;

        // Check if required dimensions are filled based on bed type
        let isValid = false;
        let missingFields = [];

        if (bedType === 'dwc' || bedType === 'media-flow' || bedType === 'flood-drain') {
            const length = parseFloat(bedItem.querySelector('.bed-length')?.value) || 0;
            const width = parseFloat(bedItem.querySelector('.bed-width')?.value) || 0;
            const height = parseFloat(bedItem.querySelector('.bed-height')?.value) || 0;
            
            if (length <= 0) missingFields.push('Length');
            if (width <= 0) missingFields.push('Width');
            if (height <= 0) missingFields.push('Height');
            
            isValid = length > 0 && width > 0 && height > 0;
        } else if (bedType === 'vertical') {
            const baseLength = parseFloat(bedItem.querySelector('.base-length')?.value) || 0;
            const baseWidth = parseFloat(bedItem.querySelector('.base-width')?.value) || 0;
            const baseHeight = parseFloat(bedItem.querySelector('.base-height')?.value) || 0;
            const verticalCount = parseFloat(bedItem.querySelector('.vertical-count')?.value) || 0;
            const plantsPerVertical = parseFloat(bedItem.querySelector('.plants-per-vertical')?.value) || 0;
            
            if (baseLength <= 0) missingFields.push('Base Length');
            if (baseWidth <= 0) missingFields.push('Base Width');
            if (baseHeight <= 0) missingFields.push('Base Height');
            if (verticalCount <= 0) missingFields.push('Number of Verticals');
            if (plantsPerVertical <= 0) missingFields.push('Plants per Vertical');
            
            isValid = baseLength > 0 && baseWidth > 0 && baseHeight > 0 && verticalCount > 0 && plantsPerVertical > 0;
        } else if (bedType === 'nft') {
            const troughLength = parseFloat(bedItem.querySelector('.trough-length')?.value) || 0;
            const troughCount = parseFloat(bedItem.querySelector('.trough-count')?.value) || 0;
            const plantSpacing = parseFloat(bedItem.querySelector('.plant-spacing')?.value) || 0;
            const reservoirVolume = parseFloat(bedItem.querySelector('.reservoir-volume')?.value) || 0;
            
            if (troughLength <= 0) missingFields.push('Trough Length');
            if (troughCount <= 0) missingFields.push('Number of Troughs');
            if (plantSpacing <= 0) missingFields.push('Plant Spacing');
            if (reservoirVolume <= 0) missingFields.push('Reservoir Volume');
            
            isValid = troughLength > 0 && troughCount > 0 && plantSpacing > 0 && reservoirVolume > 0;
        }

        if (!isValid) {
            window.app.showNotification(`‚ùå Please fill in: ${missingFields.join(', ')}`, 'error');
            return;
        }

        // Build bed configuration
        const config = {
            bed_number: bedNumber,
            bed_type: bedType,
            bed_name: `Bed ${bedNumber}`,
            volume_liters: volume * 1000, // Convert m¬≥ to liters
            area_m2: area,
            equivalent_m2: area,
            reservoir_volume: volume * 1000
        };

        // Add type-specific dimensions
        if (bedType === 'dwc' || bedType === 'media-flow' || bedType === 'flood-drain') {
            config.length_meters = parseFloat(bedItem.querySelector('.bed-length')?.value) || 0;
            config.width_meters = parseFloat(bedItem.querySelector('.bed-width')?.value) || 0;
            config.height_meters = parseFloat(bedItem.querySelector('.bed-height')?.value) || 0;
        } else if (bedType === 'vertical') {
            config.length_meters = parseFloat(bedItem.querySelector('.base-length')?.value) || 0;
            config.width_meters = parseFloat(bedItem.querySelector('.base-width')?.value) || 0;
            config.height_meters = parseFloat(bedItem.querySelector('.base-height')?.value) || 0;
            config.vertical_count = parseFloat(bedItem.querySelector('.vertical-count')?.value) || 0;
            config.plants_per_vertical = parseFloat(bedItem.querySelector('.plants-per-vertical')?.value) || 0;
            config.plant_capacity = config.vertical_count * config.plants_per_vertical;
        } else if (bedType === 'nft') {
            config.trough_length = parseFloat(bedItem.querySelector('.trough-length')?.value) || 0;
            config.trough_count = parseFloat(bedItem.querySelector('.trough-count')?.value) || 0;
            config.plant_spacing = parseFloat(bedItem.querySelector('.plant-spacing')?.value) || 0;
            config.reservoir_volume_liters = parseFloat(bedItem.querySelector('.reservoir-volume')?.value) || 0;
            
            // Calculate total plant capacity for NFT
            if (config.trough_length > 0 && config.trough_count > 0 && config.plant_spacing > 0) {
                const plantsPerTrough = Math.floor((config.trough_length * 100) / config.plant_spacing);
                config.plant_capacity = plantsPerTrough * config.trough_count;
            }
        }

        try {
            // Get all current bed configurations to preserve them
            const allBedConfigs = this.getGrowBedConfiguration();
            
            // Update or add the current bed configuration
            const existingIndex = allBedConfigs.findIndex(bed => bed.bed_number === bedNumber);
            if (existingIndex >= 0) {
                allBedConfigs[existingIndex] = config;
            } else {
                allBedConfigs.push(config);
            }
            
            // Save all beds together

            const response = await window.app.makeApiCall(`/grow-beds/system/${window.app.activeSystemId}`, {
                method: 'POST',
                body: JSON.stringify({ growBeds: allBedConfigs })
            });

            if (window.app && window.app.showNotification) {
                window.app.showNotification(`‚úÖ Bed ${bedNumber} configuration saved`, 'success');
                
                // Refresh app data to pick up the changes
                if (window.app.updateDashboardFromData) {
                    await window.app.updateDashboardFromData();
                }
            } else {
                console.error('window.app.showNotification not available');
                alert(`‚úÖ Bed ${bedNumber} configuration saved`);
            }
        } catch (error) {
            console.error('Failed to save bed configuration:', error);
            if (window.app && window.app.showNotification) {
                window.app.showNotification('‚ùå Failed to save bed configuration', 'error');
            } else {
                alert('‚ùå Failed to save bed configuration');
            }
        }
    }

    async deleteBedConfiguration(bedNumber) {
        if (!window.app || !window.app.activeSystemId) {
            window.app.showNotification('‚ùå No active system selected', 'error');
            return;
        }

        if (!confirm(`Are you sure you want to delete Grow Bed ${bedNumber} configuration? This action cannot be undone.`)) {
            return;
        }

        try {
            // Get current grow beds from the database
            const growBeds = await window.app.makeApiCall(`/grow-beds/system/${window.app.activeSystemId}`);
            
            // Find the bed to delete by bed_number
            const bedToDelete = growBeds.find(bed => bed.bed_number === bedNumber);
            
            if (!bedToDelete) {
                window.app.showNotification('‚ùå Bed configuration not found in database', 'error');
                return;
            }

            // Delete the specific bed from database
            await window.app.makeApiCall(`/grow-beds/${bedToDelete.id}`, {
                method: 'DELETE'
            });

            // Reload the entire grow bed configuration to sync with database
            await window.app.loadGrowBedConfiguration();

            window.app.showNotification(`‚úÖ Bed ${bedNumber} configuration deleted`, 'success');
        } catch (error) {
            console.error('Failed to delete bed configuration:', error);
            window.app.showNotification('‚ùå Failed to delete bed configuration', 'error');
        }
    }

    getGrowBedConfiguration() {
        const bedItems = document.querySelectorAll('.grow-bed-item');
        const configuration = [];

        bedItems.forEach((item, index) => {
            const bedNumber = index + 1;
            const bedType = item.querySelector('.bed-type').value;

            if (!bedType) {

                return;
            }

            const volume = parseFloat(item.querySelector('.calculated-volume')?.textContent.replace(' m¬≥', '')) || 0;
            const area = parseFloat(item.querySelector('.calculated-area')?.textContent.replace(' m¬≤', '')) || 0;

            // Save bed configuration if bed type is selected, even if calculations are incomplete
            if (bedType) {
                const config = {
                    bed_number: bedNumber,
                    bed_type: bedType,
                    bed_name: `Bed ${bedNumber}`,
                    volume_liters: volume * 1000,
                    area_m2: area,
                    equivalent_m2: area,
                    reservoir_volume: volume * 1000
                };

                // Add type-specific dimensions
                if (bedType === 'dwc' || bedType === 'media-flow' || bedType === 'flood-drain') {
                    config.length_meters = parseFloat(item.querySelector('.bed-length')?.value) || 0;
                    config.width_meters = parseFloat(item.querySelector('.bed-width')?.value) || 0;
                    config.height_meters = parseFloat(item.querySelector('.bed-height')?.value) || 0;
                } else if (bedType === 'vertical') {
                    config.length_meters = parseFloat(item.querySelector('.base-length')?.value) || 0;
                    config.width_meters = parseFloat(item.querySelector('.base-width')?.value) || 0;
                    config.height_meters = parseFloat(item.querySelector('.base-height')?.value) || 0;
                    config.vertical_count = parseFloat(item.querySelector('.vertical-count')?.value) || 0;
                    config.plants_per_vertical = parseFloat(item.querySelector('.plants-per-vertical')?.value) || 0;
                    config.plant_capacity = config.vertical_count * config.plants_per_vertical;
                } else if (bedType === 'nft') {
                    config.trough_length = parseFloat(item.querySelector('.trough-length')?.value) || 0;
                    config.trough_count = parseFloat(item.querySelector('.trough-count')?.value) || 0;
                    config.plant_spacing = parseFloat(item.querySelector('.plant-spacing')?.value) || 0;
                    config.reservoir_volume_liters = parseFloat(item.querySelector('.reservoir-volume')?.value) || 0;
                    
                    // Calculate total plant capacity for NFT
                    if (config.trough_length > 0 && config.trough_count > 0 && config.plant_spacing > 0) {
                        const plantsPerTrough = Math.floor((config.trough_length * 100) / config.plant_spacing);
                        config.plant_capacity = plantsPerTrough * config.trough_count;
                    }
                }

                configuration.push(config);

            }
        });

        return configuration;
    }
}

// Initialize grow bed manager
window.growBedManager = new GrowBedManager();

// Actions Required Management Functions
async function loadActionsRequired() {
    
    if (!window.app || !window.app.activeSystemId) {
        return;
    }
    
    try {
        
        // Load all pending tasks
        const [nutrientTasks, fishTasks, sprayTasks, maintenanceTasks] = await Promise.all([
            getPendingNutrientTasks(window.app.activeSystemId),
            getPendingFishTasks(window.app.activeSystemId),
            getTodaysSprayTasks(window.app.activeSystemId),
            getPendingMaintenanceTasks(window.app.activeSystemId)
        ]);
        
        
        // Display tasks in their respective containers
        displayDataCaptureTasks([...nutrientTasks, ...fishTasks]);
        displaySprayProgrammeTasks(sprayTasks);
        displayMaintenanceTasks(maintenanceTasks);
        
        // Update badge count
        const totalTasks = nutrientTasks.length + fishTasks.length + sprayTasks.length + maintenanceTasks.length;
        updateActionsBadge(totalTasks);
        
        // Show empty state if no tasks
        if (totalTasks === 0) {
            showEmptyState();
        } else {
            hideEmptyState();
        }
        
    } catch (error) {
        console.error('Error loading actions required:', error);
        showErrorState();
    }
}

async function getPendingNutrientTasks(systemId) {
    try {
        // Check when last nutrient readings were taken
        const latestReadings = await window.app.makeApiCall(`/data/nutrients/latest/${systemId}`);
        const tasks = [];
        
        // Check if readings are older than 7 days or missing
        const now = new Date();
        const weekAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
        
        const nutrientTypes = ['ph', 'ec', 'dissolved_oxygen', 'temperature', 'ammonia', 'nitrite', 'nitrate'];
        
        for (const nutrientType of nutrientTypes) {
            const reading = latestReadings[nutrientType];
            const lastReading = reading ? new Date(reading.reading_date) : null;
            
            if (!lastReading || lastReading < weekAgo) {
                const daysAgo = lastReading ? Math.floor((now - lastReading) / (1000 * 60 * 60 * 24)) : 999;
                
                tasks.push({
                    type: 'nutrient_capture',
                    title: `Water Quality Reading Required`,
                    subtitle: lastReading ? `Last reading: ${daysAgo} days ago` : 'No readings recorded',
                    priority: daysAgo > 14 ? 'overdue' : daysAgo > 7 ? 'due_soon' : 'normal',
                    nutrientType: nutrientType,
                    actions: [
                        { label: 'Capture Now', action: 'open_water_quality_form', primary: true },
                        { label: 'View History', action: 'view_water_quality_history', primary: false }
                    ]
                });
                break; // Only show one water quality task
            } else {
            }
        }
        
        return tasks;
    } catch (error) {
        console.error('Error getting nutrient tasks:', error);
        return [];
    }
}

async function getPendingFishTasks(systemId) {
    try {
        // Check when last fish measurements were taken
        const fishHealth = await window.app.makeApiCall(`/data/fish-health/${systemId}?limit=1`);
        const tasks = [];
        
        const now = new Date();
        const weekAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
        
        if (!fishHealth || fishHealth.length === 0) {
            tasks.push({
                type: 'fish_data',
                title: 'Fish Health Assessment Required',
                subtitle: 'No fish data recorded',
                priority: 'overdue',
                actions: [
                    { label: 'Record Now', action: 'open_fish_form', primary: true },
                    { label: 'View Guide', action: 'view_fish_guide', primary: false }
                ]
            });
        } else {
            const lastReading = new Date(fishHealth[0].date);
            const daysAgo = Math.floor((now - lastReading) / (1000 * 60 * 60 * 24));
            
            if (lastReading < weekAgo) {
                tasks.push({
                    type: 'fish_data',
                    title: 'Fish Health Assessment Due',
                    subtitle: `Last recorded: ${daysAgo} days ago`,
                    priority: daysAgo > 14 ? 'overdue' : 'due_soon',
                    actions: [
                        { label: 'Record Now', action: 'open_fish_form', primary: true },
                        { label: 'View History', action: 'view_fish_history', primary: false }
                    ]
                });
            }
        }
        
        return tasks;
    } catch (error) {
        console.error('Error getting fish tasks:', error);
        return [];
    }
}

// Spray tasks function moved to SprayManager service
async function getTodaysSprayTasks(systemId) {
    // Import SprayManager dynamically to maintain compatibility
    if (window.sprayManager) {
        return await window.sprayManager.getTodaysSprayTasks(systemId);
    }
    
    // Fallback: create temporary instance if module not loaded
    try {
        const { getTodaysSprayTasks: sprayTasksFunction } = await import('./public/js/modules/services/sprayManager.js');
        return await sprayTasksFunction(systemId);
    } catch (error) {
        console.error('Failed to load SprayManager service:', error);
        return [];
    }
}

async function getPendingMaintenanceTasks(systemId) {
    // Placeholder for maintenance tasks
    // Could include things like:
    // - Pump maintenance reminders
    // - Filter cleaning schedules
    // - System cleaning reminders
    return [];
}

function displayDataCaptureTasks(tasks) {
    const container = document.getElementById('data-capture-tasks');
    if (!container) return;
    
    if (tasks.length === 0) {
        container.innerHTML = '<p class="text-muted">All data capture tasks are up to date!</p>';
        return;
    }
    
    const html = tasks.map(task => createTaskCard(task)).join('');
    container.innerHTML = html;
}

function displaySprayProgrammeTasks(tasks) {
    const container = document.getElementById('spray-programme-tasks');
    if (!container) return;
    
    if (tasks.length === 0) {
        container.innerHTML = '<p class="text-muted">No spray applications scheduled for today.</p>';
        return;
    }
    
    const html = tasks.map(task => createTaskCard(task)).join('');
    container.innerHTML = html;
}

function displayMaintenanceTasks(tasks) {
    const container = document.getElementById('maintenance-tasks');
    if (!container) return;
    
    if (tasks.length === 0) {
        container.innerHTML = '<p class="text-muted">No maintenance tasks due today.</p>';
        return;
    }
    
    const html = tasks.map(task => createTaskCard(task)).join('');
    container.innerHTML = html;
}

function createTaskCard(task) {
    const priorityClass = `priority-${task.priority.replace('_', '-')}`;
    const priorityLabel = task.priority.replace('_', ' ');
    
    const actionsHtml = task.actions.map(action => {
        const dataAttributes = action.productId ? `data-product-id="${action.productId}"` : '';
        return `<button class="task-action-btn ${action.primary ? 'primary' : 'secondary'}" 
                        ${dataAttributes}
                        onclick="handleTaskAction(event, '${action.action}', ${JSON.stringify(task).replace(/"/g, '&quot;')})">
                ${action.label}
            </button>`;
    }).join('');
    
    return `
        <div class="task-card ${priorityClass}">
            <div class="task-header">
                <div class="task-info">
                    <div class="task-title">${task.title}</div>
                    <div class="task-subtitle">${task.subtitle}</div>
                    <span class="task-priority ${task.priority}">${priorityLabel}</span>
                </div>
            </div>
            <div class="task-actions">
                ${actionsHtml}
            </div>
        </div>
    `;
}

function handleTaskAction(event, action, task) {
    switch (action) {
        case 'open_water_quality_form':
            // Navigate to dashboard and open water quality modal
            window.app.navigateToDashboard();
            setTimeout(() => {
                const waterBtn = document.querySelector('.action-btn[onclick*="Water Quality"]');
                if (waterBtn) waterBtn.click();
            }, 200);
            break;
            
        case 'open_fish_form':
            // Navigate to fish tab and open fish health modal
            window.app.navigateToFish();
            setTimeout(() => {
                const fishBtn = document.querySelector('.action-btn[onclick*="Fish Health"]');
                if (fishBtn) fishBtn.click();
            }, 200);
            break;
            
        case 'start_spray_application':
            // Navigate to plants tab and open spray programmes, then show recording options
            window.app.navigateToPlants();
            setTimeout(() => {
                // Click the spray programmes tab to switch to it
                const sprayTab = document.getElementById('spray-programmes-tab');
                if (sprayTab) {
                    sprayTab.click();
                    // Show notification that user should select a product to record
                    window.app.showNotification('Select a product below to record its application', 'info');
                }
            }, 300);
            break;
            
        case 'record_spray_application':
            // Get the productId from the button data attributes
            const button = event.target.closest('.task-action-btn');
            const productId = button ? button.dataset.productId : null;
            if (productId) {
                // Directly open the record spray modal for this specific product
                window.app.recordSprayApplication(parseInt(productId));
            } else {
                // Fallback: navigate to spray programmes
                window.app.navigateToPlants();
                setTimeout(() => {
                    const sprayTab = document.getElementById('spray-programmes-tab');
                    if (sprayTab) sprayTab.click();
                }, 300);
            }
            break;
            
        case 'view_water_quality_history':
        case 'view_fish_history':
            // Navigate to appropriate history/overview
            window.app.navigateToPlants();
            break;
            
        case 'view_spray_programme':
            // Navigate to Plants tab and scroll to spray programmes section
            window.app.navigateToPlants();
            setTimeout(() => {
                // Click the spray programmes tab to switch to it
                const sprayTab = document.getElementById('spray-programmes-tab');
                if (sprayTab) {
                    sprayTab.click();
                    // Scroll to the spray programmes content
                    setTimeout(() => {
                        const spraySection = document.getElementById('spray-programmes-content');
                        if (spraySection) {
                            spraySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 100);
                }
            }, 300);
            break;
            
        default:
    }
}

function updateActionsBadge(count) {
    const badge = document.getElementById('actions-badge');
    if (!badge) return;
    
    if (count > 0) {
        badge.textContent = count;
        badge.style.display = 'inline-flex';
    } else {
        badge.style.display = 'none';
    }
}

function showEmptyState() {
    const categories = document.querySelector('.task-categories');
    const emptyState = document.getElementById('actions-empty-state');
    
    if (categories) categories.style.display = 'none';
    if (emptyState) emptyState.style.display = 'block';
}

function hideEmptyState() {
    const categories = document.querySelector('.task-categories');
    const emptyState = document.getElementById('actions-empty-state');
    
    if (categories) categories.style.display = 'grid';
    if (emptyState) emptyState.style.display = 'none';
}

function showErrorState() {
    const container = document.querySelector('.actions-required-dashboard');
    if (!container) return;
    
    container.innerHTML = `
        <h2 class="heading-2">Actions Required Today</h2>
        <div class="error-state">
            <p class="text-muted">Unable to load tasks. Please try again later.</p>
            <button class="btn btn-primary" onclick="loadActionsRequired()">Retry</button>
        </div>
    `;
}

// Make loadActionsRequired globally available
window.loadActionsRequired = loadActionsRequired;

// Auto-refresh actions every 5 minutes
setInterval(() => {
    const actionsContent = document.getElementById('dashboard-actions-content');
    if (actionsContent && actionsContent.classList.contains('active')) {
        loadActionsRequired();
    }
}, 5 * 60 * 1000);

// SVG Icon Helper Functions
const SVGIcons = {
    // Cache for loaded SVG content
    cache: {},
    
    // Load SVG content from file
    async loadSVG(iconName) {
        if (this.cache[iconName]) {
            return this.cache[iconName];
        }
        
        try {
            const response = await fetch(`/icons/new-icons/Afraponix Go Icons_${iconName}.svg`);
            const svgContent = await response.text();
            this.cache[iconName] = svgContent;
            return svgContent;
        } catch (error) {
            console.warn(`Failed to load SVG icon: ${iconName}`, error);
            return null;
        }
    },
    
    // Create an SVG icon element
    async createIcon(iconName, className = 'icon-svg') {
        const svgContent = await this.loadSVG(iconName);
        if (!svgContent) {
            return `<span class="${className}">?</span>`;
        }
        
        const div = document.createElement('div');
        div.innerHTML = svgContent;
        const svg = div.querySelector('svg');
        
        if (svg) {
            svg.setAttribute('class', className);
            // Remove hardcoded width/height attributes to allow CSS sizing
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            return svg.outerHTML;
        }
        
        return `<span class="${className}">?</span>`;
    },
    
    // Synchronous version using cached content only
    getIcon(iconName, className = 'icon-svg') {
        const svgContent = this.cache[iconName];
        if (!svgContent) {
            return `<span class="${className}">?</span>`;
        }
        
        const div = document.createElement('div');
        div.innerHTML = svgContent;
        const svg = div.querySelector('svg');
        
        if (svg) {
            svg.setAttribute('class', className);
            // Remove hardcoded width/height attributes to allow CSS sizing
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            return svg.outerHTML;
        }
        
        return `<span class="${className}">?</span>`;
    },
    
    // Preload all icons
    async preloadIcons() {
        const icons = ['add', 'edit', 'delete', 'time'];
        await Promise.all(icons.map(icon => this.loadSVG(icon)));

        // Replace icon placeholders after preloading
        this.replaceIconPlaceholders();
        
        // Fix existing SVG icons that might have hardcoded dimensions
        this.fixExistingSVGIcons();
    },
    
    // Replace all icon placeholders in the DOM
    replaceIconPlaceholders() {
        const placeholders = document.querySelectorAll('.icon-placeholder[data-icon]');
        placeholders.forEach(placeholder => {
            const iconName = placeholder.getAttribute('data-icon');
            const iconHTML = this.getIcon(iconName, 'btn-icon-svg');
            placeholder.outerHTML = iconHTML;
        });
    },
    
    // Fix existing SVG icons in the DOM that have hardcoded dimensions
    fixExistingSVGIcons() {
        const svgElements = document.querySelectorAll('.btn-icon-svg svg, .icon-svg svg');
        svgElements.forEach(svg => {
            svg.removeAttribute('width');
            svg.removeAttribute('height');
        });

    }
};

// Preload icons when the page loads
document.addEventListener('DOMContentLoaded', () => {
    SVGIcons.preloadIcons();
});

// =====================================================
// NUTRIENT RATIO MANAGEMENT SYSTEM
// =====================================================

class NutrientRatioManager {
    constructor() {
        this.ratioRules = [];
        this.environmentalAdjustments = [];
        this.nutrients = [];
        this.growthStages = [];
        this.environmentalParameters = [];
        this.currentEditingRule = null;
        this.currentEditingAdjustment = null;
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Ratio management tabs
        document.querySelectorAll('.ratio-tab').forEach(tab => {
            tab.addEventListener('click', (e) => this.switchRatioTab(e.target.dataset.target));
        });

        // Add buttons
        document.getElementById('add-ratio-rule-btn')?.addEventListener('click', () => this.showRatioRuleModal());
        document.getElementById('add-env-adjustment-btn')?.addEventListener('click', () => this.showEnvAdjustmentModal());

        // Filter dropdowns
        document.getElementById('ratio-nutrient-filter')?.addEventListener('change', (e) => this.filterRatioRules());
        document.getElementById('ratio-stage-filter')?.addEventListener('change', (e) => this.filterRatioRules());

        // Note: Admin subtab handling is now integrated directly into the main setupAdminSubTabs function
    }

    async loadRatioManagement() {
        console.log('üîÑ Loading nutrient ratio management...');
        try {
            // Load all required data
            await Promise.all([
                this.loadNutrients(),
                this.loadGrowthStages(),
                this.loadEnvironmentalParameters(),
                this.loadRatioRules(),
                this.loadEnvironmentalAdjustments()
            ]);

            // Populate dropdowns
            this.populateFilterDropdowns();
            this.populateModalDropdowns();

            // Display current data
            this.displayRatioRules();
            this.displayEnvironmentalAdjustments();

            console.log('üìä Nutrient ratio management system loaded successfully');
            console.log(`üìä Loaded ${this.ratioRules.length} ratio rules`);
            console.log(`üå°Ô∏è Loaded ${this.environmentalAdjustments.length} environmental adjustments`);
        } catch (error) {
            console.error('‚ùå Error loading ratio management:', error);
            app.showMessage('Failed to load ratio management system', 'error');
        }
    }

    switchRatioTab(targetTab) {
        // Switch active tab
        document.querySelectorAll('.ratio-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelector(`[data-target="${targetTab}"]`).classList.add('active');

        // Switch active content
        document.querySelectorAll('.ratio-content').forEach(content => content.classList.remove('active'));
        document.getElementById(targetTab).classList.add('active');
    }

    // =====================================================
    // DATA LOADING FUNCTIONS
    // =====================================================

    async loadRatioRules() {
        try {
            const response = await fetch('/api/crop-knowledge/admin/ratio-rules', {
                headers: {
                    'Authorization': `Bearer ${this.token || localStorage.getItem('authToken')}`
                }
            });
            const data = await response.json();
            
            if (data.success) {
                this.ratioRules = data.data;
                console.log(`üìä Loaded ${data.count} ratio rules`);
            } else {
                throw new Error(data.error || 'Failed to load ratio rules');
            }
        } catch (error) {
            console.error('Error loading ratio rules:', error);
            throw error;
        }
    }

    async loadEnvironmentalAdjustments() {
        try {
            const response = await fetch('/api/crop-knowledge/admin/environmental-adjustments', {
                headers: {
                    'Authorization': `Bearer ${this.token || localStorage.getItem('authToken')}`
                }
            });
            const data = await response.json();
            
            if (data.success) {
                this.environmentalAdjustments = data.data;
                console.log(`üå°Ô∏è Loaded ${data.count} environmental adjustments`);
            } else {
                throw new Error(data.error || 'Failed to load environmental adjustments');
            }
        } catch (error) {
            console.error('Error loading environmental adjustments:', error);
            throw error;
        }
    }

    async loadNutrients() {
        try {
            const data = await CropKnowledgeAPI.fetchNutrients();
            
            if (data.success) {
                this.nutrients = data.data;
                console.log(`üß™ Loaded ${data.count} nutrients`);
            } else {
                throw new Error(data.error || 'Failed to load nutrients');
            }
        } catch (error) {
            console.error('Error loading nutrients:', error);
            throw error;
        }
    }

    async loadGrowthStages() {
        try {
            const response = await fetch('/api/crop-knowledge/stages', {
                headers: {
                    'Authorization': `Bearer ${this.token || localStorage.getItem('authToken')}`
                }
            });
            const data = await response.json();
            
            if (data.success) {
                this.growthStages = data.data;
                console.log(`üå± Loaded ${data.count} growth stages`);
            } else {
                throw new Error(data.error || 'Failed to load growth stages');
            }
        } catch (error) {
            console.error('Error loading growth stages:', error);
            throw error;
        }
    }

    async loadEnvironmentalParameters() {
        // Use the existing environmental_parameters table from our schema
        this.environmentalParameters = [
            { code: 'ec', name: 'Electrical Conductivity', unit: 'mS/cm' },
            { code: 'ph', name: 'pH', unit: '' },
            { code: 'temperature', name: 'Temperature', unit: '¬∞C' },
            { code: 'humidity', name: 'Relative Humidity', unit: '%' },
            { code: 'ppfd', name: 'Light Intensity', unit: 'Œºmol/m¬≤/s' }
        ];
        console.log(`üå°Ô∏è Loaded ${this.environmentalParameters.length} environmental parameters`);
    }

    // =====================================================
    // UI POPULATION FUNCTIONS
    // =====================================================

    populateFilterDropdowns() {
        // Populate nutrient filter
        const nutrientFilter = document.getElementById('ratio-nutrient-filter');
        if (nutrientFilter) {
            nutrientFilter.innerHTML = '<option value="">All Nutrients</option>';
            this.nutrients.forEach(nutrient => {
                const option = document.createElement('option');
                option.value = nutrient.code;
                option.textContent = `${nutrient.name} (${nutrient.symbol})`;
                nutrientFilter.appendChild(option);
            });
        }

        // Populate stage filter
        const stageFilter = document.getElementById('ratio-stage-filter');
        if (stageFilter) {
            stageFilter.innerHTML = '<option value="">All Growth Stages</option>';
            this.growthStages.forEach(stage => {
                const option = document.createElement('option');
                option.value = stage.code;
                option.textContent = stage.name;
                stageFilter.appendChild(option);
            });
        }
    }

    populateModalDropdowns() {
        // Ratio rule modal - nutrients
        const ruleNutrient = document.getElementById('rule-nutrient');
        if (ruleNutrient) {
            ruleNutrient.innerHTML = '<option value="">Select Nutrient</option>';
            this.nutrients.forEach(nutrient => {
                const option = document.createElement('option');
                option.value = nutrient.code;
                option.textContent = `${nutrient.name} (${nutrient.symbol})`;
                ruleNutrient.appendChild(option);
            });
        }

        // Ratio rule modal - growth stages
        const ruleStage = document.getElementById('rule-growth-stage');
        if (ruleStage) {
            ruleStage.innerHTML = '<option value="">All Stages (General)</option>';
            this.growthStages.forEach(stage => {
                const option = document.createElement('option');
                option.value = stage.code;
                option.textContent = stage.name;
                ruleStage.appendChild(option);
            });
        }

        // Environmental adjustment modal - parameters
        const adjustmentParameter = document.getElementById('adjustment-parameter');
        if (adjustmentParameter) {
            adjustmentParameter.innerHTML = '<option value="">Select Parameter</option>';
            this.environmentalParameters.forEach(param => {
                const option = document.createElement('option');
                option.value = param.code;
                option.textContent = `${param.name}${param.unit ? ` (${param.unit})` : ''}`;
                adjustmentParameter.appendChild(option);
            });
        }
    }

    // =====================================================
    // DISPLAY FUNCTIONS
    // =====================================================

    displayRatioRules() {
        const container = document.getElementById('ratio-rules-list');
        if (!container) return;

        if (this.ratioRules.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <p>No ratio rules found. Add your first rule to get started.</p>
                </div>
            `;
            return;
        }

        // Group rules by nutrient
        const nutrientGroups = {};
        this.ratioRules.forEach(rule => {
            const key = rule.nutrient_code;
            if (!nutrientGroups[key]) {
                nutrientGroups[key] = {
                    nutrient: {
                        code: rule.nutrient_code,
                        name: rule.nutrient_name,
                        symbol: rule.symbol,
                        unit: rule.unit
                    },
                    stages: []
                };
            }
            nutrientGroups[key].stages.push(rule);
        });

        // Generate consolidated nutrient cards
        const nutrientCards = Object.values(nutrientGroups).map(group => 
            this.generateConsolidatedNutrientCard(group)
        ).join('');

        container.innerHTML = nutrientCards;
    }

    generateRatioRuleCard(rule) {
        const badges = [];
        if (rule.is_default) badges.push('<span class="ratio-badge default">Default</span>');
        if (rule.priority > 0) badges.push(`<span class="ratio-badge priority">Priority: ${rule.priority}</span>`);

        // Calculate example values for 150 ppm nitrogen base
        const exampleBase = 150;
        const minExample = (exampleBase * parseFloat(rule.min_factor)).toFixed(1);
        const maxExample = (exampleBase * parseFloat(rule.max_factor)).toFixed(1);

        return `
            <div class="ratio-rule-card" data-rule-id="${rule.id}">
                <div class="ratio-rule-header">
                    <div class="ratio-rule-info">
                        <div class="ratio-rule-title">${rule.nutrient_name} (${rule.symbol})</div>
                        <div class="ratio-rule-subtitle">${rule.stage_name || 'All Stages'} ‚Ä¢ Ratio to Nitrogen (N)</div>
                    </div>
                    <div class="ratio-rule-actions">
                        <button class="btn-edit" onclick="app.nutrientRatioManager.editRatioRule(${rule.id})" title="Edit Rule">
                            <img src="icons/new-icons/Afraponix Go Icons_edit.svg" alt="Edit" style="width: 16px; height: 16px;">
                        </button>
                        <button class="btn-delete" onclick="app.nutrientRatioManager.deleteRatioRule(${rule.id})" title="Delete Rule">
                            <img src="icons/new-icons/Afraponix Go Icons_delete.svg" alt="Delete" style="width: 16px; height: 16px;">
                        </button>
                    </div>
                </div>
                
                <div class="ratio-rule-details">
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Ratio Range</div>
                        <div class="ratio-detail-value">${parseFloat(rule.min_factor)} - ${parseFloat(rule.max_factor)}</div>
                    </div>
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Example (150 ppm N)</div>
                        <div class="ratio-detail-value">${minExample} - ${maxExample} ${rule.unit}</div>
                    </div>
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Formula</div>
                        <div class="ratio-detail-value">${rule.symbol} = N √ó ratio</div>
                    </div>
                </div>
                
                ${badges.length > 0 ? `<div class="ratio-badges">${badges.join('')}</div>` : ''}
                
                ${rule.notes ? `<div class="ratio-rule-notes">${rule.notes}</div>` : ''}
            </div>
        `;
    }

    generateConsolidatedNutrientCard(group) {
        const { nutrient, stages } = group;
        
        // Smart detection: Only iron uses fixed-range ppm values
        // All others (including calcium, potassium with small ratios) are ratio-based
        const isFixedRange = (nutrient.code === 'iron');
        
        // Sort stages by priority: vegetative, flowering, fruiting, general/all
        const stageOrder = { 'vegetative': 1, 'flowering': 2, 'fruiting': 3, 'general': 4 };
        stages.sort((a, b) => {
            const orderA = stageOrder[a.stage_code] || 999;
            const orderB = stageOrder[b.stage_code] || 999;
            return orderA - orderB;
        });

        // Generate stage entries
        const stageEntries = stages.map(stage => {
            const badges = [];
            if (stage.is_default) badges.push('<span class="ratio-badge default">Default</span>');
            if (stage.priority > 0) badges.push(`<span class="ratio-badge priority">Priority: ${stage.priority}</span>`);

            let detailsContent;
            
            if (isFixedRange) {
                // For fixed-range nutrients like iron, show absolute ranges
                const minRange = parseFloat(stage.min_factor).toFixed(1);
                const maxRange = parseFloat(stage.max_factor).toFixed(1);
                
                detailsContent = `
                    <div class="stage-detail-grid">
                        <div class="stage-detail-item">
                            <span class="stage-detail-label">Fixed Range:</span>
                            <span class="stage-detail-value">${minRange} - ${maxRange} ${nutrient.unit}</span>
                        </div>
                        <div class="stage-detail-item">
                            <span class="stage-detail-label">Type:</span>
                            <span class="stage-detail-value">Absolute concentration</span>
                        </div>
                    </div>
                `;
            } else {
                // For ratio-based nutrients, show ratios and examples
                const exampleBase = 150;
                const minExample = (exampleBase * parseFloat(stage.min_factor)).toFixed(1);
                const maxExample = (exampleBase * parseFloat(stage.max_factor)).toFixed(1);
                
                detailsContent = `
                    <div class="stage-detail-grid">
                        <div class="stage-detail-item">
                            <span class="stage-detail-label">Ratio:</span>
                            <span class="stage-detail-value">${parseFloat(stage.min_factor)} - ${parseFloat(stage.max_factor)}</span>
                        </div>
                        <div class="stage-detail-item">
                            <span class="stage-detail-label">Example (150 ppm N):</span>
                            <span class="stage-detail-value">${minExample} - ${maxExample} ${nutrient.unit}</span>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="stage-ratio-entry" data-rule-id="${stage.id}">
                    <div class="stage-ratio-header">
                        <div class="stage-ratio-info">
                            <div class="stage-ratio-stage">${stage.stage_name || 'All Stages'}</div>
                            ${badges.length > 0 ? `<div class="stage-badges">${badges.join('')}</div>` : ''}
                        </div>
                        <div class="stage-ratio-actions">
                            <button class="btn-edit-small" onclick="app.nutrientRatioManager.editRatioRule(${stage.id})" title="Edit Rule">
                                <img src="icons/new-icons/Afraponix Go Icons_edit.svg" alt="Edit" style="width: 14px; height: 14px;">
                            </button>
                            <button class="btn-delete-small" onclick="app.nutrientRatioManager.deleteRatioRule(${stage.id})" title="Delete Rule">
                                <img src="icons/new-icons/Afraponix Go Icons_delete.svg" alt="Delete" style="width: 14px; height: 14px;">
                            </button>
                        </div>
                    </div>
                    
                    <div class="stage-ratio-details">
                        ${detailsContent}
                        ${stage.notes ? `<div class="stage-notes">${stage.notes}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        // Different subtitle and formula for fixed-range vs ratio-based nutrients
        const subtitle = isFixedRange 
            ? 'Fixed absolute concentrations independent of nitrogen levels'
            : 'Ratios relative to Nitrogen (N) ‚Ä¢ Formula: ' + nutrient.symbol + ' = N √ó ratio';

        return `
            <div class="consolidated-nutrient-card ${isFixedRange ? 'fixed-range-nutrient' : 'ratio-based-nutrient'}">
                <div class="nutrient-card-header">
                    <div class="nutrient-card-info">
                        <div class="nutrient-card-title">
                            ${nutrient.name} (${nutrient.symbol})
                            ${isFixedRange ? '<span class="fixed-range-badge">Fixed Range</span>' : '<span class="ratio-based-badge">Ratio Based</span>'}
                        </div>
                        <div class="nutrient-card-subtitle">${subtitle}</div>
                    </div>
                    <div class="nutrient-card-actions">
                        <button class="btn-add-stage" onclick="app.nutrientRatioManager.addRatioRuleForNutrient('${nutrient.code}')" title="Add Stage Rule">
                            <img src="icons/new-icons/Afraponix Go Icons_add.svg" alt="Add" style="width: 16px; height: 16px;">
                            Add Stage
                        </button>
                    </div>
                </div>
                
                <div class="nutrient-stages-container">
                    ${stageEntries}
                </div>
            </div>
        `;
    }

    displayEnvironmentalAdjustments() {
        const container = document.getElementById('environmental-adjustments-list');
        if (!container) return;

        if (this.environmentalAdjustments.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <p>No environmental adjustments found. Add your first adjustment to get started.</p>
                </div>
            `;
            return;
        }

        container.innerHTML = this.environmentalAdjustments.map(adj => this.generateEnvironmentalAdjustmentCard(adj)).join('');
    }

    generateEnvironmentalAdjustmentCard(adjustment) {
        const operatorDisplay = {
            '>': 'greater than',
            '<': 'less than',
            '>=': 'greater than or equal',
            '<=': 'less than or equal',
            '=': 'equal to',
            'between': 'between'
        };

        const thresholdText = adjustment.operator === 'between' && adjustment.threshold_value_max 
            ? `${adjustment.threshold_value} - ${adjustment.threshold_value_max}`
            : adjustment.threshold_value;

        const adjustmentPercent = Math.round(parseFloat(adjustment.adjustment_factor) * 100);

        return `
            <div class="env-adjustment-card" data-adjustment-id="${adjustment.id}">
                <div class="env-adjustment-header">
                    <div class="env-adjustment-info">
                        <div class="env-adjustment-title">${adjustment.parameter_name}</div>
                        <div class="env-adjustment-subtitle">
                            <span class="env-condition-badge">${adjustment.condition_name}</span>
                        </div>
                    </div>
                    <div class="ratio-rule-actions">
                        <button class="btn-edit" onclick="app.nutrientRatioManager.editEnvironmentalAdjustment(${adjustment.id})" title="Edit Adjustment">
                            <img src="icons/new-icons/Afraponix Go Icons_edit.svg" alt="Edit" style="width: 16px; height: 16px;">
                        </button>
                        <button class="btn-delete" onclick="app.nutrientRatioManager.deleteEnvironmentalAdjustment(${adjustment.id})" title="Delete Adjustment">
                            <img src="icons/new-icons/Afraponix Go Icons_delete.svg" alt="Delete" style="width: 16px; height: 16px;">
                        </button>
                    </div>
                </div>
                
                <div class="env-adjustment-details">
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Condition</div>
                        <div class="ratio-detail-value">
                            <span class="env-operator-badge">${operatorDisplay[adjustment.operator] || adjustment.operator}</span>
                            ${thresholdText}${adjustment.parameter_unit ? ` ${adjustment.parameter_unit}` : ''}
                        </div>
                    </div>
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Adjustment</div>
                        <div class="ratio-detail-value">${adjustmentPercent}% (√ó${adjustment.adjustment_factor})</div>
                    </div>
                    <div class="ratio-detail-item">
                        <div class="ratio-detail-label">Scope</div>
                        <div class="ratio-detail-value">${adjustment.applies_to_all_nutrients ? 'All Nutrients' : 'Specific Nutrients'}</div>
                    </div>
                </div>
            </div>
        `;
    }

    filterRatioRules() {
        const nutrientFilter = document.getElementById('ratio-nutrient-filter')?.value;
        const stageFilter = document.getElementById('ratio-stage-filter')?.value;

        let filteredRules = this.ratioRules;

        if (nutrientFilter) {
            filteredRules = filteredRules.filter(rule => rule.nutrient_code === nutrientFilter);
        }

        if (stageFilter) {
            filteredRules = filteredRules.filter(rule => rule.stage_code === stageFilter);
        }

        const container = document.getElementById('ratio-rules-list');
        if (container) {
            container.innerHTML = filteredRules.map(rule => this.generateRatioRuleCard(rule)).join('');
        }
    }

    // =====================================================
    // MODAL FUNCTIONS
    // =====================================================

    addRatioRuleForNutrient(nutrientCode) {
        // Pre-populate the modal with the selected nutrient
        this.showRatioRuleModal();
        
        // Set the nutrient dropdown to the specified nutrient
        const nutrientSelect = document.getElementById('ratio-nutrient-id');
        if (nutrientSelect) {
            nutrientSelect.value = this.nutrients.find(n => n.code === nutrientCode)?.id || '';
        }
    }

    showRatioRuleModal(rule = null) {
        this.currentEditingRule = rule;
        const modal = document.getElementById('ratio-rule-modal');
        const title = document.getElementById('ratio-rule-modal-title');
        
        if (rule) {
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Ratio Rule" class="heading-icon"> Edit Ratio Rule';
            this.populateRatioRuleForm(rule);
        } else {
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_chemistry.svg" alt="Ratio Rule" class="heading-icon"> Add Ratio Rule';
            this.clearRatioRuleForm();
        }
        
        modal.style.display = 'flex';
    }

    closeRatioRuleModal() {
        document.getElementById('ratio-rule-modal').style.display = 'none';
        this.currentEditingRule = null;
        this.clearRatioRuleForm();
    }

    showEnvAdjustmentModal(adjustment = null) {
        this.currentEditingAdjustment = adjustment;
        const modal = document.getElementById('env-adjustment-modal');
        const title = document.getElementById('env-adjustment-modal-title');
        
        if (adjustment) {
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_parameters.svg" alt="Environmental Adjustment" class="heading-icon"> Edit Environmental Adjustment';
            this.populateEnvAdjustmentForm(adjustment);
        } else {
            title.innerHTML = '<img src="icons/new-icons/Afraponix Go Icons_parameters.svg" alt="Environmental Adjustment" class="heading-icon"> Add Environmental Adjustment';
            this.clearEnvAdjustmentForm();
        }
        
        modal.style.display = 'flex';
    }

    closeEnvAdjustmentModal() {
        document.getElementById('env-adjustment-modal').style.display = 'none';
        this.currentEditingAdjustment = null;
        this.clearEnvAdjustmentForm();
    }

    // =====================================================
    // FORM FUNCTIONS
    // =====================================================

    clearRatioRuleForm() {
        document.getElementById('ratio-rule-form').reset();
    }

    clearEnvAdjustmentForm() {
        document.getElementById('env-adjustment-form').reset();
        document.getElementById('adjustment-applies-all').checked = true;
    }

    populateRatioRuleForm(rule) {
        document.getElementById('rule-nutrient').value = rule.nutrient_code;
        document.getElementById('rule-growth-stage').value = rule.stage_code || '';
        document.getElementById('rule-min-factor').value = rule.min_factor;
        document.getElementById('rule-max-factor').value = rule.max_factor;
        document.getElementById('rule-priority').value = rule.priority;
        document.getElementById('rule-is-default').checked = rule.is_default;
        document.getElementById('rule-notes').value = rule.notes || '';
    }

    populateEnvAdjustmentForm(adjustment) {
        document.getElementById('adjustment-parameter').value = adjustment.parameter_code;
        document.getElementById('adjustment-condition').value = adjustment.condition_name;
        document.getElementById('adjustment-operator').value = adjustment.operator;
        document.getElementById('adjustment-threshold').value = adjustment.threshold_value;
        document.getElementById('adjustment-threshold-max').value = adjustment.threshold_value_max || '';
        document.getElementById('adjustment-factor').value = adjustment.adjustment_factor;
        document.getElementById('adjustment-applies-all').checked = adjustment.applies_to_all_nutrients;
    }

    async saveRatioRule() {
        try {
            const formData = {
                nutrient_code: document.getElementById('rule-nutrient').value,
                growth_stage_code: document.getElementById('rule-growth-stage').value || null,
                min_factor: parseFloat(document.getElementById('rule-min-factor').value),
                max_factor: parseFloat(document.getElementById('rule-max-factor').value),
                priority: parseInt(document.getElementById('rule-priority').value) || 0,
                is_default: document.getElementById('rule-is-default').checked,
                notes: document.getElementById('rule-notes').value || null
            };

            // Validation
            if (!formData.nutrient_code || !formData.min_factor || !formData.max_factor) {
                throw new Error('Please fill in all required fields');
            }

            if (formData.min_factor >= formData.max_factor) {
                throw new Error('Maximum factor must be greater than minimum factor');
            }

            const isEdit = this.currentEditingRule !== null;
            const url = isEdit 
                ? `/api/crop-knowledge/admin/ratio-rules/${this.currentEditingRule.id}`
                : '/api/crop-knowledge/admin/ratio-rules';
            
            const method = isEdit ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData)
            });

            const result = await response.json();

            if (result.success) {
                app.showMessage(`Ratio rule ${isEdit ? 'updated' : 'created'} successfully`, 'success');
                this.closeRatioRuleModal();
                await this.loadRatioRules();
                this.displayRatioRules();
                this.filterRatioRules(); // Reapply filters
            } else {
                throw new Error(result.error || `Failed to ${isEdit ? 'update' : 'create'} ratio rule`);
            }
        } catch (error) {
            console.error('Error saving ratio rule:', error);
            app.showMessage(error.message, 'error');
        }
    }

    async saveEnvAdjustment() {
        try {
            const formData = {
                parameter_code: document.getElementById('adjustment-parameter').value,
                condition_name: document.getElementById('adjustment-condition').value,
                operator: document.getElementById('adjustment-operator').value,
                threshold_value: parseFloat(document.getElementById('adjustment-threshold').value),
                threshold_value_max: document.getElementById('adjustment-threshold-max').value 
                    ? parseFloat(document.getElementById('adjustment-threshold-max').value) : null,
                adjustment_factor: parseFloat(document.getElementById('adjustment-factor').value),
                applies_to_all_nutrients: document.getElementById('adjustment-applies-all').checked
            };

            // Validation
            if (!formData.parameter_code || !formData.condition_name || !formData.operator || 
                !formData.threshold_value || !formData.adjustment_factor) {
                throw new Error('Please fill in all required fields');
            }

            if (formData.operator === 'between' && !formData.threshold_value_max) {
                throw new Error('Max threshold is required for "between" operator');
            }

            const isEdit = this.currentEditingAdjustment !== null;
            
            if (isEdit) {
                // For editing, we'd need an update endpoint
                throw new Error('Editing environmental adjustments not yet implemented');
            } else {
                const response = await fetch('/api/crop-knowledge/admin/environmental-adjustments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                const result = await response.json();

                if (result.success) {
                    app.showMessage('Environmental adjustment created successfully', 'success');
                    this.closeEnvAdjustmentModal();
                    await this.loadEnvironmentalAdjustments();
                    this.displayEnvironmentalAdjustments();
                } else {
                    throw new Error(result.error || 'Failed to create environmental adjustment');
                }
            }
        } catch (error) {
            console.error('Error saving environmental adjustment:', error);
            app.showMessage(error.message, 'error');
        }
    }

    // =====================================================
    // CRUD FUNCTIONS
    // =====================================================

    async editRatioRule(ruleId) {
        const rule = this.ratioRules.find(r => r.id === ruleId);
        if (rule) {
            this.showRatioRuleModal(rule);
        }
    }

    async deleteRatioRule(ruleId) {
        if (!confirm('Are you sure you want to delete this ratio rule?')) return;

        try {
            const response = await fetch(`/api/crop-knowledge/admin/ratio-rules/${ruleId}`, {
                method: 'DELETE'
            });

            const result = await response.json();

            if (result.success) {
                app.showMessage('Ratio rule deleted successfully', 'success');
                await this.loadRatioRules();
                this.displayRatioRules();
                this.filterRatioRules(); // Reapply filters
            } else {
                throw new Error(result.error || 'Failed to delete ratio rule');
            }
        } catch (error) {
            console.error('Error deleting ratio rule:', error);
            app.showMessage(error.message, 'error');
        }
    }

    async editEnvironmentalAdjustment(adjustmentId) {
        const adjustment = this.environmentalAdjustments.find(a => a.id === adjustmentId);
        if (adjustment) {
            this.showEnvAdjustmentModal(adjustment);
        }
    }

    async deleteEnvironmentalAdjustment(adjustmentId) {
        if (!confirm('Are you sure you want to delete this environmental adjustment?')) return;

        try {
            // Note: We'd need a DELETE endpoint for environmental adjustments
            app.showMessage('Delete environmental adjustment functionality not yet implemented', 'warning');
        } catch (error) {
            console.error('Error deleting environmental adjustment:', error);
            app.showMessage(error.message, 'error');
        }
    }
}

// Initialize the nutrient ratio manager when the app loads
document.addEventListener('DOMContentLoaded', () => {
    // Wait for app to be initialized
    setTimeout(() => {
        if (window.app) {
            app.nutrientRatioManager = new NutrientRatioManager();
            
            // Add global functions for modal callbacks
            app.closeRatioRuleModal = () => app.nutrientRatioManager.closeRatioRuleModal();
            app.closeEnvAdjustmentModal = () => app.nutrientRatioManager.closeEnvAdjustmentModal();
            app.saveRatioRule = () => app.nutrientRatioManager.saveRatioRule();
            app.saveEnvAdjustment = () => app.nutrientRatioManager.saveEnvAdjustment();
            
            console.log('‚úÖ Nutrient Ratio Manager initialized');
            
            // Add global function for manual testing
            window.testNutrientRatios = () => {
                console.log('üß™ Manual test: Loading nutrient ratios...');
                app.nutrientRatioManager.loadRatioManagement();
            };
            
            // Add comprehensive nutrient modal functions
            app.openComprehensiveNutrientModal = (nutrientCode) => {
                console.log(`üîç Opening comprehensive nutrient modal for: ${nutrientCode}`);
                app.showComprehensiveNutrientInfo(nutrientCode);
            };
            
            app.closeComprehensiveNutrientModal = () => {
                const modal = document.getElementById('comprehensive-nutrient-modal');
                modal.style.display = 'none';
            };
            
            // ========================
            // DEFICIENCY IMAGES MANAGEMENT
            // ========================
            
            app.initializeDeficiencyImagesManagement = async () => {
                console.log('üñºÔ∏è Initializing deficiency images management...');
                
                try {
                    // Load all deficiency images by default
                    console.log('üîÑ Loading all deficiency images...');
                    await app.loadAllDeficiencyImages();
                    
                    // Setup event listeners for filtering
                    console.log('üîÑ Setting up filter event listeners...');
                    app.setupDeficiencyFilterEventListeners();
                    
                    console.log('‚úÖ Deficiency images management initialized successfully!');
                } catch (error) {
                    console.error('‚ùå Error initializing deficiency images management:', error);
                }
            };
            
            app.loadDeficiencyNutrientsDropdown = async () => {
                console.log('üîÑ Loading nutrients for deficiency dropdown...');
                try {
                    const response = await fetch('/api/crop-knowledge/nutrients');
                    const data = await response.json();
                    
                    console.log('üìä Nutrients API response:', data);
                    
                    const select = document.getElementById('deficiency-nutrient-select');
                    if (!select) {
                        console.error('‚ùå Deficiency nutrient select element not found');
                        return;
                    }
                    
                    select.innerHTML = '<option value="">Choose a nutrient...</option>';
                    
                    if (data.success && data.data) {
                        console.log(`‚úÖ Found ${data.data.length} nutrients for dropdown`);
                        data.data.forEach(nutrient => {
                            const option = document.createElement('option');
                            option.value = nutrient.code;
                            option.textContent = `${nutrient.name} (${nutrient.code})`;
                            select.appendChild(option);
                            console.log(`  ‚ûï Added nutrient: ${nutrient.name} (${nutrient.code})`);
                        });
                    } else {
                        if (window.errorManager) {
                            window.errorManager.warnOnce('no_nutrients_data', '‚ö†Ô∏è No nutrients data received or API call failed', this.activeSystemId);
                        } else {
                            console.warn('‚ö†Ô∏è No nutrients data received or API call failed');
                        }
                        select.innerHTML = '<option value="">No nutrients available</option>';
                    }
                } catch (error) {
                    console.error('‚ùå Error loading nutrients dropdown:', error);
                    const select = document.getElementById('deficiency-nutrient-select');
                    if (select) {
                        select.innerHTML = '<option value="">Error loading nutrients</option>';
                    }
                }
            };
            
            app.setupDeficiencyImageEventListeners = () => {
                // Nutrient selection change
                const nutrientSelect = document.getElementById('deficiency-nutrient-select');
                if (nutrientSelect) {
                    nutrientSelect.addEventListener('change', (e) => {
                        const nutrientCode = e.target.value;
                        if (nutrientCode) {
                            app.loadDeficiencyImagesForNutrient(nutrientCode);
                        } else {
                            app.showNoNutrientSelected();
                        }
                    });
                }
                
                // Refresh button
                const refreshBtn = document.getElementById('refresh-deficiency-images');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        const selectedNutrient = nutrientSelect?.value;
                        if (selectedNutrient) {
                            app.loadDeficiencyImagesForNutrient(selectedNutrient);
                        }
                    });
                }
                
                // Add new image button
                const addBtn = document.getElementById('add-deficiency-image-btn');
                if (addBtn) {
                    console.log('‚úÖ Found add deficiency image button');
                    
                    // Add visual feedback on hover when no nutrient selected
                    const updateButtonState = () => {
                        const selectedNutrient = nutrientSelect?.value;
                        if (!selectedNutrient) {
                            addBtn.title = 'Please select a nutrient from the dropdown first';
                            addBtn.style.opacity = '0.6';
                        } else {
                            addBtn.title = 'Add deficiency image for ' + selectedNutrient;
                            addBtn.style.opacity = '1';
                        }
                    };
                    
                    // Update button state initially and when nutrient changes
                    updateButtonState();
                    if (nutrientSelect) {
                        nutrientSelect.addEventListener('change', updateButtonState);
                    }
                    
                    addBtn.addEventListener('click', () => {
                        const selectedNutrient = nutrientSelect?.value;
                        console.log('üîÑ Add button clicked, selected nutrient:', selectedNutrient);
                        console.log('üîÑ Button element:', addBtn);
                        console.log('üîÑ Nutrient select element:', nutrientSelect);
                        
                        if (selectedNutrient) {
                            console.log('‚úÖ Opening modal for nutrient:', selectedNutrient);
                            app.openDeficiencyImageModal(selectedNutrient);
                        } else {
                            console.log('‚ö†Ô∏è No nutrient selected - showing warning');
                            app.showNotification('Please select a nutrient from the dropdown first', 'warning');
                        }
                    });
                } else {
                    console.log('‚ùå Add deficiency image button not found');
                }
                
                // Method tab switching
                const methodTabs = document.querySelectorAll('.method-tab');
                methodTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const method = tab.dataset.method;
                        app.switchUploadMethod(method);
                    });
                });

                // Form submission handlers (now redundant since buttons use onclick)
                const deficiencyUploadForm = document.getElementById('deficiency-image-upload-form');
                if (deficiencyUploadForm) {
                    console.log('‚úÖ Found upload form, adding event listener');
                    deficiencyUploadForm.addEventListener('submit', (e) => {
                        console.log('üîÑ Upload form submitted - PREVENTING DEFAULT');
                        e.preventDefault();
                        e.stopPropagation();
                        app.uploadDeficiencyImage();
                        return false;
                    });
                } else {
                    console.log('‚ùå Upload form not found');
                }

                const deficiencyUrlForm = document.getElementById('deficiency-image-form');
                if (deficiencyUrlForm) {
                    console.log('‚úÖ Found URL form, adding event listener');
                    deficiencyUrlForm.addEventListener('submit', (e) => {
                        console.log('üîÑ URL form submitted - PREVENTING DEFAULT');
                        e.preventDefault();
                        e.stopPropagation();
                        app.saveDeficiencyImage();
                        return false;
                    });
                } else {
                    console.log('‚ùå URL form not found');
                }
                
                // File input change
                const fileInput = document.getElementById('deficiency-file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        app.handleFileSelection(e.target.files[0]);
                    });
                    console.log('‚úÖ File input change listener attached');
                } else {
                    console.log('‚ùå File input not found');
                }
                
                // Click handler for file upload area to trigger hidden file input
                const uploadArea = document.querySelector('.file-upload-area');
                
                const triggerFileInput = (e) => {
                    console.log('üîÑ Upload area clicked, triggering file input...');
                    e.preventDefault();
                    e.stopPropagation();
                    if (fileInput) {
                        fileInput.click();
                    } else {
                        console.log('‚ùå File input not available');
                    }
                };
                
                if (uploadArea) {
                    uploadArea.addEventListener('click', triggerFileInput);
                    uploadArea.style.cursor = 'pointer';
                    console.log('‚úÖ Upload area click listener attached');
                }
                
                // Drag and drop for file upload (using existing uploadArea variable)
                if (uploadArea) {
                    uploadArea.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        uploadArea.classList.add('dragover');
                    });
                    
                    uploadArea.addEventListener('dragleave', (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('dragover');
                    });
                    
                    uploadArea.addEventListener('drop', (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('dragover');
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            app.handleFileSelection(files[0]);
                        }
                    });
                }
                
                // Form submissions
                const uploadForm = document.getElementById('deficiency-image-upload-form');
                if (uploadForm) {
                    uploadForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        app.uploadDeficiencyImage();
                    });
                }
                
                const urlForm = document.getElementById('deficiency-image-form');
                if (urlForm) {
                    urlForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        app.saveDeficiencyImage();
                    });
                }
            };
            
            // ========== NEW FILTERING EVENT LISTENERS ==========
            app.setupDeficiencyFilterEventListeners = () => {
                console.log('üîÑ Setting up deficiency filter event listeners...');
                
                // Filter dropdown change listeners
                const nutrientFilter = document.getElementById('deficiency-nutrient-filter');
                const plantFilter = document.getElementById('deficiency-plant-filter');
                const clearFiltersBtn = document.getElementById('clear-deficiency-filters');
                
                if (nutrientFilter) {
                    nutrientFilter.addEventListener('change', () => {
                        console.log('üîç Nutrient filter changed:', nutrientFilter.value);
                        app.applyDeficiencyFilters();
                    });
                    console.log('‚úÖ Nutrient filter listener attached');
                }
                
                if (plantFilter) {
                    plantFilter.addEventListener('change', () => {
                        console.log('üîç Plant filter changed:', plantFilter.value);
                        app.applyDeficiencyFilters();
                    });
                    console.log('‚úÖ Plant filter listener attached');
                }
                
                if (clearFiltersBtn) {
                    clearFiltersBtn.addEventListener('click', () => {
                        console.log('üßπ Clear filters clicked');
                        app.clearDeficiencyFilters();
                    });
                    console.log('‚úÖ Clear filters button listener attached');
                }
                
                // Add new image button (now always available)
                const addBtn = document.getElementById('add-deficiency-image-btn');
                if (addBtn) {
                    console.log('‚úÖ Found add deficiency image button');
                    
                    // Remove old restrictions - button is now always available
                    addBtn.style.opacity = '1';
                    addBtn.title = 'Add a new deficiency image';
                    
                    // Remove any existing listeners
                    const newBtn = addBtn.cloneNode(true);
                    addBtn.parentNode.replaceChild(newBtn, addBtn);
                    
                    // Add click listener
                    newBtn.addEventListener('click', (e) => {
                        console.log('üì∏ Add deficiency image button clicked');
                        e.preventDefault();
                        app.openDeficiencyImageModal(''); // Empty nutrient code for new image
                    });
                    
                    console.log('‚úÖ Add button listener attached (always available)');
                } else {
                    console.log('‚ùå Add deficiency image button not found');
                }
                
                // Refresh button
                const refreshBtn = document.getElementById('refresh-deficiency-images');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        console.log('üîÑ Refresh button clicked - reloading all images');
                        app.loadAllDeficiencyImages();
                    });
                    console.log('‚úÖ Refresh button listener attached');
                }
                
                // File input and upload area handlers (reuse from old function)
                const fileInput = document.getElementById('deficiency-file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        app.handleFileSelection(e.target.files[0]);
                    });
                    console.log('‚úÖ File input change listener attached');
                }
                
                const uploadArea = document.querySelector('.file-upload-area');
                if (uploadArea && fileInput) {
                    console.log('üîç Upload area found:', uploadArea);
                    console.log('üîç File input found:', fileInput);
                    
                    console.log('‚úÖ File input positioned for direct clicking');
                }
                
                // Form submission handlers
                const uploadForm = document.getElementById('deficiency-image-upload-form');
                if (uploadForm) {
                    uploadForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        app.uploadDeficiencyImage();
                    });
                    console.log('‚úÖ Upload form listener attached');
                }
                
                const urlForm = document.getElementById('deficiency-image-form');
                if (urlForm) {
                    urlForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        app.saveDeficiencyImage();
                    });
                    console.log('‚úÖ URL form listener attached');
                }
                
                console.log('‚úÖ All deficiency filter event listeners attached');
            };
            
            app.loadDeficiencyImagesForNutrient = async (nutrientCode) => {
                console.log('üì∏ Loading deficiency images for:', nutrientCode);
                
                try {
                    const response = await fetch(`/api/crop-knowledge/admin/nutrients/${nutrientCode}/deficiency-images`);
                    const data = await response.json();
                    
                    // Show header and grid
                    const header = document.getElementById('deficiency-header');
                    const grid = document.getElementById('deficiency-images-grid');
                    const noSelection = document.getElementById('no-nutrient-selected');
                    const title = document.getElementById('selected-nutrient-title');
                    
                    if (header) header.style.display = 'flex';
                    if (grid) grid.style.display = 'grid';
                    if (noSelection) noSelection.style.display = 'none';
                    if (title) title.textContent = `${data.nutrient_code} Deficiency Images (${data.count})`;
                    
                    // Populate images grid
                    app.populateDeficiencyImagesGrid(data.data || []);
                    
                } catch (error) {
                    console.error('Error loading deficiency images:', error);
                    app.showNotification('Error loading deficiency images', 'error');
                }
            };
            
            app.showNoNutrientSelected = () => {
                const header = document.getElementById('deficiency-header');
                const grid = document.getElementById('deficiency-images-grid');
                const noSelection = document.getElementById('no-nutrient-selected');
                
                if (header) header.style.display = 'none';
                if (grid) grid.style.display = 'none';
                if (noSelection) noSelection.style.display = 'block';
            };
            
            app.populateDeficiencyImagesGrid = (images) => {
                const grid = document.getElementById('deficiency-images-grid');
                if (!grid) return;
                
                if (images.length === 0) {
                    grid.innerHTML = `
                        <div class="no-data-message">
                            <img src="icons/new-icons/Afraponix Go Icons_plant.svg" alt="No Images" class="no-data-icon">
                            <h4 class="heading-4">No Images Found</h4>
                            <p class="text-muted">No deficiency images have been added for this nutrient yet. Click "Add Deficiency Image" to get started.</p>
                        </div>
                    `;
                    return;
                }
                
                grid.innerHTML = images.map(image => `
                    <div class="deficiency-image-card">
                        <img src="${image.image_url}" alt="${image.caption}" class="deficiency-image-preview" 
                             onclick="app.openLightbox('${image.image_url}', '${image.caption}', '${image.nutrient_name}', '${image.crop_name || 'No specific crop'}')"
                             onerror="this.src='data:image/svg+xml,<svg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 200 200\\'><rect fill=\\'%23f3f4f6\\' width=\\'200\\' height=\\'200\\'/><text x=\\'100\\' y=\\'100\\' text-anchor=\\'middle\\' dy=\\'.3em\\' fill=\\'%236b7280\\'>No Image</text></svg>'">
                        <div class="deficiency-image-info">
                            <div class="deficiency-stage-badge ${image.deficiency_stage}">${image.deficiency_stage.toUpperCase()}</div>
                            <div class="deficiency-image-caption">${image.caption}</div>
                            <div class="deficiency-image-meta">
                                ${image.crop_name && image.crop_name.trim() ? `<span class="deficiency-meta-item">üå± ${image.crop_name}</span>` : '<span class="deficiency-meta-item text-muted">No specific crop</span>'}
                                <span class="deficiency-meta-item">${image.image_filename}</span>
                            </div>
                            <div class="deficiency-image-actions">
                                <button class="btn btn-primary" style="background-color: #007bff !important; border: 1px solid #007bff !important; color: white !important; padding: 6px 12px !important; border-radius: 4px !important; font-size: 13px !important; font-weight: 500 !important; display: inline-flex !important; align-items: center !important; gap: 6px !important; cursor: pointer !important; height: auto !important; line-height: normal !important; min-width: auto !important; width: auto !important;" onclick="app.editDeficiencyImage(${image.id})">
                                    <img src="icons/new-icons/Afraponix Go Icons_edit.svg" alt="Edit" class="btn-icon" style="width: 14px; height: 14px;">
                                    Edit
                                </button>
                                <button class="btn btn-danger" style="background-color: #dc3545 !important; border: 1px solid #dc3545 !important; color: white !important; padding: 6px 12px !important; border-radius: 4px !important; font-size: 13px !important; font-weight: 500 !important; display: inline-flex !important; align-items: center !important; gap: 6px !important; cursor: pointer !important; height: auto !important; line-height: normal !important; min-width: auto !important; width: auto !important;" onclick="app.deleteDeficiencyImage(${image.id}, '${image.nutrient_code}')">
                                    <img src="icons/new-icons/Afraponix Go Icons_delete.svg" alt="Delete" class="btn-icon" style="width: 14px; height: 14px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('');
            };
            
            app.switchUploadMethod = (method) => {
                console.log('üîÑ Switching upload method to:', method);
                
                // Save current shared form data before switching
                const sharedData = {
                    caption: document.getElementById('deficiency-caption')?.value || '',
                    stage: document.getElementById('deficiency-stage')?.value || '',
                    cropId: document.getElementById('deficiency-crop-id')?.value || '',
                    nutrientCode: document.getElementById('deficiency-nutrient-code')?.value || '',
                    imageId: document.getElementById('deficiency-image-id')?.value || ''
                };
                
                console.log('üíæ Preserving shared data:', sharedData);
                
                // Update tabs
                document.querySelectorAll('.method-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.method === method);
                });
                
                // Update forms
                document.querySelectorAll('.upload-method').forEach(form => {
                    form.classList.toggle('active', form.dataset.method === method);
                });
                
                // Restore shared data after a brief delay to ensure elements are visible
                setTimeout(() => {
                    if (document.getElementById('deficiency-caption')) {
                        document.getElementById('deficiency-caption').value = sharedData.caption;
                    }
                    if (document.getElementById('deficiency-stage')) {
                        document.getElementById('deficiency-stage').value = sharedData.stage;
                    }
                    if (document.getElementById('deficiency-crop-id')) {
                        document.getElementById('deficiency-crop-id').value = sharedData.cropId;
                    }
                    if (document.getElementById('deficiency-nutrient-code')) {
                        document.getElementById('deficiency-nutrient-code').value = sharedData.nutrientCode;
                    }
                    if (document.getElementById('deficiency-image-id')) {
                        document.getElementById('deficiency-image-id').value = sharedData.imageId;
                    }
                    console.log('‚úÖ Shared data restored after tab switch');
                }, 50);
            };
            
            app.handleFileSelection = (file) => {
                if (!file) return;
                
                // Validate file type
                const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
                if (!allowedTypes.includes(file.type)) {
                    app.showNotification('Please select an image file (JPEG, PNG, GIF, WebP)', 'error');
                    return;
                }
                
                // Validate file size (5MB)
                if (file.size > 5 * 1024 * 1024) {
                    app.showNotification('File size must be less than 5MB', 'error');
                    return;
                }
                
                // Show file preview
                const preview = document.getElementById('file-preview');
                const previewImg = document.getElementById('preview-image');
                const fileName = document.getElementById('file-name');
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewImg.src = e.target.result;
                    fileName.textContent = file.name;
                    preview.style.display = 'flex';
                };
                reader.readAsDataURL(file);
            };
            
            app.uploadDeficiencyImage = async () => {
                const nutrientCode = document.getElementById('upload-nutrient-select').value;
                const fileInput = document.getElementById('deficiency-file-input');
                const file = fileInput.files[0];
                
                if (!nutrientCode) {
                    app.showNotification('Please select a nutrient deficiency', 'error');
                    return;
                }
                
                if (!file) {
                    app.showNotification('Please select an image file', 'error');
                    return;
                }
                
                const deficiencyStage = document.getElementById('upload-deficiency-stage').value;
                if (!deficiencyStage) {
                    app.showNotification('Please select a deficiency stage', 'error');
                    return;
                }
                
                const formData = new FormData();
                formData.append('deficiency_image', file);
                formData.append('deficiency_stage', deficiencyStage);
                formData.append('caption', document.getElementById('upload-caption').value);
                formData.append('plant_id', document.getElementById('upload-crop-id').value || ''); // Actually crop_id from master crops table
                
                try {
                    const response = await fetch(`/api/crop-knowledge/admin/nutrients/${nutrientCode}/deficiency-images/upload`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        app.showNotification('Image uploaded successfully', 'success');
                        app.closeDeficiencyImageModal();
                        app.loadAllDeficiencyImages(); // Refresh all images to show new addition
                    } else {
                        app.showNotification(result.error || 'Failed to upload image', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error uploading deficiency image:', error);
                    app.showNotification('Error uploading image', 'error');
                }
            };
            
            app.openDeficiencyImageModal = async (nutrientCode, imageData = null) => {
                console.log('üîÑ Opening deficiency image modal for:', nutrientCode, imageData ? 'EDIT MODE' : 'ADD MODE');
                
                const modal = document.getElementById('deficiency-image-modal');
                const title = document.getElementById('deficiency-modal-title');
                
                console.log('üîç Modal element found:', modal);
                console.log('üîç Title element found:', title);
                
                if (!modal) {
                    console.error('‚ùå Modal element not found');
                    app.showNotification('Modal element not found - please refresh the page', 'error');
                    return;
                }
                
                if (!title) {
                    console.error('‚ùå Modal title element not found');
                    app.showNotification('Modal title element not found - please refresh the page', 'error');
                    return;
                }
                
                // Load plants and nutrients for both dropdowns
                console.log('üîÑ Loading plants and nutrients for modal...');
                try {
                    await app.loadPlantsForDeficiencyModal();
                    await app.loadNutrientsForDeficiencyModal();
                    console.log('‚úÖ Plants and nutrients loaded successfully');
                } catch (error) {
                    console.error('‚ùå Error loading dropdown data:', error);
                    app.showNotification('Warning: Could not load dropdown data', 'warning');
                }
                
                if (imageData) {
                    // Edit mode - set ALL form values BEFORE switching method to preserve them
                    title.textContent = 'Edit Deficiency Image';
                    document.getElementById('deficiency-image-id').value = imageData.id;
                    document.getElementById('deficiency-nutrient-code').value = nutrientCode;
                    document.getElementById('deficiency-filename').value = imageData.image_filename;
                    document.getElementById('deficiency-url').value = imageData.image_url;
                    document.getElementById('deficiency-caption').value = imageData.caption;
                    document.getElementById('deficiency-stage').value = imageData.deficiency_stage;
                    
                    // Set crop dropdown BEFORE switching method to preserve it
                    const cropDropdown = document.getElementById('deficiency-crop-id');
                    const plantId = imageData.plant_id || imageData.crop_id || null;
                    console.log('üîß Available plant/crop ID fields:', {
                        plant_id: imageData.plant_id,
                        crop_id: imageData.crop_id,
                        resolved: plantId
                    });
                    
                    if (cropDropdown && plantId) {
                        cropDropdown.value = plantId;
                        console.log('üîß Crop ID set BEFORE switchUploadMethod:', plantId);
                    } else {
                        console.log('üîß No crop ID to set - cropDropdown:', !!cropDropdown, 'plantId:', plantId);
                    }
                    
                    console.log('üîß Image ID set BEFORE switchUploadMethod:', imageData.id);
                    
                    app.switchUploadMethod('url');
                    
                    // Verify form values after switchUploadMethod
                    setTimeout(() => {
                        const finalImageId = document.getElementById('deficiency-image-id').value;
                        const finalCropId = document.getElementById('deficiency-crop-id').value;
                        console.log('üîß Image ID AFTER switchUploadMethod:', finalImageId);
                        console.log('üîß Crop ID AFTER switchUploadMethod:', finalCropId);
                    }, 100);
                    
                    // Set nutrient dropdown in edit form
                    const nutrientDropdown = document.getElementById('edit-nutrient-select');
                    if (nutrientDropdown && nutrientCode) {
                        nutrientDropdown.value = nutrientCode;
                        console.log('üìã Nutrient dropdown set to:', nutrientCode);
                    }
                } else {
                    // Add mode - switch to upload method
                    title.textContent = 'Add Deficiency Image';
                    app.switchUploadMethod('upload');
                    
                    // Reset specific fields instead of entire forms to preserve shared data
                    document.getElementById('deficiency-image-upload-form').reset();
                    document.getElementById('deficiency-image-form').reset();
                    
                    // Clear dropdowns for new image
                    const uploadNutrientDropdown = document.getElementById('upload-nutrient-select');
                    const editNutrientDropdown = document.getElementById('edit-nutrient-select');
                    if (uploadNutrientDropdown) uploadNutrientDropdown.value = '';
                    if (editNutrientDropdown) editNutrientDropdown.value = '';
                    
                    // Set common values for both forms (legacy hidden fields)
                    document.getElementById('upload-nutrient-code').value = '';
                    document.getElementById('deficiency-nutrient-code').value = '';
                    document.getElementById('deficiency-image-id').value = '';
                    
                    // Hide file preview
                    document.getElementById('file-preview').style.display = 'none';
                }
                
                console.log('üîÑ Setting modal display to flex...');
                
                // Force modal to be visible with aggressive styling
                modal.style.display = 'flex';
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.zIndex = '99999';
                modal.style.background = 'rgba(0, 0, 0, 0.7)';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                
                console.log('‚úÖ Modal display set to:', modal.style.display);
                console.log('üîç Modal computed style display:', window.getComputedStyle(modal).display);
                console.log('üîç Modal visibility:', window.getComputedStyle(modal).visibility);
                console.log('üîç Modal z-index:', window.getComputedStyle(modal).zIndex);
                
                // Also force the modal content to be visible
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.display = 'block';
                    modalContent.style.visibility = 'visible';
                    modalContent.style.opacity = '1';
                    console.log('‚úÖ Modal content made visible');
                } else {
                    console.error('‚ùå Modal content element not found');
                }
            };
            
            app.loadPlantsForDeficiencyModal = async () => {
                try {
                    console.log('üå± Loading crops for deficiency modal...');
                    
                    // Fetch crops data from the master crops table
                    const response = await fetch('/api/crop-knowledge/crops');
                    
                    if (!response.ok) {
                        console.warn(`Failed to fetch crops: ${response.status} ${response.statusText}`);
                        // Still populate empty dropdowns
                        const uploadSelect = document.getElementById('upload-crop-id');
                        const editSelect = document.getElementById('deficiency-crop-id');
                        [uploadSelect, editSelect].forEach(select => {
                            if (select) select.innerHTML = '<option value="">No specific crop</option>';
                        });
                        return;
                    }
                    
                    const data = await response.json();
                    
                    const uploadSelect = document.getElementById('upload-crop-id');
                    const editSelect = document.getElementById('deficiency-crop-id');
                    
                    if (!uploadSelect || !editSelect) {
                        if (window.errorManager) {
                            window.errorManager.warnOnce('crop_selects_missing', 'Crop select elements not found', this.activeSystemId);
                        } else {
                            console.warn('Crop select elements not found');
                        }
                        return;
                    }
                    
                    // Clear existing options (except default)
                    [uploadSelect, editSelect].forEach(select => {
                        select.innerHTML = '<option value="">No specific crop</option>';
                    });
                    
                    if (data.success && data.data && data.data.length > 0) {
                        console.log(`‚úÖ Found ${data.data.length} crops`);
                        
                        // Group crops by category
                        const cropsByCategory = {};
                        data.data.forEach(crop => {
                            const categoryKey = crop.category_name || 'Other';
                            if (!cropsByCategory[categoryKey]) cropsByCategory[categoryKey] = [];
                            cropsByCategory[categoryKey].push(crop);
                        });
                        
                        // Add options for each crop, grouped by category
                        Object.keys(cropsByCategory).sort().forEach(categoryName => {
                            const crops = cropsByCategory[categoryName];
                            
                            [uploadSelect, editSelect].forEach(select => {
                                // Add category header if more than one category
                                if (Object.keys(cropsByCategory).length > 1) {
                                    const categoryHeader = document.createElement('optgroup');
                                    categoryHeader.label = categoryName;
                                    
                                    crops.forEach(crop => {
                                        const option = document.createElement('option');
                                        option.value = crop.id;
                                        option.textContent = `${crop.name} (${crop.code})`;
                                        categoryHeader.appendChild(option);
                                    });
                                    
                                    select.appendChild(categoryHeader);
                                } else {
                                    // If only one category, add crops directly
                                    crops.forEach(crop => {
                                        const option = document.createElement('option');
                                        option.value = crop.id;
                                        option.textContent = `${crop.name} (${crop.code})`;
                                        select.appendChild(option);
                                    });
                                }
                            });
                        });
                        
                        console.log('‚úÖ Crop dropdowns populated successfully');
                    } else {
                        console.log('‚ÑπÔ∏è No crops found in master database');
                        [uploadSelect, editSelect].forEach(select => {
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'No crops available';
                            option.disabled = true;
                            select.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Error loading crops for deficiency modal:', error);
                    // Still populate empty dropdowns on error
                    const uploadSelect = document.getElementById('upload-crop-id');
                    const editSelect = document.getElementById('deficiency-crop-id');
                    [uploadSelect, editSelect].forEach(select => {
                        if (select) select.innerHTML = '<option value="">No specific crop</option>';
                    });
                }
            };
            
            app.loadNutrientsForDeficiencyModal = async () => {
                try {
                    console.log('üîÑ Loading nutrients for deficiency modal...');
                    
                    const response = await fetch('/api/crop-knowledge/nutrients');
                    const data = await response.json();
                    
                    if (data.success && data.data) {
                        console.log(`‚úÖ Found ${data.data.length} nutrients for modal`);
                        
                        // Populate both upload and edit form nutrient dropdowns
                        const uploadSelect = document.getElementById('upload-nutrient-select');
                        const editSelect = document.getElementById('edit-nutrient-select');
                        
                        [uploadSelect, editSelect].forEach(select => {
                            if (select) {
                                select.innerHTML = '<option value="">Select nutrient...</option>';
                                data.data.forEach(nutrient => {
                                    const option = document.createElement('option');
                                    option.value = nutrient.code;
                                    option.textContent = `${nutrient.name} (${nutrient.code})`;
                                    select.appendChild(option);
                                });
                                console.log(`‚úÖ Populated ${select.id} with ${data.data.length} nutrients`);
                            }
                        });
                    } else {
                        if (window.errorManager) {
                            window.errorManager.warnOnce('no_nutrients_data', '‚ö†Ô∏è No nutrients data received or API call failed', this.activeSystemId);
                        } else {
                            console.warn('‚ö†Ô∏è No nutrients data received or API call failed');
                        }
                        const uploadSelect = document.getElementById('upload-nutrient-select');
                        const editSelect = document.getElementById('edit-nutrient-select');
                        [uploadSelect, editSelect].forEach(select => {
                            if (select) select.innerHTML = '<option value="">No nutrients available</option>';
                        });
                    }
                } catch (error) {
                    console.error('Error loading nutrients for deficiency modal:', error);
                    // Still populate empty dropdowns on error
                    const uploadSelect = document.getElementById('upload-nutrient-select');
                    const editSelect = document.getElementById('edit-nutrient-select');
                    [uploadSelect, editSelect].forEach(select => {
                        if (select) select.innerHTML = '<option value="">Error loading nutrients</option>';
                    });
                }
            };
            
            app.editDeficiencyImage = async (imageId) => {
                console.log('üîÑ editDeficiencyImage called for ID:', imageId);
                
                try {
                    // Find image data from our stored array
                    if (!app.allDeficiencyImages) {
                        console.log('‚ùå No images loaded yet, loading all images first...');
                        await app.loadAllDeficiencyImages();
                    }
                    
                    const imageData = app.allDeficiencyImages.find(img => img.id === imageId);
                    
                    if (imageData) {
                        console.log('‚úÖ Found image data:', imageData);
                        console.log('üîç Full imageData object:', imageData);
                        console.log('üîç Nutrient code:', imageData.nutrient_code);
                        console.log('üîç Plant ID in image data:', imageData.plant_id);
                        console.log('üîç All imageData keys:', Object.keys(imageData));
                        
                        app.openDeficiencyImageModal(imageData.nutrient_code, imageData);
                    } else {
                        console.log('‚ùå No image found with ID:', imageId);
                        app.showNotification('Image not found', 'error');
                    }
                } catch (error) {
                    console.error('Error loading image for edit:', error);
                    app.showNotification('Error loading image data', 'error');
                }
            };
            
            app.saveDeficiencyImage = async () => {
                console.log('üîÑ saveDeficiencyImage called');
                
                const imageIdElement = document.getElementById('deficiency-image-id');
                const imageId = imageIdElement ? imageIdElement.value : null;
                const nutrientCode = document.getElementById('edit-nutrient-select').value;
                const isEdit = !!imageId;
                
                console.log('üîç Image ID element:', imageIdElement);
                console.log('üîç Image ID value:', imageId, 'type:', typeof imageId);
                console.log('üîç IsEdit calculation:', !!imageId);
                
                if (!nutrientCode) {
                    app.showNotification('Please select a nutrient deficiency', 'error');
                    return;
                }
                
                console.log('üìã Form data:', { imageId, nutrientCode, isEdit });
                
                const plantId = document.getElementById('deficiency-crop-id').value;
                const cropDropdown = document.getElementById('deficiency-crop-id');
                console.log('üå± Crop dropdown element:', cropDropdown);
                console.log('üå± Crop ID from dropdown:', plantId, 'type:', typeof plantId);
                console.log('üå± Dropdown selected index:', cropDropdown?.selectedIndex);
                console.log('üå± Selected option text:', cropDropdown?.options[cropDropdown.selectedIndex]?.text);
                
                const imageData = {
                    image_filename: document.getElementById('deficiency-filename').value,
                    image_url: document.getElementById('deficiency-url').value,
                    caption: document.getElementById('deficiency-caption').value,
                    deficiency_stage: document.getElementById('deficiency-stage').value,
                    plant_type: null,
                    crop_specific: null,
                    plant_id: plantId || null, // Actually crop_id from master crops table
                    system_id: null, // Not needed for master crop association
                    grow_bed_id: null // Not needed for master crop association
                };
                
                console.log('üì§ Image data to save:', imageData);
                
                try {
                    const url = isEdit 
                        ? `/api/crop-knowledge/admin/deficiency-images/${imageId}`
                        : `/api/crop-knowledge/admin/nutrients/${nutrientCode}/deficiency-images`;
                    
                    const method = isEdit ? 'PUT' : 'POST';
                    
                    console.log('üåê Making HTTP request:', {
                        url,
                        method,
                        imageData
                    });
                    
                    const response = await fetch(url, {
                        method,
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(imageData)
                    });
                    
                    console.log('üåê HTTP response status:', response.status);
                    console.log('üåê HTTP response ok:', response.ok);
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        app.showNotification(isEdit ? 'Image updated successfully' : 'Image added successfully', 'success');
                        app.closeDeficiencyImageModal();
                        // Force refresh with cache bust to ensure we get updated data
                        app.loadAllDeficiencyImages(); // Refresh all images to show changes
                    } else {
                        app.showNotification(result.error || 'Failed to save image', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error saving deficiency image:', error);
                    app.showNotification('Error saving image', 'error');
                }
            };
            
            app.deleteDeficiencyImage = async (imageId, nutrientCode) => {
                if (!confirm('Are you sure you want to delete this deficiency image? This action cannot be undone.')) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/crop-knowledge/admin/deficiency-images/${imageId}`, {
                        method: 'DELETE'
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        app.showNotification('Image deleted successfully', 'success');
                        app.loadAllDeficiencyImages(); // Refresh all images to show deletion
                    } else {
                        app.showNotification(result.error || 'Failed to delete image', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error deleting deficiency image:', error);
                    app.showNotification('Error deleting image', 'error');
                }
            };
            
            window.closeDeficiencyImageModal = () => {
                app.closeDeficiencyImageModal();
            };
            
            app.closeDeficiencyImageModal = () => {
                const modal = document.getElementById('deficiency-image-modal');
                modal.style.display = 'none';
            };
            
            // Initialize deficiency management when the admin deficiency tab is clicked
            document.addEventListener('DOMContentLoaded', () => {
                console.log('üîÑ DOM loaded, setting up deficiency tab listeners...');
                
                // Ensure modal is hidden on page load
                const modal = document.getElementById('deficiency-image-modal');
                if (modal) {
                    modal.style.display = 'none';
                    console.log('‚úÖ Modal hidden on page load');
                }
                
                const deficiencySubtab = document.getElementById('admin-deficiency-subtab');
                console.log('üîç Looking for deficiency subtab:', deficiencySubtab);
                
                if (deficiencySubtab) {
                    console.log('‚úÖ Found deficiency subtab, attaching click listener...');
                    deficiencySubtab.addEventListener('click', () => {
                        console.log('üñºÔ∏è Deficiency Images tab clicked');
                        
                        // Try multiple times with increasing delays to ensure tab content is loaded
                        const attemptInit = (attempt = 1, maxAttempts = 5) => {
                            setTimeout(() => {
                                const subcontent = document.getElementById('admin-deficiency-subcontent');
                                const dropdown = document.getElementById('deficiency-nutrient-select');
                                
                                console.log(`üîÑ Attempt ${attempt}: subcontent active: ${subcontent?.classList.contains('active')}, dropdown exists: ${!!dropdown}`);
                                
                                if (subcontent && dropdown) {
                                    console.log('‚úÖ Deficiency content ready, initializing...');
                                    app.initializeDeficiencyImagesManagement();
                                } else if (attempt < maxAttempts) {
                                    console.log(`‚è≥ Retrying initialization (${attempt}/${maxAttempts})...`);
                                    attemptInit(attempt + 1, maxAttempts);
                                } else {
                                    console.log('‚ùå Max attempts reached, trying backup auto-init...');
                                    setTimeout(() => window.autoInitDeficiencyImages(), 500);
                                }
                            }, attempt * 200); // Increasing delay: 200ms, 400ms, 600ms, etc.
                        };
                        
                        attemptInit();
                    });
                } else {
                    console.log('‚ùå Deficiency subtab element not found');
                    // Try again later in case DOM isn't fully ready
                    setTimeout(() => {
                        const laterSubtab = document.getElementById('admin-deficiency-subtab');
                        console.log('üîÑ Retrying subtab search later:', laterSubtab);
                        if (laterSubtab) {
                            console.log('‚úÖ Found subtab on retry, attaching listener...');
                            laterSubtab.addEventListener('click', () => {
                                console.log('üñºÔ∏è Deficiency Images tab clicked (retry listener)');
                                window.forceInitDeficiencyImages();
                            });
                        }
                    }, 3000);
                }
                
                // Also try auto-init when page loads if we're already on deficiency tab
                setTimeout(() => {
                    if (window.autoInitDeficiencyImages()) {
                        console.log('‚úÖ Auto-initialized deficiency images on page load');
                    }
                }, 2000);
            });

            // Also try immediate setup in case DOM is already loaded
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                console.log('üîÑ DOM already ready, trying immediate setup...');
                setTimeout(() => {
                    const immediateSubtab = document.getElementById('admin-deficiency-subtab');
                    console.log('üîç Immediate subtab search:', immediateSubtab);
                    if (immediateSubtab && !immediateSubtab.dataset.listenerAttached) {
                        console.log('‚úÖ Attaching immediate listener...');
                        immediateSubtab.addEventListener('click', () => {
                            console.log('üñºÔ∏è Deficiency Images tab clicked (immediate listener)');
                            window.forceInitDeficiencyImages();
                        });
                        immediateSubtab.dataset.listenerAttached = 'true';
                    }
                }, 500);
            }
            
        }
    }, 100);
});

// Global test function for deficiency images (available immediately)
window.testDeficiencyImages = () => {
    console.log('üß™ Manual test: Initializing deficiency images management...');
    setTimeout(() => {
        if (window.app && window.app.initializeDeficiencyImagesManagement) {
            window.app.initializeDeficiencyImagesManagement();
        } else {
            console.error('‚ùå App or initializeDeficiencyImagesManagement not available yet. Try again in a few seconds.');
        }
    }, 1000);
};

// Also trigger automatically when on deficiency page
window.autoInitDeficiencyImages = () => {
    const deficiencySelect = document.getElementById('deficiency-nutrient-select');
    if (deficiencySelect && window.app && window.app.initializeDeficiencyImagesManagement) {
        console.log('üîÑ Auto-initializing deficiency images on page...');
        window.app.initializeDeficiencyImagesManagement();
        return true;
    }
    return false;
};

// Quick test function - call this from browser console
window.testDeficiencyButton = () => {
    console.log('üß™ Testing deficiency button functionality...');
    const button = document.getElementById('add-deficiency-image-btn');
    const dropdown = document.getElementById('deficiency-nutrient-select');
    
    if (!button) {
        console.log('‚ùå Button not found - run window.forceInitDeficiencyImages() first');
        return;
    }
    
    if (!dropdown || !dropdown.value) {
        console.log('‚ö†Ô∏è No nutrient selected - selecting first option...');
        if (dropdown && dropdown.options.length > 1) {
            dropdown.selectedIndex = 1; // Select first non-empty option
            dropdown.dispatchEvent(new Event('change'));
        }
    }
    
    console.log('üîÑ Clicking button...');
    button.click();
};

// Manual testing function - call from browser console if needed
window.forceInitDeficiencyImages = () => {
    console.log('üîß FORCE: Manually initializing deficiency images...');
    console.log('üîç Current tab location:', window.location.hash);
    
    // Check if elements exist
    const dropdown = document.getElementById('deficiency-nutrient-select');
    const button = document.getElementById('add-deficiency-image-btn');
    const subcontent = document.getElementById('admin-deficiency-subcontent');
    
    console.log('üîç Elements found:');
    console.log('  - Dropdown:', !!dropdown);
    console.log('  - Add Button:', !!button);
    console.log('  - Subcontent:', !!subcontent);
    console.log('  - Subcontent active:', subcontent?.classList.contains('active'));
    
    if (window.app && window.app.initializeDeficiencyImagesManagement) {
        console.log('‚úÖ Forcing initialization...');
        window.app.initializeDeficiencyImagesManagement();
        
        // Also test button click after initialization
        setTimeout(() => {
            if (button) {
                console.log('üß™ Testing button click...');
                button.click();
            }
        }, 1000);
    } else {
        console.log('‚ùå App or initialization function not available');
    }
};


// Simple dropdown population function for immediate use
window.populateNutrientDropdown = async () => {
    console.log('üîÑ Direct dropdown population...');
    try {
        const response = await fetch('/api/crop-knowledge/nutrients');
        const data = await response.json();
        
        const select = document.getElementById('deficiency-nutrient-select');
        if (!select) {
            console.error('‚ùå Deficiency nutrient select element not found');
            return;
        }
        
        select.innerHTML = '<option value="">Choose a nutrient...</option>';
        
        if (data.success && data.data) {
            console.log(`‚úÖ Found ${data.data.length} nutrients for dropdown`);
            data.data.forEach(nutrient => {
                const option = document.createElement('option');
                option.value = nutrient.code;
                option.textContent = `${nutrient.name} (${nutrient.code})`;
                select.appendChild(option);
                console.log(`  ‚ûï Added nutrient: ${nutrient.name} (${nutrient.code})`);
            });
            console.log('‚úÖ Dropdown populated successfully!');
        } else {
            if (window.errorManager) {
                window.errorManager.warnOnce('no_nutrients_data_simple', '‚ö†Ô∏è No nutrients data received', this.activeSystemId);
            } else {
                console.warn('‚ö†Ô∏è No nutrients data received');
            }
            select.innerHTML = '<option value="">No nutrients available</option>';
        }
    } catch (error) {
        console.error('‚ùå Error loading nutrients:', error);
        const select = document.getElementById('deficiency-nutrient-select');
        if (select) {
            select.innerHTML = '<option value="">Error loading nutrients</option>';
        }
    }
};

// Auto-trigger when deficiency dropdown is visible
setInterval(() => {
    const select = document.getElementById('deficiency-nutrient-select');
    if (select && select.style.display !== 'none' && select.offsetParent !== null) {
        // Element is visible
        if (select.children.length <= 1 && !select.dataset.populated) {
            console.log('üîç Deficiency dropdown detected empty and visible - auto-populating...');
            select.dataset.populated = 'true';
            window.populateNutrientDropdown();
        }
    }
}, 2000); // Check every 2 seconds